<!doctype html>
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Imagi-World 2.0 — Complete 62 Reasoning Types with Cross-Type Matching</title>
<style>
  :root{
    --bg:#0b132b;--panel:#1c2541;--ink:#e0e6f3;--accent:#5bc0be;--warn:#ff6b6b;--ok:#2ecc71;--muted:#94a3b8
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--ink);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,Helvetica,Arial,"Apple Color Emoji","Segoe UI Emoji"}
  header{padding:20px 16px;text-align:center;border-bottom:1px solid #223}
  h1{margin:0;font-size:clamp(20px,3vw,28px)}
  .wrap{max-width:1200px;margin:0 auto;padding:16px}
  .grid{display:grid;grid-template-columns:1fr;gap:16px}
  @media(min-width:880px){.grid{grid-template-columns:360px 1fr}}
  .card{background:var(--panel);border:1px solid #2a335a;border-radius:12px;box-shadow:0 6px 16px rgba(0,0,0,.25)}
  .pad{padding:16px}
  .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap;margin:8px 0}
  label{display:block;margin:8px 0 4px}
  label span{color:var(--muted);font-size:.9rem}
  input[type=range]{width:100%}
  input[type=number]{width:96px;padding:8px;border-radius:8px;border:1px solid #334;background:#0f1835;color:var(--ink)}
  button{cursor:pointer;border:0;border-radius:10px;padding:10px 14px;font-weight:700}
  .btn{background:var(--accent);color:#062025}
  .btn.secondary{background:#324063;color:#cbd5e1}
  .btn.danger{background:#c0392b;color:white}
  .btn.ghost{background:transparent;border:1px solid #3a466b;color:#cbd5e1}
  .status{font-size:1.1rem;margin:.5rem 0;color:#cbd5e1;min-height:2em}
  .premise-container{background:#0d1736;border:1px solid #334;border-radius:10px;padding:12px;margin:12px 0;min-height:120px}
  .premise{font-size:1.3rem;line-height:1.5;margin:6px 0;color:#e0e6f3}
  .premise-number{color:var(--accent);font-weight:bold;margin-right:8px}
  .bigbtns{display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-top:12px}
  .bigbtns button{padding:18px 16px;font-size:1.2rem}
  .bigbtns .yes{background:var(--ok);color:#052b16}
  .bigbtns .no{background:var(--warn);color:#2b0505}
  .stats{display:grid;grid-template-columns:repeat(auto-fit,minmax(110px,1fr));gap:10px;margin-top:12px}
  .stat{background:#0d1736;border:1px solid #223;border-radius:10px;padding:10px;text-align:center}
  .kpi{font-size:1.5rem;font-weight:800;color:var(--accent)}
  .log{max-height:300px;overflow:auto;background:#081026;border:1px dashed #2a335a;border-radius:10px;padding:10px;font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;font-size:.9rem}
  details{background:#101a39;border-radius:10px;margin-top:10px}
  summary{cursor:pointer;padding:10px 12px;border-bottom:1px solid #202a56}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;font-size:.92rem}
  .timer-bar{height:6px;background:#223;border-radius:3px;margin:10px 0;position:relative;overflow:hidden}
  .timer-progress{height:100%;background:var(--accent);width:100%;transition:width linear}
  .match-indicator{display:inline-block;margin-left:10px;padding:2px 6px;border-radius:4px;font-size:0.8rem;font-weight:bold}
  .match-indicator.cross-type{background:#ff6b6b;color:white}
  .match-indicator.same-type{background:#5bc0be;color:#062025}
  .match-indicator.structural{background:#9b59b6;color:white}
</style>
</head>
<body>
  <header>
    <h1>Imagi-World 2.0 · Complete 62 Reasoning Types</h1>
    <p class="mono">Cross-type structural matching enabled. N-back matches work across all 62 logic types based on structural equivalence.</p>
  </header>
  <div class="wrap">
    <div class="grid">
      <section class="card pad" aria-label="controls">
        <h2 style="margin-top:0">Session Configuration</h2>
        
        <label for="nback">N-Back Level <span id="nbackV">2</span></label>
        <input id="nback" type="range" min="1" max="5" step="1" value="2" />

        <label for="sec">Seconds per Trial <span id="secV">10</span></label>
        <div class="row">
          <input id="sec" type="range" min="3" max="30" step="0.5" value="10" />
          <input id="secNum" type="number" min="3" max="30" step="0.5" value="10" />
        </div>

        <label for="premises">Premises per Trial <span id="premisesV">1</span></label>
        <div class="row">
          <input id="premises" type="range" min="1" max="5" step="1" value="1" />
          <input id="premisesNum" type="number" min="1" max="5" step="1" value="1" />
        </div>

        <label for="trials">Trials per Session <span id="trialsV">10</span></label>
        <div class="row">
          <input id="trials" type="range" min="5" max="100" step="1" value="10" />
          <input id="trialsNum" type="number" min="5" max="1000" step="1" value="10" />
        </div>

        <label for="matchRate">Target Match Rate % <span id="matchRateV">50</span></label>
        <input id="matchRate" type="range" min="10" max="100" step="10" value="50" />

        <label for="crossTypeMatching">
          <input type="checkbox" id="crossTypeMatching" checked />
          Enable Cross-Type Structural Matching
        </label>

        <label for="testWalkthrough">
          <input type="checkbox" id="testWalkthrough" />
          Use 10-Trial Walkthrough Test
        </label>

        <div class="row" style="margin-top:16px">
          <button id="start" class="btn" data-start onclick="runSessionSafe()">START</button>
          <button id="stop" class="btn danger" disabled>STOP</button>
          <button id="reset" class="btn secondary">Reset Stats</button>
        </div>
        <div class="control-group" id="voiceControls">
          <h3>VOICE</h3>
          <div class="btn-group" style="grid-template-columns:1fr 1fr">
            <button id="previewBtn" class="btn btn-secondary" type="button">Voice Preview</button>
            <button id="repeatBtn" class="btn btn-secondary" type="button" disabled>Repeat Audio</button>
          </div>
          <label>
            Speech speed
            <span class="value" id="speechRateVal">1.00×</span>
          </label>
          <div class="seed-control">
            <input type="range" id="speechRate" min="0.5" max="2.5" step="0.1" value="1.0" class="knob-slider" />
            <input type="number" id="speechRateNum" min="0.5" max="2.5" step="0.1" value="1.0" class="seed-input" style="max-width:90px" />
          </div>
          <div class="voice-info" id="voiceInfo">Initializing voice…</div>
        </div>
        <div class="row">
          <button id="download" class="btn ghost">Export Session Log</button>
        </div>
      </section>

      <section class="card pad" aria-live="polite">
        <div class="status" id="status">Ready to begin. Press START to generate premises.</div>
        <div class="timer-bar"><div class="timer-progress" id="timerBar"></div></div>
        <div class="premise-container" id="premiseContainer">
          <div id="premiseDisplay">
            <div class="premise" id="premise">
              <span class="premise-number">1.</span>
              <span class="premise-text">Premises will appear here...</span>
            </div>
          </div>
        </div>
        <div class="bigbtns">
          <button id="btnMatch" class="yes" disabled>MATCH</button>
          <button id="btnNoMatch" class="no" disabled>NO MATCH</button>
        </div>
        <div class="stats">
          <div class="stat"><div>Trial</div><div class="kpi" id="kTrial">0</div></div>
          <div class="stat"><div>Score</div><div class="kpi" id="kScore">0</div></div>
          <div class="stat"><div>Accuracy</div><div class="kpi" id="kAcc">—</div></div>
          <div class="stat"><div>Hits</div><div class="kpi" id="kHits">0</div></div>
          <div class="stat"><div>Misses</div><div class="kpi" id="kMisses">0</div></div>
          <div class="stat"><div>Omissions</div><div class="kpi" id="kOmit">0</div></div>
        </div>
        <div id="structureInfo" class="mono" style="margin-top:10px;padding:10px;background:#0d1736;border-radius:8px;font-size:0.9rem;min-height:3em;"></div>
      </section>
    </div>

    <section class="card pad">
      <details open>
        <summary><strong>Cross-Type Structural Matching</strong></summary>
        <div class="pad">
          <p><strong>NEW!</strong> N-back matches now work across different logic types based on structural equivalence:</p>
          <ul>
            <li><strong>Spatial Inversions:</strong> "A north of B" ↔ "B south of A"</li>
            <li><strong>Logical Equivalences:</strong> "P→Q" ↔ "¬Q→¬P" (contrapositive)</li>
            <li><strong>Commutative Properties:</strong> "P∧Q" ↔ "Q∧P"</li>
            <li><strong>De Morgan's Laws:</strong> "¬(P∧Q)" ↔ "¬P∨¬Q"</li>
            <li><strong>Multi-relation Patterns:</strong> Complex structural matches across reasoning types</li>
          </ul>
          <p>This creates more challenging and varied n-back patterns by recognizing logical equivalence across the 62 reasoning types.</p>
        </div>
      </details>
      <details>
        <summary><strong>10-Trial Walkthrough Test</strong></summary>
        <div class="pad">
          <p>Enable the walkthrough test to verify cross-type matching with the illumination theme:</p>
          <ul>
            <li>J = Candle (steady light)</li>
            <li>D = Fireworks (intense light)</li>
            <li>X = Observation</li>
            <li>Y = Generalization</li>
            <li>Z = Anomaly</li>
          </ul>
          <p>Expected matches: Trials 3, 4, 6, 7, 9, 10</p>
        </div>
      </details>
      <details>
        <summary><strong>Session Log</strong></summary>
        <div class="pad">
          <div id="log" class="log" aria-live="polite"></div>
        </div>
      </details>
    </section>
  </div>

<script>
// Voice engine module - attached to window for global access
window.ImagiVoice = (function(){
  const hasTTS = ('speechSynthesis' in window && 'SpeechSynthesisUtterance' in window);
  let rate = 1.0, bound = false, lastLines = [];
  const engine = {};
  
  function speakOnce(text){
    if(!hasTTS) return;
    console.log('[Voice] Speaking once:', text);
    try { speechSynthesis.cancel(); }catch(e){}
    const u = new SpeechSynthesisUtterance(text);
    u.rate = rate;
    speechSynthesis.speak(u);
  }
  
  function speakLines(lines){
    if(!hasTTS || !Array.isArray(lines) || !lines.length) return;
    console.log('[Voice] Speaking lines:', lines);
    try { speechSynthesis.cancel(); }catch(e){}
    lastLines = lines.slice();
    engine._lastLines = lines.slice();
    const cleaned = lines.map(line => {
      // Strip number prefixes if present
      return line.replace(/^\d+\.\s*/, '').trim();
    });
    cleaned.forEach(t => {
      const u = new SpeechSynthesisUtterance(t);
      u.rate = rate;
      speechSynthesis.speak(u);
    });
  }
  
  function cancelAll(){
    if(!hasTTS) return;
    try { speechSynthesis.cancel(); }catch(e){}
  }
  
  function setRate(val){
    rate = parseFloat(val) || 1;
    const rateSlider = document.getElementById('speechRate');
    const rateNum = document.getElementById('speechRateNum');
    const rateVal = document.getElementById('speechRateVal');
    if(rateSlider && rateSlider.value != rate) rateSlider.value = rate;
    if(rateNum && rateNum.value != rate) rateNum.value = rate;
    if(rateVal) rateVal.textContent = rate.toFixed(2) + '×';
  }
  
  function updateInfo(){
    const infoEl = document.getElementById('voiceInfo');
    if(!infoEl) return;
    if(!hasTTS){
      infoEl.textContent = 'Text-to-speech not available in browser';
      infoEl.style.color = '#ef4444';
      return;
    }
    try{
      const voices = speechSynthesis.getVoices();
      if(voices && voices.length > 0){
        infoEl.textContent = `${voices.length} voice(s) available`;
        infoEl.style.color = '#10b981';
      } else {
        infoEl.textContent = 'Waiting for voices to load…';
        infoEl.style.color = '#fbbf24';
      }
    }catch(e){
      infoEl.textContent = 'Voice system error';
      infoEl.style.color = '#ef4444';
    }
  }
  
  function bindUI(){
    const rateSlider = document.getElementById('speechRate');
    const rateNum = document.getElementById('speechRateNum');
    const previewBtn = document.getElementById('previewBtn');
    const repeatBtn = document.getElementById('repeatBtn');
    const infoEl = document.getElementById('voiceInfo');
    
    setRate(rate);
    if(!hasTTS){
      if(previewBtn) previewBtn.disabled = true;
      if(repeatBtn) repeatBtn.disabled = true;
      updateInfo();
      return;
    }
    
    if(typeof speechSynthesis !== 'undefined'){
      speechSynthesis.onvoiceschanged = updateInfo;
      // Load voices immediately if available
      updateInfo();
    }
    
    if(!bound){
      if(rateSlider) rateSlider.addEventListener('input', e => setRate(e.target.value));
      if(rateNum) rateNum.addEventListener('input', e => setRate(e.target.value));
      if(previewBtn) previewBtn.addEventListener('click', () => speakOnce('Imagi World voice preview with cross-type matching. Rate ' + rate.toFixed(2)));
      if(repeatBtn) repeatBtn.addEventListener('click', () => {
        if(typeof engine.repeat === 'function'){
          engine.repeat();
        }
      });
      bound = true;
    }
  }
  
  // Extract premise text from DOM elements or array
  function extractPremiseText(linesOrSelector){
    if (Array.isArray(linesOrSelector)) {
      return linesOrSelector.map(line => 
        typeof line === 'string' ? line.replace(/^\d+\.\s*/, '').trim() : ''
      ).filter(s => s.length > 0);
    }
    
    // If it's a selector string, query the DOM
    if (typeof linesOrSelector === 'string') {
      const elements = document.querySelectorAll(linesOrSelector);
      return Array.from(elements).map(el => {
        const text = el.textContent || el.innerText || '';
        return text.replace(/^\d+\.\s*/, '').trim();
      }).filter(s => s.length > 0);
    }
    
    return [];
  }
  
  engine.init = bindUI;
  engine.cancel = cancelAll;
  engine.getRate = () => rate;
  engine.hasTTS = hasTTS;
  engine._setLastLines = function(lines){
    if(Array.isArray(lines)){
      lastLines = lines.slice();
      engine._lastLines = lines.slice();
    } else {
      lastLines = [];
      engine._lastLines = [];
    }
  };
  engine.speakPremises = function(linesOrSelector){
    const lines = extractPremiseText(linesOrSelector);
    console.log('[Voice] speakPremises called with:', linesOrSelector, 'extracted:', lines);
    if(lines.length) speakLines(lines);
  };
  engine.speakPremiseList = function(linesOrSelector){
    const lines = extractPremiseText(linesOrSelector);
    console.log('[Voice] speakPremiseList called with:', linesOrSelector, 'extracted:', lines);
    if(lines.length) speakLines(lines);
  };
  engine.repeat = function(){
    if(lastLines.length) speakLines(lastLines);
  };
  engine.speakOnce = speakOnce;
  
  if(document.readyState === 'loading') document.addEventListener('DOMContentLoaded', bindUI);
  else bindUI();
  
  return engine;
})();

// Main game logic with cross-type structural matching
(function(){
  // Core utilities
  const $ = sel => document.querySelector(sel);
  const rand = (a, b) => Math.floor(Math.random() * (b - a + 1)) + a;
  const choice = arr => arr[rand(0, arr.length - 1)];
  const shuffle = arr => {
    const copy = [...arr];
    for(let i = copy.length - 1; i > 0; i--) {
      const j = rand(0, i);
      [copy[i], copy[j]] = [copy[j], copy[i]];
    }
    return copy;
  };
  const sample = (arr, k) => shuffle([...arr]).slice(0, k);

  // Premise generation helpers
  const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
  const usedPremises = new Set();
  let letterIndex = 0;

  // 10-Trial Walkthrough mapping
  const walkthroughLetterMap = {
    'J': 'Candle',
    'D': 'Fireworks', 
    'X': 'Observation',
    'Y': 'Generalization',
    'Z': 'Anomaly'
  };

  function getNextLetters(count, useWalkthrough = false) {
    if (useWalkthrough) {
      // Use specific letters for walkthrough test
      const walkthroughLetters = Object.keys(walkthroughLetterMap);
      return sample(walkthroughLetters, count);
    }
    
    const result = [];
    for(let i = 0; i < count; i++) {
      result.push(letters[letterIndex % 26]);
      letterIndex++;
    }
    return result;
  }

  // Logical connectives variations
  const IF_VARIANTS = ['If', 'When', 'Whenever', 'Given that', 'Assuming'];
  const THEN_VARIANTS = ['then', 'it follows that', 'consequently', 'therefore', 'thus'];
  const OR_VARIANTS = ['or', 'alternatively', 'otherwise', 'else'];
  const AND_VARIANTS = ['and', 'moreover', 'furthermore', 'also', 'additionally'];
  const NOT_VARIANTS = ['not', 'never', 'fails to be', 'is false'];
  const IMPLIES_VARIANTS = ['implies', 'leads to', 'results in', 'causes', 'entails'];

  // Relation types
  const ABOVE_RELATIONS = ['is above', 'is higher than', 'supersedes', 'dominates'];
  const BELOW_RELATIONS = ['is below', 'is lower than', 'is subordinate to', 'follows'];
  const BESIDE_RELATIONS = ['is beside', 'is adjacent to', 'is parallel to', 'aligns with'];

  // Complete set of all 62 reasoning type generators
  const reasoningGenerators = {
    // Type 1: Circularity via drift
    1: () => {
      const variants = [
        () => {
          const [A, B, C] = getNextLetters(3, state && state.useWalkthrough);
          return `${B} is north of ${A}; some ${C} is north of ${B}; some ${C} is east of ${A}`;
        },
        () => {
          const [A, B, C] = getNextLetters(3, state && state.useWalkthrough);
          return `${B} is north of ${A}; some ${C} is north of ${B}; ${A} is east of some ${C}`;
        },
        () => {
          const [A, B, C] = getNextLetters(3, state && state.useWalkthrough);
          const implies = choice(IMPLIES_VARIANTS);
          return `${A} ${implies} ${B}; ${B} ${implies} some ${C}; some ${C} ${implies} ${A}`;
        }
      ];
      const premise = choice(variants)();
      return {
        premise,
        logicType: 'circularity_drift',
        structure: 'A→B→∃C→A',
        typeId: 1
      };
    },

    // Type 2: Modus ponens with decoy
    2: () => {
      const variants = [
        () => {
          const [D, E, F] = getNextLetters(3);
          return `If ${D} then ${E}; either ${F} or ${D}; ${F} is false`;
        },
        () => {
          const [D, E, F] = getNextLetters(3);
          return `${D} holds unless ${F}; if ${D} then ${E}; ${F} is absent`;
        }
      ];
      const premise = choice(variants)();
      return {
        premise,
        logicType: 'modus_ponens_decoy',
        structure: '(P→Q)∧(R∨P)∧¬R⇒Q',
        typeId: 2
      };
    },

    // Type 3: Modus tollens with extra premise
    3: () => {
      const variants = [
        () => {
          const [G, H, I] = getNextLetters(3);
          return `If ${G} then ${H}; not ${H}; ${I} unrelated to ${G}`;
        },
        () => {
          const [G, H, I] = getNextLetters(3);
          const ifWord = choice(IF_VARIANTS);
          const thenWord = choice(THEN_VARIANTS);
          const notWord = choice(NOT_VARIANTS);
          return `${ifWord} ${G} ${thenWord} ${H}; ${H} is ${notWord} true; ${I} is independent`;
        }
      ];
      const premise = choice(variants)();
      return {
        premise,
        logicType: 'modus_tollens_extra',
        structure: '(P→Q)∧¬Q∧(R⊥P)⇒¬P',
        typeId: 3
      };
    },

    // Type 4: Hypothetical syllogism
    4: () => {
      const [J, K, L] = getNextLetters(3);
      const ifWord = choice(IF_VARIANTS);
      const thenWord = choice(THEN_VARIANTS);
      return {
        premise: `${ifWord} ${J} ${thenWord} ${K}; ${ifWord} ${K} ${thenWord} ${L}`,
        logicType: 'hypothetical_syllogism',
        structure: '(P→Q)∧(Q→R)⇒(P→R)',
        typeId: 4
      };
    },

    // Type 5: Disjunctive introduction
    5: () => {
      const [M, N] = getNextLetters(2);
      const orWord = choice(OR_VARIANTS);
      return {
        premise: `${M} is true; therefore ${M} ${orWord} ${N}`,
        logicType: 'disjunctive_introduction',
        structure: 'P⇒(P∨Q)',
        typeId: 5
      };
    },

    // Type 6: Conjunction elimination
    6: () => {
      const [O, P] = getNextLetters(2);
      const andWord = choice(AND_VARIANTS);
      return {
        premise: `${O} ${andWord} ${P} are both true; therefore ${O}`,
        logicType: 'conjunction_elimination',
        structure: '(P∧Q)⇒P',
        typeId: 6
      };
    },

    // Type 7: Universal instantiation
    7: () => {
      const [Q, R] = getNextLetters(2);
      return {
        premise: `All ${Q} are ${R}; this is a ${Q}; therefore it is ${R}`,
        logicType: 'universal_instantiation',
        structure: '∀x(P(x)→Q(x))∧P(a)⇒Q(a)',
        typeId: 7
      };
    },

    // Type 8: Existential generalization
    8: () => {
      const [S, T] = getNextLetters(2);
      return {
        premise: `This ${S} is ${T}; therefore some ${S} is ${T}`,
        logicType: 'existential_generalization',
        structure: 'P(a)⇒∃x(P(x))',
        typeId: 8
      };
    },

    // Type 9: De Morgan's Law (NOT AND)
    9: () => {
      const [U, V] = getNextLetters(2);
      const andWord = choice(AND_VARIANTS);
      const orWord = choice(OR_VARIANTS);
      const notWord = choice(NOT_VARIANTS);
      return {
        premise: `${notWord} (${U} ${andWord} ${V}) equals (${notWord} ${U}) ${orWord} (${notWord} ${V})`,
        logicType: 'de_morgan_and',
        structure: '¬(P∧Q)≡(¬P∨¬Q)',
        typeId: 9
      };
    },

    // Type 10: De Morgan's Law (NOT OR)
    10: () => {
      const [W, X] = getNextLetters(2);
      const andWord = choice(AND_VARIANTS);
      const orWord = choice(OR_VARIANTS);
      const notWord = choice(NOT_VARIANTS);
      return {
        premise: `${notWord} (${W} ${orWord} ${X}) equals (${notWord} ${W}) ${andWord} (${notWord} ${X})`,
        logicType: 'de_morgan_or',
        structure: '¬(P∨Q)≡(¬P∧¬Q)',
        typeId: 10
      };
    },

    // Type 11: Contrapositive
    11: () => {
      const [Y, Z] = getNextLetters(2);
      const implies = choice(IMPLIES_VARIANTS);
      return {
        premise: `${Y} ${implies} ${Z} means ¬${Z} ${implies} ¬${Y}`,
        logicType: 'contrapositive',
        structure: '(P→Q)≡(¬Q→¬P)',
        typeId: 11
      };
    },

    // Type 12: Double negation
    12: () => {
      const [A] = getNextLetters(1);
      const notWord = choice(NOT_VARIANTS);
      return {
        premise: `${notWord} ${notWord} ${A} equals ${A}`,
        logicType: 'double_negation',
        structure: '¬¬P≡P',
        typeId: 12
      };
    },

    // Type 13: Biconditional elimination (forward)
    13: () => {
      const [B, C] = getNextLetters(2);
      return {
        premise: `${B} if and only if ${C}; ${B} is true; therefore ${C}`,
        logicType: 'biconditional_elimination_forward',
        structure: '(P↔Q)∧P⇒Q',
        typeId: 13
      };
    },

    // Type 14: Biconditional elimination (backward)
    14: () => {
      const [D, E] = getNextLetters(2);
      return {
        premise: `${D} if and only if ${E}; ${E} is true; therefore ${D}`,
        logicType: 'biconditional_elimination_backward',
        structure: '(P↔Q)∧Q⇒P',
        typeId: 14
      };
    },

    // Type 15: Exclusive OR
    15: () => {
      const [F, G] = getNextLetters(2);
      return {
        premise: `Either ${F} or ${G} but not both`,
        logicType: 'exclusive_or',
        structure: 'P⊕Q≡(P∨Q)∧¬(P∧Q)',
        typeId: 15
      };
    },

    // Type 16: Material conditional
    16: () => {
      const [H, I] = getNextLetters(2);
      const implies = choice(IMPLIES_VARIANTS);
      const orWord = choice(OR_VARIANTS);
      return {
        premise: `${H} ${implies} ${I} equals not ${H} ${orWord} ${I}`,
        logicType: 'material_conditional',
        structure: '(P→Q)≡(¬P∨Q)',
        typeId: 16
      };
    },

    // Type 17: Quantifier negation (universal to existential)
    17: () => {
      const [J, K] = getNextLetters(2);
      return {
        premise: `Not all ${J} are ${K} means some ${J} are not ${K}`,
        logicType: 'quantifier_negation_universal',
        structure: '¬∀x(P(x))≡∃x(¬P(x))',
        typeId: 17
      };
    },

    // Type 18: Quantifier negation (existential to universal)
    18: () => {
      const [L, M] = getNextLetters(2);
      return {
        premise: `There is no ${L} that is ${M} means all ${L} are not ${M}`,
        logicType: 'quantifier_negation_existential',
        structure: '¬∃x(P(x))≡∀x(¬P(x))',
        typeId: 18
      };
    },

    // Type 19: Disjunctive syllogism
    19: () => {
      const [N, O] = getNextLetters(2);
      const orWord = choice(OR_VARIANTS);
      return {
        premise: `${N} ${orWord} ${O}; not ${N}; therefore ${O}`,
        logicType: 'disjunctive_syllogism',
        structure: '(P∨Q)∧¬P⇒Q',
        typeId: 19
      };
    },

    // Type 20: Constructive dilemma
    20: () => {
      const [P, Q, R, S] = getNextLetters(4);
      return {
        premise: `If ${P} then ${Q}; if ${R} then ${S}; either ${P} or ${R}; therefore ${Q} or ${S}`,
        logicType: 'constructive_dilemma',
        structure: '((P→Q)∧(R→S)∧(P∨R))⇒(Q∨S)',
        typeId: 20
      };
    },

    // Type 21: Destructive dilemma
    21: () => {
      const [T, U, V, W] = getNextLetters(4);
      return {
        premise: `If ${T} then ${U}; if ${V} then ${W}; not ${U} or not ${W}; therefore not ${T} or not ${V}`,
        logicType: 'destructive_dilemma',
        structure: '((P→Q)∧(R→S)∧(¬Q∨¬S))⇒(¬P∨¬R)',
        typeId: 21
      };
    },

    // Type 22: Absorption
    22: () => {
      const [X, Y] = getNextLetters(2);
      return {
        premise: `If ${X} then ${Y} implies if ${X} then (${X} and ${Y})`,
        logicType: 'absorption',
        structure: '(P→Q)⇒(P→(P∧Q))',
        typeId: 22
      };
    },

    // Type 23: Commutativity (AND)
    23: () => {
      const [Z, A] = getNextLetters(2);
      const andWord = choice(AND_VARIANTS);
      return {
        premise: `${Z} ${andWord} ${A} equals ${A} ${andWord} ${Z}`,
        logicType: 'commutative_and',
        structure: '(P∧Q)≡(Q∧P)',
        typeId: 23
      };
    },

    // Type 24: Commutativity (OR)
    24: () => {
      const [B, C] = getNextLetters(2);
      const orWord = choice(OR_VARIANTS);
      return {
        premise: `${B} ${orWord} ${C} equals ${C} ${orWord} ${B}`,
        logicType: 'commutative_or',
        structure: '(P∨Q)≡(Q∨P)',
        typeId: 24
      };
    },

    // Type 25: Law of excluded middle
    25: () => {
      const [D] = getNextLetters(1);
      return {
        premise: `${D} or not ${D} is always true`,
        logicType: 'excluded_middle',
        structure: 'P∨¬P≡⊤',
        typeId: 25
      };
    },

    // Type 26: Law of non-contradiction
    26: () => {
      const [E] = getNextLetters(1);
      return {
        premise: `${E} and not ${E} is always false`,
        logicType: 'non_contradiction',
        structure: '¬(P∧¬P)≡⊤',
        typeId: 26
      };
    },

    // Type 27: Reductio ad absurdum
    27: () => {
      const [F, G] = getNextLetters(2);
      return {
        premise: `Assume ${F}; this leads to contradiction; therefore not ${F}`,
        logicType: 'reductio_ad_absurdum',
        structure: '(P→⊥)⇒¬P',
        typeId: 27
      };
    },

    // Type 28: Proof by cases
    28: () => {
      const [H, I, J] = getNextLetters(3);
      return {
        premise: `Either ${H} or ${I}; if ${H} then ${J}; if ${I} then ${J}; therefore ${J}`,
        logicType: 'proof_by_cases',
        structure: '((P∨Q)∧(P→R)∧(Q→R))⇒R',
        typeId: 28
      };
    },

    // Type 29: Transitivity of equality
    29: () => {
      const [K, L, M] = getNextLetters(3);
      return {
        premise: `${K} equals ${L}; ${L} equals ${M}; therefore ${K} equals ${M}`,
        logicType: 'transitivity_equality',
        structure: '(P=Q)∧(Q=R)⇒(P=R)',
        typeId: 29
      };
    },

    // Type 30: Substitution of equals
    30: () => {
      const [N, O, P] = getNextLetters(3);
      return {
        premise: `${N} equals ${O}; ${P}(${N}) is true; therefore ${P}(${O}) is true`,
        logicType: 'substitution_equals',
        structure: '(P=Q)∧F(P)⇒F(Q)',
        typeId: 30
      };
    },

    // Type 31: Transitivity of implication
    31: () => {
      const [Q, R, S] = getNextLetters(3);
      const implies = choice(IMPLIES_VARIANTS);
      return {
        premise: `${Q} ${implies} ${R} and ${R} ${implies} ${S}, so ${Q} ${implies} ${S}`,
        logicType: 'transitivity_implication',
        structure: '(P→Q)∧(Q→R)⇒(P→R)',
        typeId: 31
      };
    },

    // Type 32: Set membership and subset
    32: () => {
      const [T, U, V] = getNextLetters(3);
      return {
        premise: `${T} is in set ${U}; ${U} is a subset of ${V}; therefore ${T} is in ${V}`,
        logicType: 'set_membership_subset',
        structure: '(x∈A)∧(A⊆B)⇒(x∈B)',
        typeId: 32
      };
    },

    // Type 33: Pigeonhole principle
    33: () => {
      const [W, X] = getNextLetters(2);
      return {
        premise: `More ${W} than ${X} means some ${X} has multiple ${W}`,
        logicType: 'pigeonhole_principle',
        structure: '|A|>|B|∧f:A→B⇒∃b∈B:|f⁻¹(b)|≥2',
        typeId: 33
      };
    },

    // Type 34: Induction base case
    34: () => {
      const [Y] = getNextLetters(1);
      return {
        premise: `Property ${Y} holds for base case n=0`,
        logicType: 'induction_base',
        structure: 'P(0)',
        typeId: 34
      };
    },

    // Type 35: Induction step
    35: () => {
      const [A] = getNextLetters(1);
      return {
        premise: `If ${A}(k) then ${A}(k+1) for all k`,
        logicType: 'induction_step',
        structure: '∀k(P(k)→P(k+1))',
        typeId: 35
      };
    },

    // Type 36: Complete induction
    36: () => {
      const [C] = getNextLetters(1);
      return {
        premise: `Base ${C}(0) and step ${C}(k)→${C}(k+1) proves ∀n ${C}(n)`,
        logicType: 'induction_complete',
        structure: 'P(0)∧∀k(P(k)→P(k+1))⇒∀n(P(n))',
        typeId: 36
      };
    },

    // Type 37: Associative (AND)
    37: () => {
      const [E, F, G] = getNextLetters(3);
      const andWord = choice(AND_VARIANTS);
      return {
        premise: `(${E} ${andWord} ${F}) ${andWord} ${G} equals ${E} ${andWord} (${F} ${andWord} ${G})`,
        logicType: 'associative_and',
        structure: '((A∧B)∧C)≡(A∧(B∧C))',
        typeId: 37
      };
    },

    // Type 38: Associative (OR)
    38: () => {
      const [H, I, J] = getNextLetters(3);
      const orWord = choice(OR_VARIANTS);
      return {
        premise: `(${H} ${orWord} ${I}) ${orWord} ${J} equals ${H} ${orWord} (${I} ${orWord} ${J})`,
        logicType: 'associative_or',
        structure: '((A∨B)∨C)≡(A∨(B∨C))',
        typeId: 38
      };
    },

    // Type 39: Distributive (AND over OR)
    39: () => {
      const [K, L, M] = getNextLetters(3);
      const andWord = choice(AND_VARIANTS);
      const orWord = choice(OR_VARIANTS);
      return {
        premise: `${K} ${andWord} (${L} ${orWord} ${M}) equals (${K} ${andWord} ${L}) ${orWord} (${K} ${andWord} ${M})`,
        logicType: 'distributive_and_or',
        structure: 'A∧(B∨C)≡(A∧B)∨(A∧C)',
        typeId: 39
      };
    },

    // Type 40: Distributive (OR over AND)
    40: () => {
      const [N, O, P] = getNextLetters(3);
      const andWord = choice(AND_VARIANTS);
      const orWord = choice(OR_VARIANTS);
      return {
        premise: `${N} ${orWord} (${O} ${andWord} ${P}) equals (${N} ${orWord} ${O}) ${andWord} (${N} ${orWord} ${P})`,
        logicType: 'distributive_or_and',
        structure: 'A∨(B∧C)≡(A∨B)∧(A∨C)',
        typeId: 40
      };
    },

    // Type 41: Identity (AND with true)
    41: () => {
      const [Q] = getNextLetters(1);
      return {
        premise: `${Q} and true equals ${Q}`,
        logicType: 'identity_and_true',
        structure: 'P∧⊤≡P',
        typeId: 41
      };
    },

    // Type 42: Identity (OR with false)
    42: () => {
      const [R] = getNextLetters(1);
      return {
        premise: `${R} or false equals ${R}`,
        logicType: 'identity_or_false',
        structure: 'P∨⊥≡P',
        typeId: 42
      };
    },

    // Type 43: Domination (AND with false)
    43: () => {
      const [S] = getNextLetters(1);
      return {
        premise: `${S} and false equals false`,
        logicType: 'domination_and_false',
        structure: 'P∧⊥≡⊥',
        typeId: 43
      };
    },

    // Type 44: Domination (OR with true)
    44: () => {
      const [T] = getNextLetters(1);
      return {
        premise: `${T} or true equals true`,
        logicType: 'domination_or_true',
        structure: 'P∨⊤≡⊤',
        typeId: 44
      };
    },

    // Type 45: Idempotent (AND)
    45: () => {
      const [U] = getNextLetters(1);
      return {
        premise: `${U} and ${U} equals ${U}`,
        logicType: 'idempotent_and',
        structure: 'P∧P≡P',
        typeId: 45
      };
    },

    // Type 46: Idempotent (OR)
    46: () => {
      const [V] = getNextLetters(1);
      return {
        premise: `${V} or ${V} equals ${V}`,
        logicType: 'idempotent_or',
        structure: 'P∨P≡P',
        typeId: 46
      };
    },

    // Type 47: Complement (AND)
    47: () => {
      const [W] = getNextLetters(1);
      return {
        premise: `${W} and not ${W} equals false`,
        logicType: 'complement_and',
        structure: 'P∧¬P≡⊥',
        typeId: 47
      };
    },

    // Type 48: Complement (OR)  
    48: () => {
      const [X] = getNextLetters(1);
      return {
        premise: `${X} or not ${X} equals true`,
        logicType: 'complement_or',
        structure: 'P∨¬P≡⊤',
        typeId: 48
      };
    },

    // Type 49: Spatial hierarchy (north)
    49: () => {
      const [A, B] = getNextLetters(2, state && state.useWalkthrough);
      const variants = [
        `${A} is north of ${B}`,
        `${A} lies above ${B} in hierarchy`,
        `${A} supersedes ${B}`,
        `${A} dominates ${B} spatially`
      ];
      return {
        premise: choice(variants),
        logicType: 'spatial_hierarchy_north',
        structure: 'north(A,B)',
        typeId: 49
      };
    },

    // Type 50: Spatial hierarchy (south) - inverse of north
    50: () => {
      const [A, B] = getNextLetters(2, state && state.useWalkthrough);
      const variants = [
        `${A} is south of ${B}`,
        `${A} lies below ${B} in hierarchy`,
        `${A} is subordinate to ${B}`,
        `${A} is under ${B} spatially`
      ];
      return {
        premise: choice(variants),
        logicType: 'spatial_hierarchy_south',
        structure: 'south(A,B)',
        typeId: 50
      };
    },

    // Type 51: Spatial relation (east)
    51: () => {
      const [A, B] = getNextLetters(2, state && state.useWalkthrough);
      const variants = [
        `${A} is east of ${B}`,
        `${A} lies to the right of ${B}`,
        `${A} is adjacent eastward to ${B}`,
        `${A} parallels ${B} eastward`
      ];
      return {
        premise: choice(variants),
        logicType: 'spatial_relation_east',
        structure: 'east(A,B)',
        typeId: 51
      };
    },

    // Type 52: Spatial relation (west) - inverse of east  
    52: () => {
      const [A, B] = getNextLetters(2, state && state.useWalkthrough);
      const variants = [
        `${A} is west of ${B}`,
        `${A} lies to the left of ${B}`,
        `${A} is adjacent westward to ${B}`,
        `${A} parallels ${B} westward`
      ];
      return {
        premise: choice(variants),
        logicType: 'spatial_relation_west',
        structure: 'west(A,B)',
        typeId: 52
      };
    },

    // Type 53: Multi-relation spatial compound
    53: () => {
      const [A, B, C] = getNextLetters(3, state && state.useWalkthrough);
      const variants = [
        `${A} is west of ${B}; ${A} is south of ${C}`,
        `${A} is north of ${B}; ${A} is east of ${C}`,
        `${A} above ${B} and ${A} beside ${C}`,
        `${A} dominates ${B}; ${A} parallels ${C}`
      ];
      return {
        premise: choice(variants),
        logicType: 'multi_relation_spatial',
        structure: 'west(A,B)∧south(A,C)',
        typeId: 53
      };
    },

    // Type 54: Comparative analogy (cross-type match for multi-relation)
    54: () => {
      const [A, B, C] = getNextLetters(3, state && state.useWalkthrough);
      const variants = [
        `${A} is east of ${B}; ${C} is north of ${B}`,
        `${A} beside ${B}; ${C} above ${B}`,
        `${A} parallels ${B} eastward; ${C} supersedes ${B}`
      ];
      return {
        premise: choice(variants),
        logicType: 'comparative_analogy',
        structure: 'east(A,B)∧north(C,B)',
        typeId: 54
      };
    },

    // Type 55: Inverse relation
    55: () => {
      const [A, B] = getNextLetters(2);
      return {
        premise: `${A} is north of ${B} means ${B} is south of ${A}`,
        logicType: 'inverse_relation',
        structure: 'R(A,B)≡R⁻¹(B,A)',
        typeId: 55
      };
    },

    // Type 56: Circular reasoning with quantifier
    56: () => {
      const [A, B, C] = getNextLetters(3);
      return {
        premise: `All ${A} are ${B}; some ${B} are ${C}; those ${C} are ${A}`,
        logicType: 'circular_quantifier',
        structure: '∀x(A(x)→B(x))∧∃x(B(x)∧C(x))∧(C→A)',
        typeId: 56
      };
    },

    // Type 57: Bijection
    57: () => {
      const [A, B] = getNextLetters(2);
      return {
        premise: `Function f: ${A} → ${B} is bijective`,
        logicType: 'bijection',
        structure: 'bijective(f:A→B)',
        typeId: 57
      };
    },

    // Type 58: Injection
    58: () => {
      const [A, B] = getNextLetters(2);
      return {
        premise: `Function f: ${A} → ${B} is injective`,
        logicType: 'injection',
        structure: 'injective(f:A→B)',
        typeId: 58
      };
    },

    // Type 59: Surjection
    59: () => {
      const [A, B] = getNextLetters(2);
      return {
        premise: `Function f: ${A} → ${B} is surjective`,
        logicType: 'surjection',
        structure: 'surjective(f:A→B)',
        typeId: 59
      };
    },

    // Type 60: Partial function
    60: () => {
      const [A, B] = getNextLetters(2);
      return {
        premise: `Function f: ${A} ⇀ ${B} is partial`,
        logicType: 'partial_function',
        structure: 'partial(f:A⇀B)',
        typeId: 60
      };
    },

    // Type 61: Total function
    61: () => {
      const [A, B] = getNextLetters(2);
      return {
        premise: `Function f: ${A} → ${B} is total`,
        logicType: 'total_function',
        structure: 'total(f:A→B)',
        typeId: 61
      };
    },

    // Type 62: Composition of functions
    62: () => {
      const [A, B, C] = getNextLetters(3);
      return {
        premise: `(g ∘ f): ${A} → ${C} where f: ${A} → ${B} and g: ${B} → ${C}`,
        logicType: 'function_composition',
        structure: '(g∘f)(x)=g(f(x))',
        typeId: 62
      };
    }
  }

  // Structure equivalence detection system
  const structureEquivalence = {
    // Define equivalence classes for structural matching
    equivalenceClasses: {
      // Spatial inversions
      'north(A,B)': ['south(B,A)'],
      'south(A,B)': ['north(B,A)'],
      'east(A,B)': ['west(B,A)'],
      'west(A,B)': ['east(B,A)'],
      
      // Multi-relation patterns (can match if atoms are inverse pairs)
      'west(A,B)∧south(A,C)': ['east(B,A)∧north(C,A)'],
      'east(A,B)∧north(C,B)': ['west(B,A)∧south(B,C)'],
      
      // Logical equivalences
      '(P→Q)': ['(¬Q→¬P)'],
      '(P∧Q)': ['(Q∧P)'],
      '(P∨Q)': ['(Q∨P)'],
      '¬(P∧Q)': ['(¬P∨¬Q)'],
      '¬(P∨Q)': ['(¬P∧¬Q)']
    },

    // Check if two structures are equivalent
    areEquivalent(structure1, structure2) {
      if (!structure1 || !structure2) return false;
      
      // Direct match
      if (structure1 === structure2) return true;
      
      // Normalize for comparison
      const norm1 = this.normalizeStructure(structure1);
      const norm2 = this.normalizeStructure(structure2);
      
      if (norm1 === norm2) return true;
      
      // Check spatial inversions
      if (this.areSpatialInverses(structure1, structure2)) return true;
      
      // Check multi-relation inversions
      if (this.areMultiRelationInverses(structure1, structure2)) return true;
      
      // Check logical equivalences
      if (this.areLogicallyEquivalent(norm1, norm2)) return true;
      
      // Check equivalence classes
      for (const [key, equivalents] of Object.entries(this.equivalenceClasses)) {
        const keyNorm = this.normalizeStructure(key);
        const equivNorms = equivalents.map(e => this.normalizeStructure(e));
        
        if ((norm1 === keyNorm && equivNorms.includes(norm2)) ||
            (norm2 === keyNorm && equivNorms.includes(norm1))) {
          return true;
        }
      }
      
      return false;
    },

    // Normalize structure for comparison
    normalizeStructure(structure) {
      if (!structure) return '';
      // Keep the structure but normalize spacing and case
      return structure.replace(/\s+/g, '').toLowerCase();
    },

    // Check if two spatial relations are inverses
    areSpatialInverses(s1, s2) {
      // Check single spatial relations
      const spatialPairs = [
        ['north(', 'south('],
        ['east(', 'west('],
        ['above(', 'below('],
        ['right(', 'left(']
      ];
      
      for (const [dir1, dir2] of spatialPairs) {
        // Check if s1 has dir1(A,B) and s2 has dir2(B,A)
        const pattern1 = new RegExp(dir1.replace('(', '\\(') + '([^,]+),([^)]+)\\)');
        const pattern2 = new RegExp(dir2.replace('(', '\\(') + '([^,]+),([^)]+)\\)');
        
        const match1 = s1.match(pattern1);
        const match2 = s2.match(pattern2);
        
        if (match1 && match2) {
          // Check if arguments are swapped
          if (match1[1] === match2[2] && match1[2] === match2[1]) {
            return true;
          }
        }
        
        // Check reverse
        const match1r = s2.match(pattern1);
        const match2r = s1.match(pattern2);
        
        if (match1r && match2r) {
          if (match1r[1] === match2r[2] && match1r[2] === match2r[1]) {
            return true;
          }
        }
      }
      
      return false;
    },

    // Check if multi-relation compounds are inverses
    areMultiRelationInverses(s1, s2) {
      // Check for compound relations like "west(A,B)∧south(A,C)" vs "east(B,A)∧north(C,A)"
      if (s1.includes('∧') && s2.includes('∧')) {
        const parts1 = s1.split('∧').map(p => p.trim());
        const parts2 = s2.split('∧').map(p => p.trim());
        
        if (parts1.length === 2 && parts2.length === 2) {
          // Check if both parts are spatial inverses
          return this.areSpatialInverses(parts1[0], parts2[0]) && 
                 this.areSpatialInverses(parts1[1], parts2[1]);
        }
      }
      
      return false;
    },

    // Check logical equivalences
    areLogicallyEquivalent(s1, s2) {
      const patterns = [
        // Contrapositive
        ['(p→q)', '(¬q→¬p)'],
        // Commutative
        ['(p∧q)', '(q∧p)'],
        ['(p∨q)', '(q∨p)'],
        // De Morgan
        ['¬(p∧q)', '(¬p∨¬q)'],
        ['¬(p∨q)', '(¬p∧¬q)'],
        // Double negation
        ['¬¬p', 'p']
      ];
      
      for (const [pat1, pat2] of patterns) {
        if ((s1.includes(pat1) && s2.includes(pat2)) ||
            (s1.includes(pat2) && s2.includes(pat1))) {
          return true;
        }
      }
      
      return false;
    },

    // Find all types with equivalent structures
    findEquivalentTypes(targetStructure) {
      const equivalentTypes = [];
      
      for (const [typeId, generator] of Object.entries(reasoningGenerators)) {
        try {
          const sample = generator();
          if (this.areEquivalent(sample.structure, targetStructure)) {
            equivalentTypes.push(parseInt(typeId));
          }
        } catch(e) {
          console.warn(`Error checking type ${typeId}:`, e);
        }
      }
      
      return equivalentTypes;
    }
  };

  // PCG32 random number generator for reproducible randomness
  function pcg32(seed) {
    let state = BigInt(seed || 12345);
    const multiplier = 6364136223846793005n;
    const increment = 1442695040888963407n;
    const modulus = 2n ** 64n;

    return function() {
      const xorshifted = Number(((state >> 18n) ^ state) >> 27n);
      const rot = Number(state >> 59n);
      state = (state * multiplier + increment) % modulus;
      const result = (xorshifted >>> rot) | (xorshifted << (32 - rot));
      return (result >>> 0) / 4294967296;
    };
  }

  // Game state
  const state = {
    running: false,
    n: 2,
    secondsPerTrial: 10,
    premisesPerTrial: 1,
    trials: 10,
    matchRate: 50,
    currentTrial: 0,
    history: [],
    schedule: [],
    timer: null,
    timerBar: null,
    responses: 0,
    hits: 0,
    misses: 0,
    omissions: 0,
    score: 0,
    log: [],
    crossTypeEnabled: true,
    useWalkthrough: false,
    
    // Advanced tracking
    familyFreq: {},
    recentWindow: [],
    pairCount: Array(63).fill(null).map(() => ({})),
    theta: 0,
    lastFamily: 0,
    atNback: 0,
    stream: []
  };

  // 10-Trial Walkthrough Test Configuration
  const walkthroughTrials = [
    { typeId: 49, structure: 'north(A,B)', shouldMatch: false }, // Trial 1: D north of J
    { typeId: 53, structure: 'west(A,B)∧south(A,C)', shouldMatch: false }, // Trial 2: Z west of X; Z south of Y
    { typeId: 50, structure: 'south(A,B)', shouldMatch: true }, // Trial 3: J south of D (matches Trial 1 inverse)
    { typeId: 54, structure: 'east(A,B)∧north(C,B)', shouldMatch: true }, // Trial 4: X east of Z; Y north of Z (matches Trial 2 inverse)
    { typeId: 51, structure: 'east(A,B)', shouldMatch: false }, // Trial 5: D east of J
    { typeId: 53, structure: 'west(A,B)∧south(A,C)', shouldMatch: true }, // Trial 6: Same as Trial 2 structure
    { typeId: 52, structure: 'west(A,B)', shouldMatch: true }, // Trial 7: J west of D (matches Trial 5 inverse)
    { typeId: 51, structure: 'east(A,B)', shouldMatch: false }, // Trial 8: X east of Z (single relation)
    { typeId: 51, structure: 'east(A,B)', shouldMatch: true }, // Trial 9: D east of J (matches Trial 7's inverse)
    { typeId: 52, structure: 'west(A,B)', shouldMatch: true } // Trial 10: Z west of X (matches Trial 8 inverse)
  ];

  // Generate unique premise
  function generateUniquePremise(typeId, allowCrossType = true) {
    const maxAttempts = 50;
    let seed = Date.now() + state.currentTrial * 1000;
    
    for(let attempt = 0; attempt < maxAttempts; attempt++) {
      const r = pcg32(seed + attempt);
      
      let selectedType = typeId;
      
      // Allow cross-type selection if enabled
      if (allowCrossType && state.crossTypeEnabled && r() < 0.4) {
        const targetStructure = reasoningGenerators[typeId]().structure;
        const equivalentTypes = structureEquivalence.findEquivalentTypes(targetStructure);
        if (equivalentTypes.length > 1) {
          // Select a different but equivalent type
          const otherTypes = equivalentTypes.filter(t => t !== typeId);
          if (otherTypes.length > 0) {
            selectedType = choice(otherTypes);
          }
        }
      }
      
      const result = reasoningGenerators[selectedType]();
      
      if (!usedPremises.has(result.premise)) {
        usedPremises.add(result.premise);
        result.originalTypeId = typeId;
        result.actualTypeId = selectedType;
        result.isCrossType = selectedType !== typeId;
        return result;
      }
    }
    
    // Fallback
    const id = typeId || rand(1, 62);
    const result = reasoningGenerators[id]();
    result.typeId = id;
    result.premise += ` [${Date.now()}]`;
    usedPremises.add(result.premise);
    return result;
  }

  // Generate trial premises with structural matching
  function generateTrialPremises(count, matchData = null) {
    const premises = [];

    if (state.useWalkthrough && state.currentTrial < walkthroughTrials.length) {
      // Use predefined walkthrough trial
      const trialConfig = walkthroughTrials[state.currentTrial];
      const premise = generateUniquePremise(trialConfig.typeId, false);
      premise.structure = trialConfig.structure;
      premise.shouldMatch = trialConfig.shouldMatch;
      premises.push(premise);
      return premises;
    }

    if (matchData && matchData.length > 0) {
      // Generate structurally matching premises
      for(let i = 0; i < count; i++) {
        const targetData = matchData[i % matchData.length];
        const targetStructure = targetData.structure;
        
        if (state.crossTypeEnabled) {
          // Find all types with equivalent structures
          const equivalentTypes = structureEquivalence.findEquivalentTypes(targetStructure);
          
          if (equivalentTypes.length > 0) {
            // Prefer cross-type matches for variety
            const otherTypes = equivalentTypes.filter(t => t !== targetData.typeId);
            const selectedTypeId = otherTypes.length > 0 ? choice(otherTypes) : choice(equivalentTypes);
            
            const premise = generateUniquePremise(selectedTypeId, false);
            premise.isStructuralMatch = true;
            premise.matchedStructure = targetStructure;
            premise.crossTypeMatch = selectedTypeId !== targetData.typeId;
            premises.push(premise);
          } else {
            // Fallback to same type
            premises.push(generateUniquePremise(targetData.typeId, false));
          }
        } else {
          // Same-type matching only
          premises.push(generateUniquePremise(targetData.typeId, false));
        }
      }
    } else {
      // Generate new random premises
      for(let i = 0; i < count; i++) {
        const typeId = rand(1, 62);
        premises.push(generateUniquePremise(typeId, state.crossTypeEnabled));
      }
    }

    return premises;
  }

  // Build match schedule
  function buildSchedule(n, trials, matchRate) {
    const schedule = new Array(trials).fill(false);
    
    if (state.useWalkthrough) {
      // Use predefined walkthrough matches
      return [false, false, true, true, false, true, true, false, true, true];
    }
    
    const targetMatches = Math.floor(trials * (matchRate / 100));
    let matchCount = 0;
    
    // Place matches starting from trial n
    for(let i = n; i < trials && matchCount < targetMatches; i++) {
      if(Math.random() < (targetMatches - matchCount) / (trials - i)) {
        schedule[i] = true;
        matchCount++;
      }
    }
    
    return schedule;
  }

  // UI update functions
  function updateStats() {
    const accuracy = state.responses > 0 
      ? ((state.hits / state.responses) * 100).toFixed(1) 
      : '—';
    
    $('#kTrial').textContent = state.currentTrial;
    $('#kScore').textContent = state.score;
    $('#kAcc').textContent = accuracy + (state.responses > 0 ? '%' : '');
    $('#kHits').textContent = state.hits;
    $('#kMisses').textContent = state.misses;
    $('#kOmit').textContent = state.omissions;
  }

  function addLog(message) {
    state.log.push(`[${new Date().toLocaleTimeString()}] ${message}`);
    const logEl = $('#log');
    if(logEl) {
      const entry = document.createElement('div');
      entry.textContent = message;
      logEl.appendChild(entry);
      logEl.scrollTop = logEl.scrollHeight;
    }
  }

  function updateStructureInfo(trialData) {
    const infoEl = $('#structureInfo');
    if (!infoEl) return;
    
    const current = trialData[0];
    let info = `Current: Type ${current.actualTypeId || current.typeId} - ${current.structure}`;
    
    if (state.currentTrial >= state.n) {
      const nBackData = state.history[state.currentTrial - state.n][0];
      info += ` | N-back: Type ${nBackData.actualTypeId || nBackData.typeId} - ${nBackData.structure}`;
      
      const isMatch = structureEquivalence.areEquivalent(current.structure, nBackData.structure);
      if (isMatch) {
        info += ' <span style="color:#2ecc71">✓ STRUCTURAL MATCH</span>';
        if (current.crossTypeMatch) {
          info += ' <span class="match-indicator cross-type">CROSS-TYPE</span>';
        }
      }
    }
    
    infoEl.innerHTML = info;
  }

  // Present trial
  function presentTrial() {
    if(!state.running || state.currentTrial >= state.trials) {
      endSession();
      return;
    }

    const shouldMatch = state.schedule[state.currentTrial];
    let trialData;
    
    if(shouldMatch && state.currentTrial >= state.n) {
      // Generate matching premises
      const matchTarget = state.history[state.currentTrial - state.n];
      trialData = generateTrialPremises(state.premisesPerTrial, matchTarget);
      
      // Log match details
      const crossTypeMatches = trialData.filter(d => d.crossTypeMatch);
      if (crossTypeMatches.length > 0) {
        addLog(`Trial ${state.currentTrial + 1}: CROSS-TYPE MATCH - Type ${trialData[0].actualTypeId} matches Type ${matchTarget[0].typeId} (${trialData[0].structure} ≡ ${matchTarget[0].structure})`);
      } else {
        addLog(`Trial ${state.currentTrial + 1}: SAME-TYPE MATCH - Type ${trialData[0].typeId} (${trialData[0].structure})`);
      }
    } else {
      // Generate new premises
      trialData = generateTrialPremises(state.premisesPerTrial);
      addLog(`Trial ${state.currentTrial + 1}: New - Type ${trialData[0].actualTypeId || trialData[0].typeId} (${trialData[0].structure})`);
    }
    
    state.history.push(trialData);
    
    // Display premises
    const container = $('#premiseDisplay');
    container.innerHTML = '';
    trialData.forEach((data, index) => {
      const div = document.createElement('div');
      div.className = 'premise';
      const num = document.createElement('span');
      num.className = 'premise-number';
      num.textContent = `${index + 1}.`;
      const text = document.createElement('span');
      text.className = 'premise-text';
      text.textContent = data.premise;
      div.appendChild(num);
      div.appendChild(text);
      container.appendChild(div);
    });

    // Update structure info
    updateStructureInfo(trialData);

    // Text-to-speech - Fixed to properly extract and speak premises
    if (window.ImagiVoice && window.ImagiVoice.hasTTS) {
      // Extract just the text content from the premises
      const premiseElements = container.querySelectorAll('.premise-text');
      const lines = Array.from(premiseElements).map(el => el.textContent || el.innerText || '');
      
      console.log('[Game] Attempting to speak premises:', lines);
      
      if (lines.length > 0) {
        window.ImagiVoice.speakPremiseList(lines);
        // Enable repeat button after speaking
        const repeatBtn = document.getElementById('repeatBtn');
        if(repeatBtn) repeatBtn.disabled = false;
      }
    } else {
      console.log('[Game] Voice not available:', {
        ImagiVoice: window.ImagiVoice,
        hasTTS: window.ImagiVoice ? window.ImagiVoice.hasTTS : false
      });
    }
    
    // Update status
    $('#status').textContent = `Trial ${state.currentTrial + 1} of ${state.trials} • N-back: ${state.n}`;
    
    // Enable response buttons
    $('#btnMatch').disabled = false;
    $('#btnNoMatch').disabled = false;
    
    // Start timer
    startTimer();
  }

  // Timer management
  function startTimer() {
    clearTimeout(state.timer);
    
    const timerBar = $('#timerBar');
    timerBar.style.width = '100%';
    timerBar.style.transition = 'none';
    
    setTimeout(() => {
      timerBar.style.transition = `width ${state.secondsPerTrial}s linear`;
      timerBar.style.width = '0%';
    }, 50);
    
    state.timer = setTimeout(() => {
      handleOmission();
    }, state.secondsPerTrial * 1000);
  }

  // Handle omission
  function handleOmission() {
    state.omissions++;
    state.responses++;
    
    const expected = state.schedule[state.currentTrial];
    const message = expected ? 'Time up! Expected: MATCH' : 'Time up! Expected: NO MATCH';
    $('#status').textContent = message;
    addLog(`Trial ${state.currentTrial + 1}: OMISSION (expected: ${expected ? 'MATCH' : 'NO MATCH'})`);
    
    $('#btnMatch').disabled = true;
    $('#btnNoMatch').disabled = true;
    
    state.currentTrial++;
    updateStats();
    
    setTimeout(() => presentTrial(), 1000);
  }

  // Handle response
  function handleResponse(isMatch) {
    if(!state.running) return;
    
    clearTimeout(state.timer);
    $('#timerBar').style.width = '0%';
    
    const expected = state.schedule[state.currentTrial];
    const correct = (isMatch === expected);
    
    if(correct) {
      state.hits++;
      state.score += 10;
      $('#status').textContent = '✓ Correct!';
      addLog(`Trial ${state.currentTrial + 1}: CORRECT (${isMatch ? 'MATCH' : 'NO MATCH'})`);
    } else {
      state.misses++;
      $('#status').textContent = '✗ Incorrect';
      addLog(`Trial ${state.currentTrial + 1}: INCORRECT (expected: ${expected ? 'MATCH' : 'NO MATCH'})`);
    }
    
    state.responses++;
    $('#btnMatch').disabled = true;
    $('#btnNoMatch').disabled = true;
    
    state.currentTrial++;
    updateStats();
    
    setTimeout(() => presentTrial(), 1000);
  }

  // Start session
  function startSession() {
    // Reset state
    state.running = true;
    state.n = parseInt($('#nback').value);
    state.secondsPerTrial = parseFloat($('#sec').value);
    state.premisesPerTrial = parseInt($('#premises').value);
    state.trials = parseInt($('#trials').value);
    state.matchRate = parseInt($('#matchRate').value);
    state.crossTypeEnabled = $('#crossTypeMatching').checked;
    state.useWalkthrough = $('#testWalkthrough').checked;
    
    if (state.useWalkthrough) {
      state.trials = 10;
      state.n = 2;
      $('#trials').value = 10;
      $('#trialsV').textContent = 10;
      $('#nback').value = 2;
      $('#nbackV').textContent = 2;
    }
    
    state.currentTrial = 0;
    state.history = [];
    state.schedule = buildSchedule(state.n, state.trials, state.matchRate);
    state.responses = 0;
    state.hits = 0;
    state.misses = 0;
    state.omissions = 0;
    state.score = 0;
    state.log = [];
    
    // Clear used premises
    usedPremises.clear();
    letterIndex = 0;
    
    // Reset UI
    $('#log').innerHTML = '';
    updateStats();
    
    // Update buttons
    $('#start').disabled = true;
    $('#stop').disabled = false;
    
    const mode = state.crossTypeEnabled ? 'Cross-Type Matching' : 'Same-Type Only';
    const walkthrough = state.useWalkthrough ? ' (10-Trial Walkthrough)' : '';
    addLog(`Session started: ${mode}${walkthrough}, N-back=${state.n}, Trials=${state.trials}`);
    
    // Start first trial
    presentTrial();
  }

  // End session
  function endSession() {
    state.running = false;
    clearTimeout(state.timer);
    
    const accuracy = state.responses > 0 
      ? ((state.hits / state.responses) * 100).toFixed(1)
      : 0;
    
    $('#status').textContent = `Session complete! Score: ${state.score} (${accuracy}% accuracy)`;
    addLog(`Session ended: Score=${state.score}, Accuracy=${accuracy}%`);
    
    $('#start').disabled = false;
    $('#stop').disabled = true;
    $('#btnMatch').disabled = true;
    $('#btnNoMatch').disabled = true;
    
    // Disable repeat button
    const repeatBtn = document.getElementById('repeatBtn');
    if(repeatBtn) repeatBtn.disabled = true;
  }

  // Export session log
  function exportLog() {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const filename = `imagi-world-session-${timestamp}.txt`;
    const content = [
      'Imagi-World Session Log',
      '=' .repeat(50),
      `Date: ${new Date().toLocaleString()}`,
      `Configuration:`,
      `  N-back: ${state.n}`,
      `  Trials: ${state.trials}`,
      `  Match Rate: ${state.matchRate}%`,
      `  Cross-Type Matching: ${state.crossTypeEnabled}`,
      `  Walkthrough Test: ${state.useWalkthrough}`,
      '',
      'Session Log:',
      '-'.repeat(50),
      ...state.log,
      '',
      'Final Statistics:',
      '-'.repeat(50),
      `  Score: ${state.score}`,
      `  Accuracy: ${state.responses > 0 ? ((state.hits / state.responses) * 100).toFixed(1) : 0}%`,
      `  Hits: ${state.hits}`,
      `  Misses: ${state.misses}`,
      `  Omissions: ${state.omissions}`
    ].join('\n');
    
    const blob = new Blob([content], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.click();
    URL.revokeObjectURL(url);
  }

  // Bind UI controls
  function bindControls() {
    // Sliders
    $('#nback').addEventListener('input', e => {
      $('#nbackV').textContent = e.target.value;
      state.n = parseInt(e.target.value);
    });
    
    $('#sec').addEventListener('input', e => {
      $('#secV').textContent = e.target.value;
      $('#secNum').value = e.target.value;
      state.secondsPerTrial = parseFloat(e.target.value);
    });
    
    $('#secNum').addEventListener('input', e => {
      $('#sec').value = e.target.value;
      $('#secV').textContent = e.target.value;
      state.secondsPerTrial = parseFloat(e.target.value);
    });
    
    $('#premises').addEventListener('input', e => {
      $('#premisesV').textContent = e.target.value;
      $('#premisesNum').value = e.target.value;
      state.premisesPerTrial = parseInt(e.target.value);
    });
    
    $('#premisesNum').addEventListener('input', e => {
      $('#premises').value = e.target.value;
      $('#premisesV').textContent = e.target.value;
      state.premisesPerTrial = parseInt(e.target.value);
    });
    
    $('#trials').addEventListener('input', e => {
      $('#trialsV').textContent = e.target.value;
      $('#trialsNum').value = e.target.value;
      state.trials = parseInt(e.target.value);
    });
    
    $('#trialsNum').addEventListener('input', e => {
      $('#trials').value = e.target.value;
      $('#trialsV').textContent = e.target.value;
      state.trials = parseInt(e.target.value);
    });
    
    $('#matchRate').addEventListener('input', e => {
      $('#matchRateV').textContent = e.target.value;
      state.matchRate = parseInt(e.target.value);
    });
    
    // Checkboxes
    $('#crossTypeMatching').addEventListener('change', e => {
      state.crossTypeEnabled = e.target.checked;
    });
    
    $('#testWalkthrough').addEventListener('change', e => {
      state.useWalkthrough = e.target.checked;
      if (e.target.checked) {
        $('#trials').value = 10;
        $('#trialsV').textContent = 10;
        $('#nback').value = 2;
        $('#nbackV').textContent = 2;
        $('#matchRate').value = 50;
        $('#matchRateV').textContent = 50;
      }
    });
    
    // Buttons
    $('#start').addEventListener('click', startSession);
    $('#stop').addEventListener('click', endSession);
    $('#reset').addEventListener('click', () => {
      state.score = 0;
      state.hits = 0;
      state.misses = 0;
      state.omissions = 0;
      state.responses = 0;
      updateStats();
      addLog('Statistics reset');
    });
    
    $('#btnMatch').addEventListener('click', () => handleResponse(true));
    $('#btnNoMatch').addEventListener('click', () => handleResponse(false));
    $('#download').addEventListener('click', exportLog);
    
    // Keyboard shortcuts
    document.addEventListener('keydown', e => {
      if(!state.running) return;
      if(e.key === '1' || e.key === 'm' || e.key === 'M') {
        if(!$('#btnMatch').disabled) handleResponse(true);
      } else if(e.key === '2' || e.key === 'n' || e.key === 'N') {
        if(!$('#btnNoMatch').disabled) handleResponse(false);
      }
    });
  }

  // Initialize
  function init() {
    bindControls();
    updateStats();
    addLog('System initialized with cross-type structural matching enabled.');
    
    // Initialize and test voice system
    if(window.ImagiVoice && typeof window.ImagiVoice.init === 'function') {
      window.ImagiVoice.init();
      
      // Test voice availability
      setTimeout(() => {
        if(window.ImagiVoice.hasTTS) {
          addLog('Voice system: Available and ready');
          console.log('[Game] Voice system initialized successfully');
        } else {
          addLog('Voice system: Not available (text-to-speech may be disabled in browser)');
          console.log('[Game] Voice system not available');
        }
      }, 500);
    } else {
      addLog('Voice system: Module not loaded');
      console.error('[Game] ImagiVoice module not found on window object');
    }
  }

  // Safe session runner
  window.runSessionSafe = function() {
    try {
      startSession();
    } catch(error) {
      console.error('Session error:', error);
      addLog(`Error: ${error.message}`);
      endSession();
    }
  };

  // Initialize on DOM ready
  if(document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }
})();
</script>

</body>
</html>
