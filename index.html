<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Auditory N-Back</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            background: linear-gradient(135deg, #0a0a0f 0%, #1a1a2e 50%, #0f0f1a 100%);
            min-height: 100vh;
            color: #e8e8e8;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .container { width: 100%; max-width: 500px; padding: 20px; }
        h1 { text-align: center; font-size: 1.6rem; margin-bottom: 8px; color: #00d9ff; }
        .subtitle { text-align: center; color: #555; margin-bottom: 30px; font-size: 0.85rem; }
        .settings { display: flex; flex-wrap: wrap; justify-content: center; gap: 20px; margin-bottom: 30px; }
        .setting { display: flex; flex-direction: column; align-items: center; gap: 6px; }
        .setting label { font-size: 0.75rem; color: #666; text-transform: uppercase; }
        select {
            background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.15);
            color: #fff; padding: 10px 15px; border-radius: 8px; font-size: 1rem; min-width: 90px;
        }
        .toggle-container { display: flex; align-items: center; gap: 10px; }
        .toggle {
            width: 50px; height: 26px; background: rgba(255,255,255,0.1);
            border-radius: 13px; position: relative; cursor: pointer;
            transition: background 0.3s;
        }
        .toggle.active { background: #00ff88; }
        .toggle::after {
            content: ''; position: absolute; width: 22px; height: 22px;
            background: #fff; border-radius: 50%; top: 2px; left: 2px;
            transition: transform 0.3s;
        }
        .toggle.active::after { transform: translateX(24px); }
        .display { text-align: center; margin-bottom: 30px; }
        .letter {
            font-size: 6rem; font-weight: 200; height: 180px;
            display: flex; align-items: center; justify-content: center;
            color: #00d9ff; text-shadow: 0 0 30px rgba(0,217,255,0.5); text-transform: uppercase;
        }
        .letter.countdown { color: #ff8800; text-shadow: 0 0 30px rgba(255,136,0,0.5); }
        .letter.practice-mode { color: #00ff88; text-shadow: 0 0 30px rgba(0,255,136,0.5); }
        .stats { display: flex; justify-content: center; gap: 40px; margin-bottom: 20px; }
        .stat { text-align: center; }
        .stat-value { font-size: 1.8rem; font-weight: 300; color: #00d9ff; }
        .stat-label { font-size: 0.7rem; color: #555; text-transform: uppercase; }
        .stat.practice .stat-value { color: #00ff88; }
        .feedback { text-align: center; height: 24px; font-size: 0.85rem; margin-bottom: 15px; }
        .feedback.hit { color: #00ff88; }
        .feedback.miss { color: #ff4444; }
        .feedback.false-alarm { color: #ff8800; }
        .feedback.correct-rejection { color: #00d9ff; }
        .buttons { display: flex; justify-content: center; gap: 15px; margin-bottom: 20px; }
        .btn-response {
            width: 120px; height: 60px; border: none; border-radius: 12px;
            font-size: 1rem; font-weight: 600; cursor: pointer;
            -webkit-tap-highlight-color: transparent;
            transition: transform 0.1s, opacity 0.2s;
        }
        .btn-response:active { transform: scale(0.95); }
        .btn-response:disabled { opacity: 0.3; cursor: not-allowed; }
        .btn-match { background: linear-gradient(135deg, #00ff88, #00cc6a); color: #000; }
        .btn-no-match { background: linear-gradient(135deg, #ff6b6b, #ee5a5a); color: #fff; }
        .controls { display: flex; justify-content: center; gap: 15px; }
        .btn-control { 
            padding: 12px 30px; border-radius: 8px; font-size: 0.9rem; cursor: pointer; border: none;
            -webkit-tap-highlight-color: transparent;
        }
        .btn-start { background: #00d9ff; color: #000; font-weight: 600; }
        .btn-stop { background: #ff4444; color: #fff; display: none; }
        .hint { text-align: center; color: #333; font-size: 0.75rem; margin-top: 25px; }
        .hint kbd { background: rgba(255,255,255,0.1); padding: 3px 8px; border-radius: 4px; }
        .history { margin-top: 20px; padding: 15px; background: rgba(255,255,255,0.03); border-radius: 8px; }
        .history-label { font-size: 0.7rem; color: #444; text-transform: uppercase; margin-bottom: 8px; }
        .history-letters { font-family: monospace; font-size: 1rem; color: #666; letter-spacing: 2px; word-wrap: break-word; }
        .history-letters .current { color: #00d9ff; font-weight: bold; }
        .history-letters .match-position { color: #00ff88; }
        .practice-banner {
            background: rgba(0,255,136,0.1); border: 1px solid rgba(0,255,136,0.3);
            padding: 8px 15px; border-radius: 8px; text-align: center;
            color: #00ff88; font-size: 0.8rem; margin-bottom: 20px; display: none;
        }
        .practice-banner.visible { display: block; }
        .manual-btn {
            position: fixed;
            top: 15px;
            right: 15px;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            color: #888;
            font-size: 1.2rem;
            cursor: pointer;
            z-index: 100;
        }
        .manual-btn:hover { background: rgba(255,255,255,0.15); }
        .manual-overlay {
            display: none;
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.92);
            z-index: 200;
            overflow-y: auto;
            padding: 20px;
        }
        .manual-overlay.visible { display: block; }
        .manual-content {
            max-width: 600px;
            margin: 0 auto;
            color: #ccc;
            font-size: 0.95rem;
            line-height: 1.7;
        }
        .manual-content h2 { color: #00d9ff; margin: 25px 0 15px 0; font-weight: 500; }
        .manual-content h3 { color: #00ff88; margin: 20px 0 10px 0; font-weight: 500; font-size: 1rem; }
        .manual-content p { margin-bottom: 12px; }
        .manual-content .close-btn {
            display: inline-block;
            margin-top: 30px;
            padding: 12px 30px;
            background: #00d9ff;
            color: #000;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
        }
        .manual-content .emphasis { color: #ff8800; }
        .manual-content .note { color: #888; font-size: 0.85rem; font-style: italic; }
        .breath-indicator {
            text-align: center;
            height: 30px;
            font-size: 0.85rem;
            color: #444;
            margin-bottom: 10px;
        }
        .breath-indicator.inhale { color: #00d9ff; }
        .breath-indicator.exhale { color: #00ff88; }
        .error-detail { font-size: 0.75rem; color: #666; margin-top: 4px; }
    </style>
</head>
<body>
    <button class="manual-btn" id="manualBtn">?</button>

```
<div class="manual-overlay" id="manualOverlay">
    <div class="manual-content">
        <h2>How to Play</h2>
        
        <h3>The Basic Task</h3>
        <p>You will hear short melodic patterns. Your task is to determine whether the <span class="emphasis">current pattern</span> matches the pattern you heard <span class="emphasis">N positions back</span>.</p>
        
        <p>For example, in 2-back mode: Does what you just heard match what you heard 2 patterns ago?</p>
        
        <h3>Controls</h3>
        <p><strong>MATCH</strong> â€” Press when the current pattern matches the N-back position.<br>
        <strong>NO MATCH</strong> â€” Press when it does not match.<br>
        Keyboard: <strong>M</strong> = Match, <strong>N</strong> = No Match, <strong>Space</strong> = Start/Stop</p>
        
        <h3>What Counts as a "Match"?</h3>
        <p>Here is where this training differs from ordinary memory tasks. The exact notes you hear will be <span class="emphasis">different every time</span>. You are not listening for identical sounds. You are listening for whether two patterns share the same <span class="emphasis">underlying structure</span>.</p>
        
        <p class="note">We have intentionally not described what these structures are or how many exist. Discovering them yourself is part of the training. Your task is to perceive the relational shape of each pattern and hold that shape in memory.</p>
        
        <h3>Why This Matters</h3>
        <p>This is not a memorization task. It is training in <span class="emphasis">relational perception</span> â€” the ability to extract abstract structure from concrete experience. Because the surface features (actual notes) are always novel, you cannot rely on rote memory. You must engage the deeper pattern-recognition capacity that underlies fluid intelligence.</p>
        
        <h3>Tips for Beginners</h3>
        <p>â€¢ Start with 1-back or 2-back to learn the rhythm.<br>
        â€¢ Use Practice Mode first â€” it shows feedback without scoring.<br>
        â€¢ Don't overthink. Let your intuition recognize the shapes.<br>
        â€¢ When you notice confusion, observe it. Which positions are you conflating?<br>
        â€¢ Enable Breath Sync to help anchor your attention rhythmically.</p>
        
        <button class="close-btn" id="closeManual">Begin Training</button>
    </div>
</div>

<div class="container">
    <h1>Auditory N-Back</h1>
    <p class="subtitle">Piano Tones</p>
    
    <div class="practice-banner" id="practiceBanner">
        ðŸŽ¯ PRACTICE MODE â€” No scoring, learn the rhythm
    </div>
    
    <div class="settings" id="settings">
        <div class="setting">
            <label>N-Back</label>
            <select id="nBack">
                <option value="1">1</option>
                <option value="2" selected>2</option>
                <option value="3">3</option>
                <option value="4">4</option>
                <option value="5">5</option>
                <option value="6">6</option>
                <option value="7">7</option>
                <option value="8">8</option>
                <option value="9">9</option>
                <option value="10">10</option>
                <option value="11">11</option>
                <option value="12">12</option>
                <option value="13">13</option>
                <option value="14">14</option>
                <option value="15">15</option>
            </select>
        </div>
        <div class="setting">
            <label>Interval (sec)</label>
            <select id="interval">
                <option value="2.5">2.5</option>
                <option value="3" selected>3</option>
                <option value="3.5">3.5</option>
                <option value="4">4</option>
                <option value="5">5</option>
                <option value="6">6</option>
                <option value="7">7</option>
                <option value="8">8</option>
                <option value="10">10</option>
                <option value="12">12</option>
                <option value="15">15</option>
                <option value="20">20</option>
                <option value="25">25</option>
                <option value="30">30</option>
            </select>
        </div>
        <div class="setting">
            <label>Practice</label>
            <div class="toggle-container">
                <div class="toggle" id="practiceToggle"></div>
            </div>
        </div>
        <div class="setting">
            <label>Breath Sync</label>
            <div class="toggle-container">
                <div class="toggle" id="breathToggle"></div>
            </div>
        </div>
    </div>
    
    <div class="display">
        <div class="breath-indicator" id="breathIndicator"></div>
        <div class="letter" id="letter">â€”</div>
    </div>
    
    <div class="stats">
        <div class="stat">
            <div class="stat-value" id="trial">0</div>
            <div class="stat-label">Trial</div>
        </div>
        <div class="stat" id="accuracyStat">
            <div class="stat-value" id="accuracy">â€”</div>
            <div class="stat-label">Accuracy</div>
        </div>
        <div class="stat">
            <div class="stat-value" id="hits">0</div>
            <div class="stat-label">Hits</div>
        </div>
    </div>
    
    <div class="feedback" id="feedback"></div>
    
    <div class="buttons">
        <button class="btn-response btn-match" id="btnMatch" disabled>MATCH</button>
        <button class="btn-response btn-no-match" id="btnNoMatch" disabled>NO MATCH</button>
    </div>
    
    <div class="controls">
        <button class="btn-control btn-start" id="btnStart">Start</button>
        <button class="btn-control btn-stop" id="btnStop">Stop</button>
    </div>
    
    <div class="hint">
        <kbd>M</kbd> Match | <kbd>N</kbd> No Match | <kbd>Space</kbd> Start/Stop
    </div>
    
    <div class="history">
        <div class="history-label">Sequence</div>
        <div class="history-letters" id="historyLetters">â€”</div>
    </div>
</div>

<script>
    // ========================================
    // STATE
    // ========================================
    var running = false;
    var trialNum = 0;
    var sequence = [];
    var hits = 0;
    var misses = 0;
    var falseAlarms = 0;
    var correctRejections = 0;
    var responded = false;
    var nextTrialTimeout = null;
    var practiceMode = false;
    var breathSync = false;
    var breathPhase = 'exhale'; // 'inhale' or 'exhale'
    var breathTimeout = null;
    var recentPerformance = []; // Track last 10 trials for adaptive difficulty
    var baseLureRate = 0.28;
    var currentLureRate = 0.28;
    var lastConfusedPositions = null; // Track which positions were confused
    
    // ========================================
    // AUDIO CONTEXT
    // ========================================
    var audioCtx = null;
    var masterGain = null;
    var reverbNode = null;
    var reverbGain = null;
    var dryGain = null;
    
    // ========================================
    // CONTOUR CATEGORIES - 20 distinct relational shapes
    // 6 directions = 7 notes (start + 6 transitions)
    // Selected for: perceptual distinctness, challenging pairs,
    // coverage of structural space, resistance to verbal labeling
    // Match = same contour structure, NOT same notes
    // ========================================
    var CONTOURS = [
        // Pure movement
        { name: 'Rise',        symbol: 'â†—â†—â†—â†—â†—â†—', directions: [1, 1, 1, 1, 1, 1] },
        { name: 'Fall',        symbol: 'â†˜â†˜â†˜â†˜â†˜â†˜', directions: [-1, -1, -1, -1, -1, -1] },
        // Arch variants (peak position varies)
        { name: 'Arch',        symbol: 'â†—â†—â†—â†˜â†˜â†˜', directions: [1, 1, 1, -1, -1, -1] },
        { name: 'EarlyPeak',   symbol: 'â†—â†—â†˜â†˜â†˜â†˜', directions: [1, 1, -1, -1, -1, -1] },
        { name: 'LatePeak',    symbol: 'â†—â†—â†—â†—â†˜â†˜', directions: [1, 1, 1, 1, -1, -1] },
        // Dip variants (trough position varies)
        { name: 'Dip',         symbol: 'â†˜â†˜â†˜â†—â†—â†—', directions: [-1, -1, -1, 1, 1, 1] },
        { name: 'EarlyTrough', symbol: 'â†˜â†˜â†—â†—â†—â†—', directions: [-1, -1, 1, 1, 1, 1] },
        { name: 'LateTrough',  symbol: 'â†˜â†˜â†˜â†˜â†—â†—', directions: [-1, -1, -1, -1, 1, 1] },
        // Periodic (alternating)
        { name: 'ZigUp',       symbol: 'â†—â†˜â†—â†˜â†—â†˜', directions: [1, -1, 1, -1, 1, -1] },
        { name: 'ZigDown',     symbol: 'â†˜â†—â†˜â†—â†˜â†—', directions: [-1, 1, -1, 1, -1, 1] },
        // Plateau patterns
        { name: 'RiseFlat',    symbol: 'â†—â†—â†—â†’â†’â†’', directions: [1, 1, 1, 0, 0, 0] },
        { name: 'FlatRise',    symbol: 'â†’â†’â†’â†—â†—â†—', directions: [0, 0, 0, 1, 1, 1] },
        { name: 'FallFlat',    symbol: 'â†˜â†˜â†˜â†’â†’â†’', directions: [-1, -1, -1, 0, 0, 0] },
        { name: 'FlatFall',    symbol: 'â†’â†’â†’â†˜â†˜â†˜', directions: [0, 0, 0, -1, -1, -1] },
        // Double turning points
        { name: 'DoublePeak',  symbol: 'â†—â†˜â†—â†˜â†’â†’', directions: [1, -1, 1, -1, 0, 0] },
        { name: 'DoubleDip',   symbol: 'â†˜â†—â†˜â†—â†’â†’', directions: [-1, 1, -1, 1, 0, 0] },
        // Step patterns
        { name: 'StepUp',      symbol: 'â†—â†’â†—â†’â†—â†’', directions: [1, 0, 1, 0, 1, 0] },
        { name: 'StepDown',    symbol: 'â†˜â†’â†˜â†’â†˜â†’', directions: [-1, 0, -1, 0, -1, 0] },
        // Swoop patterns (dip/rise with flat transition)
        { name: 'SwoopUp',     symbol: 'â†˜â†˜â†’â†—â†—â†—', directions: [-1, -1, 0, 1, 1, 1] },
        { name: 'SwoopDown',   symbol: 'â†—â†—â†’â†˜â†˜â†˜', directions: [1, 1, 0, -1, -1, -1] }
    ];

    // ========================================
    // GETTERS
    // ========================================
    function getNBack() { 
        return parseInt(document.getElementById('nBack').value); 
    }
    
    function getIntervalMs() { 
        return parseFloat(document.getElementById('interval').value) * 1000; 
    }

    // ========================================
    // AUDIO INITIALIZATION
    // ========================================
    function initAudio() {
        if (audioCtx) {
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
            return;
        }
        
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        // Master output
        masterGain = audioCtx.createGain();
        masterGain.gain.value = 0.8;
        masterGain.connect(audioCtx.destination);
        
        // Dry path
        dryGain = audioCtx.createGain();
        dryGain.gain.value = 0.7;
        dryGain.connect(masterGain);
        
        // Reverb path
        reverbNode = audioCtx.createConvolver();
        reverbNode.buffer = createReverbBuffer(2.2, 2.5);
        
        reverbGain = audioCtx.createGain();
        reverbGain.gain.value = 0.35;
        reverbNode.connect(reverbGain);
        reverbGain.connect(masterGain);
    }
    
    // ========================================
    // CREATE REVERB IMPULSE RESPONSE
    // Simulates a warm concert hall
    // ========================================
    function createReverbBuffer(duration, decay) {
        var length = audioCtx.sampleRate * duration;
        var buffer = audioCtx.createBuffer(2, length, audioCtx.sampleRate);
        var left = buffer.getChannelData(0);
        var right = buffer.getChannelData(1);
        
        for (var i = 0; i < length; i++) {
            var t = i / audioCtx.sampleRate;
            // Exponential decay with early reflections
            var envelope = Math.exp(-t * decay);
            // Add some early reflection bumps
            if (t < 0.1) {
                envelope *= (1 + 0.5 * Math.sin(t * 100));
            }
            var noise = (Math.random() * 2 - 1);
            left[i] = noise * envelope;
            right[i] = (Math.random() * 2 - 1) * envelope;
        }
        
        return buffer;
    }

    // ========================================
    // KARPLUS-STRONG STRING SYNTHESIS
    // Creates realistic plucked/struck string sound
    // ========================================
    function createKarplusStrongBuffer(freq, duration, brightness, pluckPosition) {
        var sampleRate = audioCtx.sampleRate;
        var numSamples = Math.floor(sampleRate * duration);
        var buffer = audioCtx.createBuffer(1, numSamples, sampleRate);
        var data = buffer.getChannelData(0);
        
        // Delay line length determines pitch
        var delayLength = Math.round(sampleRate / freq);
        var delayLine = new Float32Array(delayLength);
        
        // Initialize delay line with excitation signal
        // Mix of noise and harmonic content for piano-like attack
        for (var i = 0; i < delayLength; i++) {
            var pos = i / delayLength;
            
            // Pluck position shapes initial harmonics
            // Plucking near center emphasizes fundamental
            var pluckShape = Math.sin(Math.PI * pos / pluckPosition) * 
                             Math.sin(Math.PI * pos);
            
            // Mix noise with shaped waveform
            var noise = (Math.random() * 2 - 1) * 0.6;
            var shaped = pluckShape * 0.4;
            
            delayLine[i] = noise + shaped;
        }
        
        // Low-pass filter state for Karplus-Strong
        var filterState = 0;
        var damping = brightness; // 0.0 = very dark, 1.0 = bright
        
        // Process
        var readPos = 0;
        for (var i = 0; i < numSamples; i++) {
            // Read from delay line
            var sample = delayLine[readPos];
            
            // Output
            data[i] = sample;
            
            // Low-pass filter (averaging filter with damping control)
            var nextPos = (readPos + 1) % delayLength;
            var nextSample = delayLine[nextPos];
            
            // Weighted average for low-pass effect
            // Higher damping = brighter sound
            var filtered = filterState * (1 - damping) + 
                           ((sample + nextSample) * 0.5) * damping;
            filterState = filtered;
            
            // Write back to delay line with slight decay
            delayLine[readPos] = filtered * 0.996;
            
            readPos = nextPos;
        }
        
        return buffer;
    }

    // ========================================
    // PLAY MELODIC CONTOUR PATTERN
    // Generates novel pitches conforming to contour structure
    // Every trial sounds different, but matches share structure
    // Variable timing adds rhythmic dimension
    // ========================================
    function playContourPattern(contourIndex) {
        if (!audioCtx) return;
        
        var contour = CONTOURS[contourIndex];
        var directions = contour.directions;
        
        // Random starting pitch (MIDI 48-72 = C3-C5)
        var startMidi = 48 + Math.floor(Math.random() * 24);
        
        // Generate 7 pitches following contour directions (start + 6 transitions)
        var midiNotes = [startMidi];
        
        for (var i = 0; i < directions.length; i++) {
            var dir = directions[i];
            var interval;
            
            if (dir === 0) {
                // Same pitch
                interval = 0;
            } else {
                // Random interval size: 2-5 semitones (preserves direction perception)
                interval = dir * (2 + Math.floor(Math.random() * 4));
            }
            
            var nextMidi = midiNotes[midiNotes.length - 1] + interval;
            
            // Clamp to playable range (MIDI 36-84 = C2-C6)
            nextMidi = Math.max(36, Math.min(84, nextMidi));
            
            midiNotes.push(nextMidi);
        }
        
        // Convert MIDI to frequencies
        var frequencies = midiNotes.map(function(midi) {
            return 440 * Math.pow(2, (midi - 69) / 12);
        });
        
        // Variable timing within pattern (adds rhythmic dimension)
        // Base spacing with subtle variation
        var baseSpacing = 0.20;
        var timings = [0];
        for (var i = 1; i < frequencies.length; i++) {
            // Vary by Â±15% for humanization
            var variation = baseSpacing * (0.85 + Math.random() * 0.30);
            timings.push(timings[i-1] + variation);
        }
        
        var now = audioCtx.currentTime;
        
        for (var i = 0; i < frequencies.length; i++) {
            playPatternNote(frequencies[i], now + timings[i], i === 0);
        }
    }
    
    // ========================================
    // PLAY SINGLE NOTE IN PATTERN
    // Slightly shorter decay than standalone notes
    // ========================================
    function playPatternNote(freq, startTime, isFirst) {
        var duration = 1.8;
        var brightness = 0.45 + (freq / 1000) * 0.25;
        brightness = Math.min(0.7, brightness);
        
        // Create note output node
        var noteGain = audioCtx.createGain();
        
        // Softer attack for non-first notes (legato feel)
        var attackTime = isFirst ? 0.008 : 0.012;
        var peakLevel = isFirst ? 0.4 : 0.32;
        
        noteGain.gain.setValueAtTime(0, startTime);
        noteGain.gain.linearRampToValueAtTime(peakLevel, startTime + attackTime);
        noteGain.gain.linearRampToValueAtTime(peakLevel * 0.8, startTime + 0.05);
        noteGain.gain.exponentialRampToValueAtTime(0.001, startTime + duration);
        
        noteGain.connect(dryGain);
        noteGain.connect(reverbNode);
        
        // Create 3 detuned strings
        var detunings = [-0.6, 0, 0.6];
        var stringGains = [0.3, 0.4, 0.3];
        
        for (var s = 0; s < 3; s++) {
            var detunedFreq = freq * Math.pow(2, detunings[s] / 1200);
            var pluckPos = 0.12 + (s * 0.015) + (Math.random() * 0.01);
            
            var stringBuffer = createKarplusStrongBuffer(
                detunedFreq,
                duration + 0.1,
                brightness + (Math.random() * 0.03 - 0.015),
                pluckPos
            );
            
            var stringSource = audioCtx.createBufferSource();
            stringSource.buffer = stringBuffer;
            
            var stringGain = audioCtx.createGain();
            stringGain.gain.value = stringGains[s];
            
            stringSource.connect(stringGain);
            stringGain.connect(noteGain);
            
            var startOffset = s * 0.001;
            stringSource.start(startTime + startOffset);
            stringSource.stop(startTime + duration + 0.2);
        }
        
        // Subtle hammer noise on first note only
        if (isFirst) {
            addHammerNoise(noteGain, freq, startTime);
        }
    }
    
    // ========================================
    // PLAY PIANO NOTE (kept for countdown)
    // Uses multiple detuned Karplus-Strong strings
    // with envelope shaping for piano character
    // ========================================
    function playPianoTone(noteIndex) {
        if (!audioCtx) return;
        
        var note = NOTES[noteIndex];
        var freq = note.freq;
        var now = audioCtx.currentTime;
        
        // Duration varies by pitch (lower = longer)
        var baseDuration = 3.5;
        var duration = baseDuration * Math.pow(300 / freq, 0.25);
        duration = Math.max(2.0, Math.min(duration, 5.0));
        
        // Brightness varies by pitch (higher notes brighter)
        var brightness = 0.4 + (freq / 1200) * 0.35;
        brightness = Math.min(0.75, brightness);
        
        // Create note output node
        var noteGain = audioCtx.createGain();
        
        // Piano envelope: soft attack, natural decay
        var attackTime = 0.008;
        var peakTime = 0.03;
        var decayTime = duration - peakTime;
        
        noteGain.gain.setValueAtTime(0, now);
        noteGain.gain.linearRampToValueAtTime(0.5, now + attackTime);
        noteGain.gain.linearRampToValueAtTime(0.4, now + peakTime);
        noteGain.gain.exponentialRampToValueAtTime(0.001, now + duration);
        
        noteGain.connect(dryGain);
        noteGain.connect(reverbNode);
        
        // Create 3 slightly detuned strings (like real piano)
        var detunings = [-0.8, 0, 0.8]; // cents
        var stringGains = [0.33, 0.4, 0.33];
        
        for (var s = 0; s < 3; s++) {
            // Detune frequency
            var detunedFreq = freq * Math.pow(2, detunings[s] / 1200);
            
            // Slightly different pluck positions for each string
            var pluckPos = 0.12 + (s * 0.02) + (Math.random() * 0.02);
            
            // Create the string buffer
            var stringBuffer = createKarplusStrongBuffer(
                detunedFreq, 
                duration + 0.1, 
                brightness + (Math.random() * 0.05 - 0.025),
                pluckPos
            );
            
            // Play string
            var stringSource = audioCtx.createBufferSource();
            stringSource.buffer = stringBuffer;
            
            var stringGain = audioCtx.createGain();
            stringGain.gain.value = stringGains[s];
            
            stringSource.connect(stringGain);
            stringGain.connect(noteGain);
            
            // Slight timing variation between strings
            var startOffset = s * 0.002 * Math.random();
            stringSource.start(now + startOffset);
            stringSource.stop(now + duration + 0.2);
        }
        
        // Add hammer noise (very subtle)
        addHammerNoise(noteGain, freq, now);
    }
    
    // ========================================
    // ADD HAMMER NOISE
    // Subtle attack transient
    // ========================================
    function addHammerNoise(destination, freq, startTime) {
        var noiseDuration = 0.025;
        var noiseLength = Math.floor(audioCtx.sampleRate * noiseDuration);
        var noiseBuffer = audioCtx.createBuffer(1, noiseLength, audioCtx.sampleRate);
        var noiseData = noiseBuffer.getChannelData(0);
        
        // Shaped noise burst
        for (var i = 0; i < noiseLength; i++) {
            var t = i / noiseLength;
            // Quick attack, quick decay
            var env = Math.sin(t * Math.PI) * Math.exp(-t * 8);
            noiseData[i] = (Math.random() * 2 - 1) * env;
        }
        
        var noiseSource = audioCtx.createBufferSource();
        noiseSource.buffer = noiseBuffer;
        
        // Bandpass filter centered on note frequency
        var filter = audioCtx.createBiquadFilter();
        filter.type = 'bandpass';
        filter.frequency.value = freq * 1.5;
        filter.Q.value = 1.0;
        
        var noiseGain = audioCtx.createGain();
        noiseGain.gain.value = 0.12;
        
        noiseSource.connect(filter);
        filter.connect(noiseGain);
        noiseGain.connect(destination);
        
        noiseSource.start(startTime);
        noiseSource.stop(startTime + noiseDuration);
    }
    
    // ========================================
    // COUNTDOWN TONE - Gentle bell
    // ========================================
    function playCountdownTone(pitch) {
        if (!audioCtx) return;
        
        var now = audioCtx.currentTime;
        var duration = 0.4;
        
        var osc = audioCtx.createOscillator();
        var osc2 = audioCtx.createOscillator();
        var gain = audioCtx.createGain();
        
        osc.type = 'sine';
        osc.frequency.value = pitch;
        osc2.type = 'sine';
        osc2.frequency.value = pitch * 2.4;
        
        var gain2 = audioCtx.createGain();
        gain2.gain.value = 0.15;
        
        gain.gain.setValueAtTime(0, now);
        gain.gain.linearRampToValueAtTime(0.15, now + 0.01);
        gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
        
        osc.connect(gain);
        osc2.connect(gain2);
        gain2.connect(gain);
        gain.connect(masterGain);
        
        osc.start(now);
        osc.stop(now + duration);
        osc2.start(now);
        osc2.stop(now + duration);
    }

    // ========================================
    // CORE LOGIC
    // ========================================
    function isCurrentMatch() {
        var n = getNBack();
        if (sequence.length <= n) return false;
        return sequence[sequence.length - 1] === sequence[sequence.length - 1 - n];
    }

    function pickContour() {
        var n = getNBack();
        
        // Adaptive difficulty: adjust lure rate based on recent performance
        if (recentPerformance.length >= 10) {
            var recentCorrect = recentPerformance.filter(function(x) { return x; }).length;
            var recentAccuracy = recentCorrect / recentPerformance.length;
            
            // If doing well (>80%), increase lures; if struggling (<60%), decrease
            if (recentAccuracy > 0.8) {
                currentLureRate = Math.min(0.38, baseLureRate + 0.05);
            } else if (recentAccuracy < 0.6) {
                currentLureRate = Math.max(0.18, baseLureRate - 0.05);
            } else {
                currentLureRate = baseLureRate;
            }
        }
        
        // Need at least n items to have a target
        if (sequence.length >= n) {
            var roll = Math.random();
            var target = sequence[sequence.length - n];
            
            // 30% - Exact n-back target
            if (roll < 0.30) {
                return target;
            }
            
            // Adaptive lure rate - Lure trials (nÂ±1 positions) for cognitive interference
            if (roll < 0.30 + currentLureRate) {
                var lures = [];
                
                // n-1 lure
                if (n > 1) {
                    var lure1 = sequence[sequence.length - n + 1];
                    if (lure1 !== target) {
                        lures.push({ contour: lure1, position: n - 1 });
                    }
                }
                
                // n+1 lure
                if (sequence.length > n) {
                    var lure2 = sequence[sequence.length - n - 1];
                    if (lure2 !== target) {
                        lures.push({ contour: lure2, position: n + 1 });
                    }
                }
                
                if (lures.length > 0) {
                    var chosen = lures[Math.floor(Math.random() * lures.length)];
                    return chosen.contour;
                }
            }
        }
        
        // Random contour
        return Math.floor(Math.random() * CONTOURS.length);
    }

    // ========================================
    // UI UPDATES
    // ========================================
    function updateHistory() {
        var n = getNBack();
        var el = document.getElementById('historyLetters');
        if (sequence.length === 0) { 
            el.textContent = 'â€”'; 
            return; 
        }
        var html = '';
        for (var i = 0; i < sequence.length; i++) {
            var contourSymbol = CONTOURS[sequence[i]].symbol;
            if (i === sequence.length - 1) {
                html += '<span class="current">' + contourSymbol + '</span>';
            } else if (i === sequence.length - 1 - n && sequence.length > n) {
                html += '<span class="match-position">' + contourSymbol + '</span>';
            } else {
                html += contourSymbol;
            }
            if (i < sequence.length - 1) html += ' ';
        }
        el.innerHTML = html;
    }

    function showFeedback(text, cls) {
        var el = document.getElementById('feedback');
        el.textContent = text;
        el.className = 'feedback ' + cls;
    }
    
    function clearFeedback() {
        var el = document.getElementById('feedback');
        el.textContent = '';
        el.className = 'feedback';
    }

    function updateAccuracy() {
        var total = hits + misses + falseAlarms + correctRejections;
        var el = document.getElementById('accuracy');
        if (total === 0) { 
            el.textContent = 'â€”'; 
            return; 
        }
        var acc = Math.round(((hits + correctRejections) / total) * 100);
        el.textContent = acc + '%';
    }

    // ========================================
    // SCORING
    // ========================================
    function evaluatePreviousTrial() {
        if (practiceMode) return;
        
        var n = getNBack();
        if (sequence.length > n + 1 && !responded) {
            var prevIndex = sequence.length - 2;
            var wasMatch = sequence[prevIndex] === sequence[prevIndex - n];
            if (wasMatch) {
                misses++;
            } else {
                correctRejections++;
            }
            updateAccuracy();
        }
    }

    // ========================================
    // TRIAL EXECUTION
    // ========================================
    function runTrial() {
        if (!running) return;
        
        if (trialNum > 0) {
            evaluatePreviousTrial();
        }
        
        clearFeedback();
        
        trialNum++;
        responded = false;
        
        var contourIndex = pickContour();
        sequence.push(contourIndex);
        
        document.getElementById('trial').textContent = trialNum;
        
        var canRespond = sequence.length > getNBack();
        document.getElementById('btnMatch').disabled = !canRespond;
        document.getElementById('btnNoMatch').disabled = !canRespond;
        
        var letterEl = document.getElementById('letter');
        var breathEl = document.getElementById('breathIndicator');
        
        if (breathSync) {
            // Breath sync: pattern plays on exhale phase
            breathEl.textContent = 'exhale...';
            breathEl.className = 'breath-indicator exhale';
        }
        
        // Play melodic contour pattern (novel pitches, same structure)
        playContourPattern(contourIndex);
        
        // Show visual after delay
        setTimeout(function() {
            if (running) {
                letterEl.textContent = CONTOURS[contourIndex].symbol;
                if (practiceMode) {
                    letterEl.className = 'letter practice-mode';
                } else {
                    letterEl.className = 'letter';
                }
                updateHistory();
            }
        }, 600);
        
        // Breath indication changes mid-interval
        if (breathSync) {
            var halfInterval = getIntervalMs() / 2;
            breathTimeout = setTimeout(function() {
                if (running) {
                    breathEl.textContent = 'inhale...';
                    breathEl.className = 'breath-indicator inhale';
                }
            }, halfInterval);
        }
        
        // Schedule next trial
        nextTrialTimeout = setTimeout(runTrial, getIntervalMs());
    }

    // ========================================
    // RESPONSE HANDLING
    // ========================================
    function respond(isMatchResponse) {
        if (!running) return;
        if (responded) return;
        if (sequence.length <= getNBack()) return;
        
        responded = true;
        var n = getNBack();
        var wasActualMatch = isCurrentMatch();
        var correct = (isMatchResponse === wasActualMatch);
        
        // Track recent performance for adaptive difficulty
        recentPerformance.push(correct);
        if (recentPerformance.length > 10) {
            recentPerformance.shift();
        }
        
        // Determine confused position for error feedback
        lastConfusedPositions = null;
        if (!correct && isMatchResponse) {
            // False alarm - they thought it was a match but wasn't
            // Check if it matched a nearby position (lure confusion)
            var currentContour = sequence[sequence.length - 1];
            for (var offset = 1; offset <= 2; offset++) {
                if (n - offset > 0 && sequence.length > n - offset) {
                    if (sequence[sequence.length - 1 - (n - offset)] === currentContour) {
                        lastConfusedPositions = { actual: 'none', confused: n - offset };
                        break;
                    }
                }
                if (sequence.length > n + offset) {
                    if (sequence[sequence.length - 1 - (n + offset)] === currentContour) {
                        lastConfusedPositions = { actual: 'none', confused: n + offset };
                        break;
                    }
                }
            }
        }
        
        if (practiceMode) {
            var msg = '';
            var cls = '';
            if (isMatchResponse && wasActualMatch) {
                msg = 'âœ“ Correct - It was a match!';
                cls = 'hit';
            } else if (isMatchResponse && !wasActualMatch) {
                msg = 'âœ— Not a match';
                if (lastConfusedPositions) {
                    msg += ' (was ' + lastConfusedPositions.confused + '-back)';
                }
                cls = 'false-alarm';
            } else if (!isMatchResponse && wasActualMatch) {
                msg = 'âœ— It WAS a match!';
                cls = 'miss';
            } else {
                msg = 'âœ“ Correct - Not a match';
                cls = 'correct-rejection';
            }
            showFeedback(msg, cls);
        } else {
            if (isMatchResponse && wasActualMatch) {
                hits++;
                showFeedback('âœ“ Hit!', 'hit');
            } else if (isMatchResponse && !wasActualMatch) {
                falseAlarms++;
                var msg = 'âœ— False Alarm';
                if (lastConfusedPositions) {
                    msg += ' (' + lastConfusedPositions.confused + '-back?)';
                }
                showFeedback(msg, 'false-alarm');
            } else if (!isMatchResponse && wasActualMatch) {
                misses++;
                showFeedback('âœ— Miss', 'miss');
            } else {
                correctRejections++;
                showFeedback('âœ“ Correct Rejection', 'correct-rejection');
            }
            document.getElementById('hits').textContent = hits;
            updateAccuracy();
        }
    }

    // ========================================
    // COUNTDOWN
    // ========================================
    function startCountdown(onComplete) {
        var letterEl = document.getElementById('letter');
        letterEl.className = 'letter countdown';
        
        letterEl.textContent = '3';
        playCountdownTone(660);
        
        setTimeout(function() {
            letterEl.textContent = '2';
            playCountdownTone(660);
        }, 1000);
        
        setTimeout(function() {
            letterEl.textContent = '1';
            playCountdownTone(660);
        }, 2000);
        
        setTimeout(function() {
            letterEl.textContent = '0';
            playCountdownTone(880);
        }, 3000);
        
        setTimeout(function() {
            letterEl.textContent = 'â€”';
            letterEl.className = 'letter';
            onComplete();
        }, 4000);
    }

    // ========================================
    // GAME CONTROL
    // ========================================
    function startGame() {
        initAudio();
        
        trialNum = 0;
        sequence = [];
        hits = 0;
        misses = 0;
        falseAlarms = 0;
        correctRejections = 0;
        responded = false;
        recentPerformance = [];
        currentLureRate = baseLureRate;
        lastConfusedPositions = null;
        
        document.getElementById('letter').textContent = 'â€”';
        document.getElementById('letter').className = 'letter';
        document.getElementById('trial').textContent = '0';
        document.getElementById('accuracy').textContent = 'â€”';
        document.getElementById('hits').textContent = '0';
        document.getElementById('breathIndicator').textContent = '';
        document.getElementById('breathIndicator').className = 'breath-indicator';
        clearFeedback();
        document.getElementById('historyLetters').textContent = 'â€”';
        
        document.getElementById('btnStart').style.display = 'none';
        document.getElementById('btnStop').style.display = 'inline-block';
        
        document.getElementById('settings').style.opacity = '0.5';
        document.getElementById('settings').style.pointerEvents = 'none';
        
        if (practiceMode) {
            document.getElementById('practiceBanner').classList.add('visible');
            document.getElementById('accuracyStat').classList.add('practice');
        }
        
        running = true;
        
        startCountdown(function() {
            if (running) {
                runTrial();
            }
        });
    }

    function stopGame() {
        running = false;
        
        if (nextTrialTimeout) {
            clearTimeout(nextTrialTimeout);
            nextTrialTimeout = null;
        }
        
        if (breathTimeout) {
            clearTimeout(breathTimeout);
            breathTimeout = null;
        }
        
        document.getElementById('letter').className = 'letter';
        document.getElementById('breathIndicator').textContent = '';
        document.getElementById('breathIndicator').className = 'breath-indicator';
        document.getElementById('btnStart').style.display = 'inline-block';
        document.getElementById('btnStop').style.display = 'none';
        document.getElementById('settings').style.opacity = '1';
        document.getElementById('settings').style.pointerEvents = 'auto';
        document.getElementById('btnMatch').disabled = true;
        document.getElementById('btnNoMatch').disabled = true;
        document.getElementById('practiceBanner').classList.remove('visible');
        document.getElementById('accuracyStat').classList.remove('practice');
        
        if (!practiceMode) {
            var total = hits + misses + falseAlarms + correctRejections;
            if (total > 0) {
                var finalAcc = Math.round(((hits + correctRejections) / total) * 100);
                showFeedback('Final: ' + finalAcc + '% (' + hits + ' hits, ' + misses + ' misses)', 
                             finalAcc >= 80 ? 'hit' : 'miss');
            }
        }
    }

    // ========================================
    // PRACTICE MODE TOGGLE
    // ========================================
    function togglePracticeMode() {
        practiceMode = !practiceMode;
        var toggle = document.getElementById('practiceToggle');
        if (practiceMode) {
            toggle.classList.add('active');
        } else {
            toggle.classList.remove('active');
        }
    }
    
    // ========================================
    // BREATH SYNC TOGGLE
    // ========================================
    function toggleBreathSync() {
        breathSync = !breathSync;
        var toggle = document.getElementById('breathToggle');
        if (breathSync) {
            toggle.classList.add('active');
        } else {
            toggle.classList.remove('active');
        }
    }

    // ========================================
    // EVENT LISTENERS
    // ========================================
    document.getElementById('btnMatch').onclick = function() { 
        respond(true); 
    };
    
    document.getElementById('btnNoMatch').onclick = function() { 
        respond(false); 
    };
    
    document.getElementById('btnStart').onclick = startGame;
    document.getElementById('btnStop').onclick = stopGame;
    document.getElementById('practiceToggle').onclick = togglePracticeMode;
    document.getElementById('breathToggle').onclick = toggleBreathSync;
    
    // Manual overlay
    document.getElementById('manualBtn').onclick = function() {
        document.getElementById('manualOverlay').classList.add('visible');
    };
    document.getElementById('closeManual').onclick = function() {
        document.getElementById('manualOverlay').classList.remove('visible');
    };

    document.onkeydown = function(e) {
        var key = e.key.toLowerCase();
        if (key === 'm') {
            respond(true);
        } else if (key === 'n') {
            respond(false);
        } else if (key === ' ') {
            e.preventDefault();
            if (running) {
                stopGame();
            } else {
                startGame();
            }
        }
    };
</script>
```

</body>
</html>
