<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Imagi-world</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        h1 {
            margin: 20px 0;
            font-size: 2rem;
            text-align: center;
        }

        .container {
            max-width: 900px;
            width: 100%;
        }

        .controls {
            background: #16213e;
            padding: 25px;
            border-radius: 12px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            font-size: 0.95rem;
        }

        #numTrialsSlider {
            width: 100%;
            margin-top: 8px;
        }

        #numTrialsDisplay {
            display: block;
            margin-top: 8px;
            font-weight: 600;
            color: #e94560;
        }

        .label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            font-size: 0.95rem;
        }

        .hint {
            display: block;
            margin-top: 4px;
            color: #aaa;
            font-size: 0.85rem;
        }

        input[type="range"] {
            width: 100%;
            height: 8px;
            background: #0f3460;
            border-radius: 4px;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #e94560;
            cursor: pointer;
            border-radius: 50%;
        }

        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #e94560;
            cursor: pointer;
            border-radius: 50%;
            border: none;
        }

        input[type="range"]:focus {
            outline: 2px solid #e94560;
            outline-offset: 2px;
        }

        input[type="number"] {
            width: 80px;
            padding: 8px;
            background: #0f3460;
            color: #eee;
            border: 1px solid #1a4d7a;
            border-radius: 6px;
            font-size: 1rem;
            margin-left: 10px;
        }

        input[type="number"]:focus {
            outline: 2px solid #e94560;
            outline-offset: 2px;
        }

        .range-value {
            display: inline-block;
            min-width: 30px;
            text-align: right;
            font-weight: bold;
            color: #e94560;
        }

        .dual-control {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .dual-control input[type="range"] {
            flex: 1;
        }

        button {
            background: #e94560;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            margin-right: 10px;
            margin-bottom: 10px;
        }

        button:hover {
            background: #d63651;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(233, 69, 96, 0.3);
        }

        button:active {
            transform: translateY(0);
        }

        button:focus {
            outline: 2px solid #e94560;
            outline-offset: 2px;
        }

        button:disabled {
            background: #555;
            cursor: not-allowed;
            transform: none;
        }

        #btnInstructions.completed::after {
            content: ' ‚úì';
            font-weight: 700;
            color: #2ecc71;
        }

        button.secondary {
            background: #0f3460;
        }

        button.secondary:hover:not(:disabled) {
            background: #1a4d7a;
        }

        button.danger {
            background: #c0392b;
        }

        button.danger:hover:not(:disabled) {
            background: #a93226;
        }

        button.success {
            background: #27ae60;
        }

        button.success:hover:not(:disabled) {
            background: #229954;
        }

        .game-area {
            background: #16213e;
            padding: 30px;
            border-radius: 12px;
            text-align: center;
            min-height: 300px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }

        .status {
            font-size: 1.5rem;
            margin-bottom: 20px;
            font-weight: 600;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 20px;
            width: 100%;
        }

        .stat-box {
            background: #0f3460;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-label {
            font-size: 0.85rem;
            color: #aaa;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.8rem;
            font-weight: bold;
            color: #e94560;
        }

        .response-buttons {
            display: flex;
            gap: 15px;
            margin-top: 20px;
        }

        .response-buttons button {
            flex: 1;
            padding: 20px;
            font-size: 1.2rem;
        }

        .match-btn {
            background: #2ecc71;
        }

        .match-btn:hover:not(:disabled) {
            background: #27ae60;
        }

        .no-match-btn {
            background: #e74c3c;
        }

        .no-match-btn:hover:not(:disabled) {
            background: #c0392b;
        }

        .feedback {
            margin-top: 15px;
            padding: 15px;
            border-radius: 6px;
            font-weight: 600;
            font-size: 1.1rem;
            min-height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .feedback.correct {
            background: rgba(46, 204, 113, 0.2);
            color: #2ecc71;
        }

        .feedback.incorrect {
            background: rgba(231, 76, 60, 0.2);
            color: #e74c3c;
        }

        #debug {
            background: #0a0e1a;
            padding: 20px;
            border-radius: 8px;
            margin-top: 20px;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            max-height: 400px;
            overflow-y: auto;
        }

        #debug h3 {
            margin-bottom: 15px;
            color: #e94560;
        }

        .debug-premise {
            margin-bottom: 10px;
            padding: 8px;
            background: #16213e;
            border-radius: 4px;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .inline {
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .checkbox-group input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .checkbox-group input[type="checkbox"]:focus {
            outline: 2px solid #e94560;
            outline-offset: 2px;
        }

        .voice-info {
            background: #0f3460;
            padding: 10px;
            border-radius: 6px;
            font-size: 0.9rem;
            color: #aaa;
            margin-top: 10px;
        }

        .voice-info strong {
            color: #e94560;
        }

        .button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .test-panel {
            background: #0a0e1a;
            padding: 20px;
            border-radius: 8px;
            margin-top: 20px;
        }


        .test-result {
            padding: 8px;
            margin: 5px 0;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
        }

        .test-result.pass {
            background: rgba(46, 204, 113, 0.2);
            color: #2ecc71;
        }

        .test-result.fail {
            background: rgba(231, 76, 60, 0.2);
            color: #e74c3c;
        }

        .premise-display {
            font-size: 1.3rem;
            color: #aaa;
            margin: 20px 0;
            min-height: 60px;
            font-style: italic;
        }

        @media (max-width: 600px) {
            .stats {
                grid-template-columns: 1fr 1fr;
            }

            .response-buttons {
                flex-direction: column;
            }
        }

        #dlgInstructions {
            position: fixed;
            inset: 0;
            background: rgba(10, 14, 26, 0.88);
            backdrop-filter: blur(6px);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 40px 20px;
            z-index: 999;
        }

        #dlgInstructions[hidden] {
            display: none;
        }

        #dlgInstructions > header,
        #dlgInstructions > footer,
        #dlgInstructions > nav,
        #dlgInstructions > article {
            width: min(960px, 100%);
        }

        #dlgInstructions > header {
            background: #16213e;
            padding: 20px 60px 20px 24px;
            border-radius: 12px 12px 0 0;
            position: relative;
        }

        #instTitle {
            margin-bottom: 12px;
            font-size: 1.6rem;
        }

        #instClose {
            position: absolute;
            top: 16px;
            right: 16px;
            background: transparent;
            border: none;
            font-size: 1.4rem;
            line-height: 1;
            color: #e94560;
            cursor: pointer;
            padding: 4px 8px;
        }

        #instClose:hover {
            transform: none;
            color: #fff;
            background: transparent;
            box-shadow: none;
        }

        #instTabs {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 8px;
            background: #0f3460;
            padding: 16px;
        }

        #instTabs button {
            background: #16213e;
            border-radius: 6px;
            padding: 10px;
            font-size: 0.95rem;
            border: 1px solid transparent;
        }

        #instTabs button.active {
            background: #e94560;
            border-color: #f08fa2;
        }

        #instTabs button.visited:not(.active) {
            border-color: #27ae60;
        }

        #instContent {
            background: #0a0e1a;
            padding: 24px;
            min-height: 280px;
            max-height: 360px;
            overflow-y: auto;
            outline: none;
        }

        #instContent h3 {
            margin-bottom: 12px;
            font-size: 1.3rem;
        }

        #instContent p {
            margin-bottom: 12px;
            line-height: 1.6;
        }

        #walkthroughN2 .algo li {
            margin: 0.25rem 0;
        }

        #walkthroughN2 .anchors,
        #walkthroughN2 .returns {
            margin-left: 1rem;
        }

        #walkthroughN2 .trials > li {
            margin: 0.5rem 0;
            padding: 0.5rem;
            border: 1px solid var(--border, #444);
            border-radius: 0.5rem;
            background: rgba(22, 33, 62, 0.6);
        }

        #walkthroughN2 .match {
            color: var(--ok, #2ecc71);
            font-weight: 600;
        }

        #walkthroughN2 .nomatch {
            color: var(--warn, #e67e22);
            font-weight: 600;
        }

        #walkthroughN2 .actions {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.75rem;
            flex-wrap: wrap;
        }

        #walkthroughN2 .brandline {
            margin-bottom: 0.5rem;
        }

        #instContent ul,
        #instContent ol {
            margin-left: 20px;
            margin-bottom: 12px;
            line-height: 1.6;
        }

        #examplesFilters {
            margin: .5rem 0 1rem;
            display: flex;
            gap: .5rem;
            align-items: center;
            flex-wrap: wrap;
        }

        #examplesFilters button.active {
            font-weight: 700;
            text-decoration: underline;
        }

        #examplesList > li {
            margin: 0 0 1rem 0;
            padding: .75rem;
            border: 1px solid var(--border, #ddd);
            border-radius: .5rem;
        }

        .exActions {
            display: flex;
            gap: .5rem;
            margin-top: .5rem;
        }

        #instFooter {
            display: flex;
            align-items: center;
            gap: 12px;
            background: #16213e;
            padding: 16px 24px;
            border-radius: 0 0 12px 12px;
        }

        #instFooter .inline {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.95rem;
        }

        #instFooter .spacer {
            flex: 1;
        }

        .inst-brand-tagline {
            font-size: 0.9rem;
            color: #f5c0d1;
            line-height: 1.5;
        }

        body.dialog-open {
            overflow: hidden;
        }

        .sandbox-panel {
            margin-top: 16px;
            padding: 16px;
            background: #111a33;
            border-radius: 8px;
        }

        .sandbox-panel h4 {
            margin-bottom: 8px;
            font-size: 1.1rem;
        }

        .sandbox-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 12px;
        }

        .sandbox-letter-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 10px;
            margin-bottom: 12px;
        }

        .sandbox-letter {
            background: #16213e;
            padding: 10px;
            border-radius: 6px;
        }

        .sandbox-letter label {
            font-size: 0.85rem;
            margin-bottom: 6px;
        }

        .sandbox-letter input[type="text"] {
            width: 100%;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #1a4d7a;
            background: #0f3460;
            color: #fff;
        }

        .sandbox-atom-list {
            margin-bottom: 12px;
            font-family: 'Courier New', monospace;
        }

        .sandbox-journal {
            margin-top: 12px;
            max-height: 140px;
            overflow-y: auto;
            background: #0f0f24;
            padding: 10px;
            border-radius: 6px;
            font-size: 0.85rem;
        }

        .sandbox-journal-entry {
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px dashed rgba(233, 69, 96, 0.4);
        }

        @media (max-width: 780px) {
            #instTabs {
                grid-template-columns: repeat(2, 1fr);
            }

            #instFooter {
                flex-direction: column;
                align-items: stretch;
            }

            #instFooter .spacer {
                display: none;
            }

            .inst-footer-brand {
                max-width: 100%;
            }
        }
    </style>
</head>
<body>
    <main class="container">
        <h1>üåÄImagi-worldüåÄ</h1>

        <div class="controls">
            <div class="control-group">
                <label>N-Back Level: <span class="range-value" id="n-value">1</span></label>
                <input type="range" id="n-slider" min="1" max="5" value="1">
            </div>

            <div class="control-group">
                <label><span id="k-label">Atoms per Premise</span> (k): <span class="range-value" id="k-value">1</span></label>
                <input type="range" id="k-slider" min="1" max="4" value="1">
            </div>

            <div class="control-group">
                <label>Seconds per Trial: <span class="range-value" id="spt-value">8.0</span> s</label>
                <div class="dual-control">
                    <input type="range" id="spt-slider" min="2" max="20" step="0.5" value="8.0">
                    <input type="number" id="spt-number" min="2" max="20" step="0.5" value="8.0">
                </div>
            </div>

            <div class="control-group">
                <label for="numTrialsInput">Number of trials per session</label>
                <input id="numTrialsInput" type="number" min="1" max="10000" step="1" value="20" />
                <input id="numTrialsSlider" type="range" min="1" max="500" step="1" value="20" />
                <span id="numTrialsDisplay">Trials: 20</span>
            </div>

            <div class="control-group checkbox-group">
                <input type="checkbox" id="transitivity-toggle">
                <label for="transitivity-toggle" style="margin-bottom: 0;">Enable Advanced Transitivity</label>
            </div>

            <div class="control-group checkbox-group">
                <input type="checkbox" id="g-leap-toggle">
                <label for="g-leap-toggle" style="margin-bottom: 0;">Force Meta-Relational Trials (Level 6: g-Leap)</label>
            </div>

            <div class="control-group checkbox-group">
                <input type="checkbox" id="compound-leap-toggle">
                <label for="compound-leap-toggle" style="margin-bottom: 0;">Force Compound Operator Trials (Level 7: Maximum g-Load)</label>
            </div>

            <div class="control-group checkbox-group">
                <input type="checkbox" id="octo-leap-toggle">
                <label for="octo-leap-toggle" style="margin-bottom: 0;">Force 8-Direction Compound Operator Trials (Level 8: Octo-Leap)</label>
            </div>

            <div class="control-group checkbox-group">
                <input type="checkbox" id="hexa-leap-toggle">
                <label for="hexa-leap-toggle" style="margin-bottom: 0;">Force 16-Direction Triple-Compound Operator Trials (Level 9: Hexa-Leap)</label>
            </div>

            <div class="control-group checkbox-group">
                <input type="checkbox" id="lock-seed-toggle">
                <label for="lock-seed-toggle" style="margin-bottom: 0;">Lock seed (reuse until unlocked)</label>
            </div>

            <div class="control-group checkbox-group">
                <input type="checkbox" id="reset-seed-toggle">
                <label for="reset-seed-toggle" style="margin-bottom: 0;">Reset stats & logs on Restart</label>
            </div>

            <div class="control-group checkbox-group">
                <input type="checkbox" id="debug-toggle">
                <label for="debug-toggle" style="margin-bottom: 0;">Show Debug Panel</label>
            </div>

            <div class="control-group">
                <label class="inline" title="Let the session play without responses">
                    <input id="listenOnlyToggle" type="checkbox" />
                    Listen-Only (Auto-Advance)
                </label>
                <small id="listenOnlyHint" aria-live="polite" hidden>
                    Listening mode: scoring disabled; session will auto-advance to completion.
                </small>
            </div>

            <div style="margin-top: 20px;">
                <div class="button-group">
                    <button id="start-btn" class="success">Start</button>
                    <button id="restart-btn" class="success" disabled>Restart</button>
                    <button id="stop-btn" class="danger" disabled>Stop</button>
                    <button id="repeat-btn" class="secondary" disabled>Repeat Audio</button>
                    <button id="preview-btn" class="secondary">Voice Preview</button>
                    <button id="reset-voice-btn" class="secondary">Reset Voice</button>
                    <button id="btnInstructions" aria-haspopup="dialog" aria-controls="dlgInstructions">Instructions</button>
                    <button id="btnLevel8Instructions" class="secondary" style="background: #e94560; color: white;">Level 8 Instructions</button>
                    <button id="btnLevel9Instructions" class="secondary" style="background: #8b00ff; color: white;">Level 9 Instructions</button>
                    <button id="btnDaVinciInstructions" class="secondary" style="background: #ffa500; color: white;">Da Vinci does Imagi-World</button>
                </div>
                <div class="button-group">
                    <button id="test-btn" class="secondary">Run Tests</button>
                    <button id="export-btn" class="secondary">Download so far</button>
                </div>
            </div>

            <div class="voice-info" id="voice-info">Initializing voice...</div>
        </div>

        <div class="game-area">
            <div class="status" id="status">Preparing voice system...</div>
            <div class="premise-display" id="premise-display"></div>

            <div class="response-buttons">
                <button class="match-btn" id="match-btn" disabled>
                    MATCH<br><small>(Spacebar)</small>
                </button>
                <button class="no-match-btn" id="no-match-btn" disabled>
                    NO MATCH<br><small>(Enter)</small>
                </button>
            </div>

            <div class="feedback" id="feedback"></div>

            <div class="stats">
                <div class="stat-box">
                    <div class="stat-label">Trial</div>
                    <div class="stat-value" id="trial-count">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Score</div>
                    <div class="stat-value" id="score">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Accuracy</div>
                    <div class="stat-value" id="accuracy">-</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Rolling Acc.</div>
                    <div class="stat-value" id="rolling-acc">-</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Omissions</div>
                    <div class="stat-value" id="omissions">0</div>
                </div>
            </div>
        </div>


        <div id="debug" hidden>
            <h3>Debug Panel - Last Premises</h3>
            <div id="debug-content"></div>
        </div>

        <div id="test-panel" class="test-panel" hidden>
            <h3>Test Results</h3>
            <div id="test-results"></div>
        </div>
    </main>

    <section id="dlgInstructions" role="dialog" aria-modal="true" aria-labelledby="instTitle" hidden>
        <header>
            <h2 id="instTitle">Imagi-World: Learn the Arc of Abstraction</h2>
            <p class="inst-brand-tagline"><strong>Imagi-World</strong> trains maximized imagination across the <strong>Arc of Abstraction</strong>. At its intersection with your lived experience lies the engine of creation, recognition, and extension of thought‚Äîyour route to deeper consciousness.</p>
            <button id="instClose" aria-label="Close">‚úï</button>
        </header>

        <nav id="instTabs" aria-label="Tutorial Sections">
            <button data-tab="welcome" class="active">Welcome</button>
            <button data-tab="compass">Imagi-Compass</button>
            <button data-tab="anchor">Anchor &amp; Transform</button>
            <button data-tab="examples">Guided Examples</button>
            <button data-tab="practice">Sandbox Practice</button>
            <button data-tab="mastery">Mastery Path</button>
            <button data-tab="level6">Level 6: g-Leap</button>
            <button data-tab="level7">Level 7: Ultimate</button>
            <button data-tab="level8">Level 8: Octo-Leap</button>
            <button data-tab="level9">Level 9: Hexa-Leap</button>
            <button data-tab="level8-instructions">Level 8 Instructions</button>
            <button data-tab="level9-instructions">Level 9 Instructions</button>
            <button data-tab="davinci-method">Da Vinci does Imagi-World</button>
            <button data-tab="pitfalls">Pitfalls &amp; FAQ</button>
            <button data-tab="glossary">Glossary</button>
        </nav>

        <article id="instContent" tabindex="0" aria-live="polite"></article>

        <footer id="instFooter">
            <label class="inline">
                <input id="instReadAloud" type="checkbox" />
                Read this section aloud
            </label>
            <div class="spacer"></div>
            <button id="instPrev">‚Üê Previous</button>
            <button id="instNext">Next ‚Üí</button>
        </footer>
    </section>

    <script type="module">
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // FORENSIC DEBUG MODE - LEVEL 6 TRACING
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        console.log('IMAGI-WORLD LEVEL 6 DEBUG VERSION LOADED');
        console.log('File loaded at:', new Date().toISOString());
        console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

        const RELATION_WORDS = { N: 'north of', NE: 'northeast of', E: 'east of', SE: 'southeast of', S: 'south of', SW: 'southwest of', W: 'west of', NW: 'northwest of' };
        const MATCH_AXES = ['N', 'S', 'E', 'W'];

        // Level 6: Direction words as spatial letters
        const DIRECTION_LETTERS = ['North', 'South', 'East', 'West'];

        // Level 8: 8-Direction Meta-Compound Operators
        const LEVEL8_OPERATORS = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'];
        const DIAGONAL_OPERATORS = ['NE', 'SE', 'SW', 'NW'];

        // Level 9: 16-Direction Meta-Compound Operators (Hexa-Leap)
        const LEVEL9_OPERATORS = ['N', 'NNE', 'NE', 'ENE', 'E', 'ESE', 'SE', 'SSE', 'S', 'SSW', 'SW', 'WSW', 'W', 'WNW', 'NW', 'NNW'];

        // Voice synthesis support for 16-direction operators
        const RELATION_WORDS_16D = {
            'N': 'north', 'NNE': 'north-northeast', 'NE': 'northeast', 'ENE': 'east-northeast',
            'E': 'east', 'ESE': 'east-southeast', 'SE': 'southeast', 'SSE': 'south-southeast',
            'S': 'south', 'SSW': 'south-southwest', 'SW': 'southwest', 'WSW': 'west-southwest',
            'W': 'west', 'WNW': 'west-northwest', 'NW': 'northwest', 'NNW': 'north-northwest'
        };

        const ACCEPTANCE_ALPHA = 0.25;
        const ACCEPTANCE_BETA = 0.5;
        const FIRST_N_NOVELTY = 6;
        const HAMMING_WINDOW = 8;
        const NOVELTY_OVERRIDE_THRESHOLD = 30;
        const MAX_GENERATION_ATTEMPTS = 240;
        const conflictConfig = {
            foilRate: 0.35,
            foilTypesWeights: {
                ANCHOR_ONE: 0.20,
                PAIR_SWAP: 0.20,
                PARITY_OFF: 0.15,
                AXIS_ORTHO: 0.15,
                DERIVED_IN_ONE: 0.15,
                WINDOW_SHADOW: 0.15
            }
        };

        const NUM_TRIALS_KEY = 'numTrials';
        const LISTEN_ONLY_KEY = 'listenOnly';
        const numTrialsInput = document.getElementById('numTrialsInput');
        const numTrialsSlider = document.getElementById('numTrialsSlider');
        const numTrialsDisplay = document.getElementById('numTrialsDisplay');
        const listenOnlyToggle = document.getElementById('listenOnlyToggle');
        const listenOnlyHint = document.getElementById('listenOnlyHint');

        function loadListenOnly() {
            try {
                return localStorage.getItem(LISTEN_ONLY_KEY) === '1';
            } catch (err) {
                console.warn('Failed to load listen-only preference', err);
                return false;
            }
        }

        function persistListenOnly(on) {
            try {
                localStorage.setItem(LISTEN_ONLY_KEY, on ? '1' : '0');
            } catch (err) {
                console.warn('Failed to persist listen-only preference', err);
            }
            if (listenOnlyHint) {
                listenOnlyHint.hidden = !on;
            }
        }

        if (listenOnlyToggle) {
            const initListenOnly = loadListenOnly();
            listenOnlyToggle.checked = initListenOnly;
            persistListenOnly(initListenOnly);
            listenOnlyToggle.addEventListener('change', () => {
                persistListenOnly(listenOnlyToggle.checked);
            });
        }

        const TUTORIAL_SECTIONS = [
            {
                id: 'welcome',
                title: 'Welcome to Imagi-World',
                html: `
                    <h3>Welcome to Imagi-World</h3>
                    <p><strong>Imagi-World</strong> trains maximized imagination across the <strong>Arc of Abstraction</strong>. At its intersection with your lived experience lies the engine of creation, recognition, and extension of thought‚Äîyour route to deeper consciousness.</p>
                    <p>Imagi-World is imagination with a steering wheel. You will learn to project your lived thoughts onto letters and then move them along the <strong>Arc of Abstraction</strong> using the <strong>Imagi-Compass</strong>. North means <strong>up-shift</strong> to higher-order concepts, South means <strong>down-shift</strong> to concrete instances, East means <strong>analogue</strong> (same role/sibling concept), West means <strong>opposite</strong> (counterpart/foil).</p>
                    <p>The spatial logic remains strict; your analogies ride on top. This union‚Äîformal clarity plus creative projection‚Äîis our brand and our method.</p>
                    <p><strong>Outcome:</strong> by the end, you will anchor any symbol to a vivid mental seed and transform it consistently through multiple relational steps, even under time pressure.</p>
                `,
                speech: 'Welcome to Imagi-World. Imagi-World trains maximized imagination across the Arc of Abstraction. At its intersection with your lived experience lies the engine of creation, recognition, and extension of thought‚Äîyour route to deeper consciousness. Imagi-World is imagination with a steering wheel. You will learn to project your lived thoughts onto letters and then move them along the Arc of Abstraction using the Imagi-Compass. North means up-shift to higher-order concepts. South means down-shift to concrete instances. East means analogue, the same role or a sibling concept. West means opposite, the counterpart or foil. The spatial logic remains strict, and your analogies ride on top. This union, formal clarity plus creative projection, is our brand and our method. Outcome: by the end, you will anchor any symbol to a vivid mental seed and transform it consistently through multiple relational steps, even under time pressure.'
            },
            {
                id: 'compass',
                title: 'The Imagi-Compass',
                html: `
                    <h3>The Imagi-Compass</h3>
                    <ul>
                        <li><strong>North (‚Üë Up-shift):</strong> move to meta, greater scale, more general, more intense. "Candle ‚Üí Fireworks"; "Task ‚Üí Project ‚Üí Program."</li>
                        <li><strong>South (‚Üì Down-shift):</strong> move to instance, component, concrete, less intense. "Theory ‚Üí Example"; "System ‚Üí Tool ‚Üí Part."</li>
                        <li><strong>East (‚Üí Analogue):</strong> parallel function or sibling concept. "Candle ‚Üí Lantern"; "Fact ‚Üí Case study"; "Parent ‚Üí Guardian."</li>
                        <li><strong>West (‚Üê Opposite):</strong> antonym/counter-role. "Fact ‚Üî Fiction"; "Order ‚Üî Chaos"; "Light ‚Üî Darkness."</li>
                    </ul>
                    <p><strong>Rule:</strong> your analogical mapping must be <strong>self-consistent</strong> within a session. Reframes are allowed but must be acknowledged.</p>
                `,
                speech: 'The Imagi-Compass. North, the up-shift, moves to meta, to greater scale, to more general or more intense territory. Candle to fireworks. Task to project to program. South, the down-shift, moves to instance, to component, to concrete or less intense forms. Theory to example. System to tool to part. East, the analogue, is the parallel function or sibling concept. Candle to lantern. Fact to case study. Parent to guardian. West, the opposite, is the antonym or counter-role. Fact to fiction. Order to chaos. Light to darkness. Rule: your analogical mapping must be self-consistent within a session. Reframes are allowed but must be acknowledged.'
            },
            {
                id: 'anchor',
                title: 'Step-by-Step: Anchor & Transform',
                html: `
                    <h3>Step-by-Step: Anchor &amp; Transform</h3>
                    <ol>
                        <li><strong>Anchor</strong> one letter from the current premise to a real concept from your stream of consciousness (write it or think it). Example: <code>X := "Fact"</code>.</li>
                        <li><strong>Transform</strong> per atom:
                            <ul>
                                <li><code>Y is north of X</code> ‚Üí <code>Y := Up-shift(X)</code> ‚Üí "Theory".</li>
                                <li><code>Z is west of X</code> ‚Üí <code>Z := Opposite(X)</code> ‚Üí "Fiction".</li>
                                <li><code>R is south of Y</code> ‚Üí <code>R := Down-shift(Y)</code> ‚Üí "Example".</li>
                                <li><code>H is east of R</code> ‚Üí <code>H := Analogue(R)</code> ‚Üí "Case study".</li>
                            </ul>
                        </li>
                        <li><strong>Check coherence</strong>: does each transformed concept match its relational cue? If yes, commit this mapping to your session notes.</li>
                        <li><strong>Never bleed analogies into scoring</strong>: logic is graded by the formal engine; analogies are your training mirror.</li>
                    </ol>
                    <p><strong>Mantra:</strong> <strong>Anchor ‚Üí Transform ‚Üí Cohere ‚Üí Commit.</strong></p>
                `,
                speech: 'Step-by-Step: Anchor and Transform. One: Anchor one letter from the current premise to a real concept from your stream of consciousness, write it or think it. Example: X equals Fact. Two: Transform per atom. Y is north of X, so Y equals the up-shift of X, Theory. Z is west of X, so Z equals the opposite of X, Fiction. R is south of Y, so R equals the down-shift of Y, Example. H is east of R, so H equals the analogue of R, Case study. Three: Check coherence. Does each transformed concept match its relational cue? If yes, commit this mapping to your session notes. Four: Never bleed analogies into scoring. Logic is graded by the formal engine; analogies are your training mirror. Mantra: Anchor, Transform, Cohere, Commit.'
            },
            {
                id: 'examples',
                title: 'Guided Examples',
                html: `
                    <h3>Guided Examples</h3>
                    <p>The worked library loads in a moment. Use it to study beginner-friendly mappings across every compass move.</p>
                `,
                speech: 'Guided Examples. Explore the library of thirty worked analogies. Use the filter buttons to focus on single atoms, dual heads, chains, or full quartets. Each entry shows the premise, anchors, compass moves, the resulting mapping, and a quick rationale. Tap Speak summary to hear one in the same training voice.'
            },
            {
                id: 'practice',
                title: 'Sandbox Practice (Not Scored)',
                html: `
                    <h3>Sandbox Practice (Not Scored)</h3>
                    <ul>
                        <li>This is a safe studio. Load the <strong>latest premise</strong> (button "Load current premise"), or spawn a <strong>fresh training premise</strong> (button "Spawn practice premise").</li>
                        <li>Enter concepts for the letters; click <strong>Apply Relation Operations</strong> to auto-suggest analogues/opposites/up/down (you may override).</li>
                        <li>Use <strong>Commit to Journal</strong> to save your mapping snapshots (they do not affect your game score).</li>
                        <li>Toggle <strong>Read this section aloud</strong> for gentle narration using the same single voice the game uses.</li>
                    </ul>
                    <p><strong>Tip:</strong> strive for <strong>one-sentence explanations</strong> that justify your choices: "I chose <em>Theory</em> above <em>Fact</em> because it generalizes observations into predictive structure."</p>
                `,
                speech: 'Sandbox Practice, not scored. This is a safe studio. Load the latest premise with the button Load current premise, or spawn a fresh training premise with the button Spawn practice premise. Enter concepts for the letters; click Apply Relation Operations to auto-suggest analogues, opposites, up, or down shifts. You may override anything. Use Commit to Journal to save your mapping snapshots. They do not affect your game score. Toggle Read this section aloud for gentle narration using the same single voice the game uses. Tip: strive for one-sentence explanations that justify your choices, such as, I chose Theory above Fact because it generalizes observations into predictive structure.'
            },
            {
                id: 'mastery',
                title: 'Mastery: From Symbols to Schemas',
                html: `
                    <h3>Mastery: From Symbols to Schemas</h3>
                    <ul>
                        <li><strong>Level 1 ‚Äî Single-atom fluency:</strong> 95% accuracy in naming valid up/down/analogue/opposite for any anchor within 3 seconds.</li>
                        <li><strong>Level 2 ‚Äî Two-atom coordination:</strong> keep consistency when a letter appears in two relations; reconcile tensions by compound mappings ("chaotic example").</li>
                        <li><strong>Level 3 ‚Äî Chain reasoning:</strong> three or more atoms spanning two axes; maintain semantic integrity across the chain.</li>
                        <li><strong>Level 4 ‚Äî Near-miss foils:</strong> detect when premises <strong>look</strong> similar but fail one criterion (anchoring parity, mapping, axis alignment, derivability). Explain <strong>why</strong> they're not matches in plain language.</li>
                        <li><strong>Level 5 ‚Äî Transfer:</strong> take a mapping that worked in one theme ("Learning &amp; Illumination") and remake it in a different theme ("Teams &amp; Leadership"), preserving relational roles: <code>Fact‚ÜíNovice Task</code>, <code>Theory‚ÜíBest Practice</code>, <code>Example‚ÜíCase Review</code>, <code>Case study‚ÜíPlaybook</code>, <code>Fiction‚ÜíMyth/Misconception</code>.</li>
                        <li><strong>Level 6 ‚Äî Meta-Relational Analogy (The 'g' Leap):</strong> This is the most advanced task, designed for peak fluid intelligence. You will see a new premise type: <code>"North to South as East to West."</code> This is a pure analogy of relations. The game engine is testing if the <em>relationship</em> between the first pair is the same as the <em>relationship</em> between the second pair. <br><strong>Your Task:</strong> Determine if the premise is True or False. An N-back match occurs if the N-back premise has the <em>same truth value</em> (i.e., True matches True, and False matches False). <br><strong>Example:</strong> <code>North to South as East to West</code> <br><strong>Deduction 1 (5th-Order):</strong> The relation <code>(North to South)</code> is <code>Up-shift</code> ‚Üí <code>Down-shift</code>. These are opposites. The hidden operator is <strong>West</strong>. <br><strong>Deduction 2 (5th-Order):</strong> The relation <code>(East to West)</code> is <code>Analogue</code> ‚Üí <code>Opposite</code>. These are also opposites. The hidden operator is <strong>West</strong>. <br><strong>Result:</strong> <code>West</code> equals <code>West</code>. The premise is <strong>True</strong>. <br><strong>Example 2:</strong> <code>North to East as South to West</code> <br><strong>Deduction 1:</strong> <code>(North to East)</code> is <code>Up-shift</code> ‚Üí <code>Analogue</code>. These are orthogonal. The relation is <strong>None</strong>. <br><strong>Deduction 2:</strong> <code>(South to West)</code> is <code>Down-shift</code> ‚Üí <code>Opposite</code>. These are also orthogonal. The relation is <strong>None</strong>. <br><strong>Result:</strong> <code>None</code> equals <code>None</code>. The premise is <strong>True</strong>. <br><strong>Example 3:</strong> <code>North to South as North to East</code> <br><strong>Result:</strong> <code>West</code> does not equal <code>None</code>. The premise is <strong>False</strong>.</li>
                        <li><strong>Level 7 ‚Äî Compound Operator Relational (Maximum g-Load):</strong> The ultimate challenge: premises like <code>"north-west is north of south-east"</code> where compound operators (2-operator sequences) are related by meta-operators. You mentally anchor concepts and apply sequential transformations (Order‚ÜíSystem‚ÜíChaos). Combines all cognitive demands: sequential transformation, semantic anchoring, meta-reasoning, working memory, and n-back recall. Mutually exclusive with Level 6.</li>
                        <li><strong>Level 8 ‚Äî 8-Direction Meta-Compound Operators (Octo-Leap):</strong> Beyond maximum: extends to 8 directions (N, NE, E, SE, S, SW, W, NW), creating 56 possible compounds. YOU must invent meanings for diagonal operators (NE, SE, SW, NW) and maintain coherence across trials. Example: <code>"northeast-southwest is north of southeast-northwest"</code>. Requires generative semantics, 8-way spatial reasoning, diagonal abstraction, and all Level 7 demands. Mutually exclusive with Levels 6 and 7. <strong>Start with low n and k</strong>‚Äîthis is cognitively demanding beyond measure.</li>
                        <li><strong>Advanced Strategy ‚Äî Semantic Anchoring (Mental Technique):</strong> This is <strong>not a separate game mode</strong>‚Äîit's a powerful mental strategy you can apply to any level. Instead of manipulating abstract letters, you <strong>mentally anchor them to concrete concepts</strong> from your lived experience. <br><strong>How It Works (Purely Mental):</strong> (1) System shows: <code>N is north of J</code>. (2) You mentally anchor: J := "Fact". (3) You mentally transform: North(J‚ÜíN) = up-shift "Fact" ‚Üí "Theory". (4) You mentally map: N := "Theory". (5) In your head, the premise becomes "Theory is the higher abstraction of Fact". <br><strong>The Key:</strong> The system <strong>never sees</strong> your semantic anchors. They exist purely in your working memory. <br><strong>Applying to Levels 6-8:</strong> You can anchor META premises and compound operators mentally. For Level 8, you must also define your own diagonal operator meanings. This maximizes g-load because YOUR imagination creates the entire semantic layer.</li>
                    </ul>
                    <p><strong>Mastery litmus:</strong> you can improvise <strong>new, coherent mappings</strong> at speed, across themes, while the logic engine remains satisfied‚Äîno contradictions, no shortcuts. At Level 8, you can maintain a consistent 8-direction model purely in working memory.</p>
                `,
                speech: 'Mastery: From Symbols to Schemas. Level one, single-atom fluency: ninety-five percent accuracy in naming valid up, down, analogue, or opposite moves for any anchor within three seconds. Level two, two-atom coordination: keep consistency when a letter appears in two relations; reconcile tensions by compound mappings such as Chaotic example. Level three, chain reasoning: three or more atoms spanning two axes; maintain semantic integrity across the chain. Level four, near-miss foils: detect when premises look similar but fail one criterion‚Äîanchoring parity, mapping, axis alignment, derivability. Explain why they are not matches in plain language. Level five, transfer: take a mapping that worked in one theme, Learning and Illumination, and remake it in a different theme, Teams and Leadership, preserving relational roles: Fact to Novice Task, Theory to Best Practice, Example to Case Review, Case study to Playbook, Fiction to Myth or Misconception. Level six, Meta-Relational Analogy, the g-Leap: This is peak fluid intelligence. You will see pure operator analogies like North to South as East to West. Your task: determine if the premise is true or false by deducing the hidden operator. Example: North to South is Up-shift to Down-shift, which are opposites, so the hidden operator is West. East to West is Analogue to Opposite, also opposites, so the hidden operator is West. West equals West, the premise is True. An n-back match occurs when both premises have the same truth value. Level seven, Generative Semantic Anchoring, the Ultimate g-Leap: This is the highest cognitive challenge. When you see a Level six premise, you will be prompted to generate your own semantic pairs from imagination. The system shows North to South as East to West. You input: What does North to South mean to you? You type Teacher to Student. You input: What does East to West mean to you? You type Day to Night. The system validates your pairs, stores them with the premise, and you must recall YOUR anchors across n-back trials. This maximizes g-load through generative creation, working memory for self-generated concepts, dual representation of operators plus personal semantics, validation of your semantics, and n-back matching while recalling your anchors. This is the highest g-load task because your imagination creates the semantic layer. Mastery litmus: you can improvise new, coherent mappings at speed, across themes, while the logic engine remains satisfied‚Äîno contradictions, no shortcuts.'
            },
            {
                id: 'pitfalls',
                title: 'Pitfalls & FAQ',
                html: `
                    <h3>Pitfalls &amp; FAQ</h3>
                    <dl>
                        <dt><strong>Q:</strong> Can I use the same word for East (analogue)?</dt>
                        <dd><strong>A:</strong> Prefer <strong>siblings</strong>, not duplicates. "Candle ‚Üí Lantern," not "Candle ‚Üí Candle."</dd>
                        <dt><strong>Q:</strong> My West choice feels too cartoonish.</dt>
                        <dd><strong>A:</strong> "Opposite" includes <strong>counter-role</strong> or <strong>antagonist</strong>, not just antonym. "Order ‚Üî Chaos," "Plan ‚Üî Improvisation."</dd>
                        <dt><strong>Q:</strong> What if my mapping breaks later?</dt>
                        <dd><strong>A:</strong> Use a <strong>Reframe</strong> action. Log it. Consistency matters more than stubbornness.</dd>
                        <dt><strong>Q:</strong> Do analogies change scoring?</dt>
                        <dd><strong>A:</strong> No. Scoring is formal. Analogies train your <strong>semantic agility</strong>.</dd>
                        <dt><strong>Q (Level 6):</strong> How do I know if a META premise is True or False?</dt>
                        <dd><strong>A:</strong> Deduce the hidden operator for each pair. Example: "North to South" = Up-shift‚ÜíDown-shift = <strong>Opposite (West)</strong>. "East to West" = Analogue‚ÜíOpposite = <strong>Opposite (West)</strong>. West = West ‚Üí <strong>True</strong>. If operators differ, it's False. If both are orthogonal (no relationship), it's True.</dd>
                        <dt><strong>Q (Level 6):</strong> What's an "orthogonal" relationship?</dt>
                        <dd><strong>A:</strong> No clear relationship exists. Example: North‚ÜíEast (Up-shift‚ÜíAnalogue) has no operator because they're perpendicular concepts. If <strong>both</strong> pairs are orthogonal, the premise is True (None = None).</dd>
                        <dt><strong>Q (Level 6):</strong> How does n-back matching work for META premises?</dt>
                        <dd><strong>A:</strong> Match on <strong>truth value</strong>, not operators. If n-back premise was True and current premise is True ‚Üí MATCH. If n-back was False and current is False ‚Üí MATCH. Different truth values ‚Üí NO MATCH.</dd>
                        <dt><strong>Q (Semantic Anchoring):</strong> What if I can't think of a good semantic anchor?</dt>
                        <dd><strong>A:</strong> Use the directional concept as a guide. For North (Up-shift), think: mature‚Üíimmature, complex‚Üísimple, whole‚Üípart. For South (Down-shift), reverse it. For East (Analogue), think: siblings, parallel roles, same category. For West (Opposite), think: antonyms, counter-roles, complementary pairs.</dd>
                        <dt><strong>Q (Semantic Anchoring):</strong> Does it matter what semantic anchors I choose?</dt>
                        <dd><strong>A:</strong> Not to the system‚Äîit never sees them! Choose anchors that are <strong>vivid and memorable to YOU</strong>. The cognitive load comes from generating AND remembering YOUR specific mental anchors across n-back trials.</dd>
                        <dt><strong>Q (Semantic Anchoring):</strong> Should I use the same anchors throughout a session?</dt>
                        <dd><strong>A:</strong> It helps! If J := "Fact" in trial 1, keeping it as "Fact" throughout makes recall easier. But you can also challenge yourself by creating fresh anchors each trial.</dd>
                        <dt><strong>Q (Semantic Anchoring):</strong> Can I write down my semantic anchors?</dt>
                        <dd><strong>A:</strong> You can, but that defeats the purpose! The cognitive training comes from maintaining these anchors <strong>in working memory only</strong>. Writing them down is like using a calculator instead of doing mental math.</dd>
                        <dt><strong>Q (Level 8):</strong> What do the diagonal directions mean?</dt>
                        <dd><strong>A:</strong> <strong>YOU decide!</strong> That's the entire point of Level 8. The diagonals (NE, SE, SW, NW) are open for your interpretation. A common approach: use compositional logic. NE = N+E = "up-shift an analogue" = "abstract sibling". SE = S+E = "down-shift an analogue" = "concrete parallel". SW = S+W = "down-shift an opposite" = "concrete antithesis". NW = N+W = "up-shift an opposite" = "abstract negation". But YOUR system is what matters‚Äîjust be consistent!</dd>
                        <dt><strong>Q (Level 8):</strong> Should I write down my diagonal interpretations?</dt>
                        <dd><strong>A:</strong> <strong>Initially, yes!</strong> For your first few Level 8 sessions, keep a written reference of your diagonal meanings. Once you've internalized your 8-direction model (after 5-10 sessions), challenge yourself to maintain it purely in working memory. That's when the maximum cognitive benefit occurs.</dd>
                        <dt><strong>Q (Level 8):</strong> Can I change my diagonal interpretations between sessions?</dt>
                        <dd><strong>A:</strong> You can, but it's not recommended. Consistency helps you build fluency. Pick a system that makes sense to you and stick with it across sessions. Think of it like learning a language‚Äîchanging the vocabulary every day makes mastery impossible.</dd>
                        <dt><strong>Q (Level 8):</strong> How is Level 8 different from Level 7?</dt>
                        <dd><strong>A:</strong> Level 7 uses 4-direction compound operators (12 possible compounds). Level 8 uses 8-direction compound operators (56 possible compounds) with diagonal directions that YOU must define. Level 8 adds: generative semantics (inventing diagonal meanings), 8-way spatial reasoning, combinatorial explosion (4.7√ó more compounds), and diagonal abstraction (combining two axes). It's Level 7 on steroids.</dd>
                        <dt><strong>Q (Level 8):</strong> What if my diagonal interpretations create contradictions?</dt>
                        <dd><strong>A:</strong> That's a sign your system needs refinement! A good 8-direction model should be internally consistent. If NE = "abstract sibling" and you apply it twice, the result should feel coherent. Test your system before committing to it. Try applying each diagonal 2-3 times in a chain‚Äîdoes it still make sense?</dd>
                    </dl>
                `,
                speech: 'Pitfalls and FAQ. Question: Can I use the same word for East, the analogue? Answer: Prefer siblings, not duplicates. Candle to Lantern, not Candle to Candle. Question: My West choice feels too cartoonish. Answer: Opposite includes counter-role or antagonist, not just antonym. Order to Chaos. Plan to Improvisation. Question: What if my mapping breaks later? Answer: Use a Reframe action. Log it. Consistency matters more than stubbornness. Question: Do analogies change scoring? Answer: No. Scoring is formal. Analogies train your semantic agility. Question, Level six: How do I know if a META premise is true or false? Answer: Deduce the hidden operator for each pair. Example: North to South equals Up-shift to Down-shift equals Opposite, West. East to West equals Analogue to Opposite equals Opposite, West. West equals West, so True. If operators differ, it is False. If both are orthogonal, no relationship, it is True. Question, Level six: What is an orthogonal relationship? Answer: No clear relationship exists. Example: North to East, Up-shift to Analogue, has no operator because they are perpendicular concepts. If both pairs are orthogonal, the premise is True, None equals None. Question, Level six: How does n-back matching work for META premises? Answer: Match on truth value, not operators. If n-back premise was True and current premise is True, MATCH. If n-back was False and current is False, MATCH. Different truth values, NO MATCH. Question, Level seven: What if I cannot think of a semantic pair? Answer: Use the concept hint shown in the modal. For North, Up-shift, think mature to immature, complex to simple. For South, reverse it. For East, think siblings, parallel roles. For West, think antonyms, counter-roles. Question, Level seven: Does it matter what semantic pairs I choose? Answer: Yes! They must match the operator concept. The system validates this. But within valid pairs, your choice is what matters. The cognitive load comes from generating and remembering your specific choices across n-back trials. Question, Level seven: Do I have to remember my semantic pairs from previous trials? Answer: Yes! That is the entire point. When evaluating n-back matches, you should recall what you anchored n trials ago. This generative working memory demand is what creates maximum g-load. Question, Level seven: Can I write down my semantic pairs? Answer: The system displays them with each premise, so you will see them. But for maximum training effect, try to recall them from memory first, then verify with the display.'
            },
            {
                id: 'glossary',
                title: 'Glossary',
                html: `
                    <h3>Glossary</h3>
                    <ul>
                        <li><strong>Arc of Abstraction:</strong> the mental continuum from concrete/particular to abstract/general.</li>
                        <li><strong>Up-shift / Down-shift:</strong> moves along the Arc (North/South).</li>
                        <li><strong>Analogue / Opposite:</strong> lateral moves preserving or inverting role (East/West).</li>
                        <li><strong>Anchor:</strong> your chosen seed concept for a letter.</li>
                        <li><strong>Compound mapping:</strong> a single letter carrying a composed phrase to satisfy multiple relations (e.g., "chaotic example").</li>
                        <li><strong>Reframe:</strong> deliberate change to an anchored concept, logged for consistency tracking.</li>
                        <li><strong>Direction-word spatial reasoning (Level 6):</strong> using the four compass directions (North, South, East, West) as spatial letters in relational premises. Example: "West is north of East, East is west of South". Requires SAT-based constraint solving and standard atomic equivalence matching.</li>
                        <li><strong>Direction letters:</strong> the four compass direction names used as letters in Level 6 premises. Unlike regular letters (A-Z), direction words form a separate pool and never mix with alphabetic letters.</li>
                        <li><strong>Constraint graph:</strong> the spatial dependency network formed by middle-window atoms establishing positional relationships. Level 6 requires building and validating constraint graphs using direction words as nodes.</li>
                        <li><strong>SAT solving (Level 6):</strong> Satisfiability solving to verify that a premise is spatially consistent with existing constraints. Direction-word premises must pass SAT validation to be accepted as valid.</li>
                        <li><strong>Semantic anchoring:</strong> a mental strategy where you anchor abstract letters to concrete concepts from your lived experience, then apply directional transformations. Example: J := "Fact", North(J‚ÜíN) = "Fact"‚Üí"Theory".</li>
                        <li><strong>Arc of Abstraction:</strong> the spectrum from concrete lived experience to abstract concepts. Semantic anchoring uses this arc to make abstract premises meaningful.</li>
                        <li><strong>Mental transformation:</strong> applying directional operators to your semantic anchors in your head. Example: South("Theory") = down-shift ‚Üí "Example".</li>
                        <li><strong>Compound operator (Level 7):</strong> a 2-operator sequence from 4 directions (N, S, E, W), creating 12 possible compounds (e.g., "north-west", "south-east"). Used in premises like "north-west is north of south-east".</li>
                        <li><strong>8-direction compound operator (Level 8):</strong> a 2-operator sequence from 8 directions (N, NE, E, SE, S, SW, W, NW), creating 56 possible compounds (e.g., "northeast-southwest", "southeast-northwest").</li>
                        <li><strong>Diagonal operators (Level 8):</strong> the four diagonal directions (NE, SE, SW, NW) that combine cardinal axes. Their meanings are generatively defined by the player. Example: NE = "up-shift + analogue" = "abstract sibling".</li>
                        <li><strong>Generative semantics (Level 8):</strong> the process of inventing and maintaining consistent meanings for diagonal operators. Unlike cardinal directions with fixed meanings, diagonals require creative interpretation.</li>
                        <li><strong>Compositional logic (Level 8):</strong> defining diagonal operators by combining their component cardinal directions. Example: NE = N+E = "generalize an analogue" = "abstract sibling".</li>
                        <li><strong>8-way spatial reasoning (Level 8):</strong> maintaining a coherent mental model of 8 directional operators and their compound sequences. Requires significantly higher working memory than 4-way reasoning.</li>
                        <li><strong>Octo-Leap (Level 8):</strong> shorthand for "8-Direction Meta-Compound Operators", the highest difficulty level requiring generative semantics, 8-way spatial reasoning, and all previous level demands.</li>
                    </ul>
                `,
                speech: 'Glossary. Arc of Abstraction: the mental continuum from concrete or particular to abstract or general. Up-shift and Down-shift: moves along the arc, north and south. Analogue and Opposite: lateral moves preserving or inverting role, east and west. Anchor: your chosen seed concept for a letter. Compound mapping: a single letter carrying a composed phrase to satisfy multiple relations, for example Chaotic example. Reframe: deliberate change to an anchored concept, logged for consistency tracking. Direction-word spatial reasoning, Level six: using the four compass directions, North, South, East, West, as spatial letters in relational premises. Example: West is north of East, East is west of South. Requires SAT-based constraint solving and standard atomic equivalence matching. Direction letters: the four compass direction names used as letters in Level six premises. Unlike regular letters A through Z, direction words form a separate pool and never mix with alphabetic letters. Constraint graph: the spatial dependency network formed by middle-window atoms establishing positional relationships. Level six requires building and validating constraint graphs using direction words as nodes. SAT solving, Level six: Satisfiability solving to verify that a premise is spatially consistent with existing constraints. Direction-word premises must pass SAT validation to be accepted as valid. Semantic anchoring: a mental strategy where you anchor abstract letters to concrete concepts from your lived experience, then apply directional transformations. Example: J equals Fact, North of J to N equals Fact to Theory. Arc of Abstraction: the spectrum from concrete lived experience to abstract concepts. Semantic anchoring uses this arc to make abstract premises meaningful. Mental transformation: applying directional operators to your semantic anchors in your head. Example: South of Theory equals down-shift to Example.'
            },
            {
                id: 'level6',
                title: 'Level 6: Direction-Word Spatial Reasoning',
                html: `
                    <h3>Level 6: Direction-Word Spatial Reasoning (Advanced g-Leap)</h3>
                    <p>Level 6 introduces <strong>direction words as spatial letters</strong>‚Äîa radical cognitive challenge requiring 6th-order relational reasoning across abstract directional concepts.</p>

                    <h4>What You'll See</h4>
                    <p>Instead of regular letters (A, B, C), you'll see direction words used as spatial coordinates:</p>
                    <p style="text-align: center; font-size: 1.2rem; color: #3498db; margin: 20px 0;"><code>"West is north of East, East is west of South"</code></p>

                    <h4>How It Works</h4>
                    <p>The four compass directions (North, South, East, West) become <strong>letters in spatial relationships</strong>. You must:</p>
                    <ol>
                        <li><strong>Build a constraint graph</strong> from middle-window atoms establishing spatial positions</li>
                        <li><strong>Verify spatial consistency</strong> of the current premise using SAT solving</li>
                        <li><strong>Match with n-back premise</strong> using standard equivalence logic (invertible mapping, shared anchors, mid-window derivability)</li>
                    </ol>

                    <h4>Example Walkthrough</h4>
                    <div style="background: rgba(22, 33, 62, 0.8); padding: 16px; margin: 16px 0;">
                        <p><strong>Trial 5 (n=2):</strong></p>
                        <p>Middle atoms (from trials 3-4): <code>"North is south of South"</code></p>
                        <p>N-2-back premise (trial 3): <code>"West is north of East"</code></p>
                        <p>Current premise (trial 5): <code>"East is south of West"</code></p>

                        <p style="margin-top: 12px;"><strong>Step 1: Build constraint model from middle atoms</strong></p>
                        <ul style="margin-left: 20px; color: #aaa;">
                            <li>North is positioned south of South (establishes vertical relationship)</li>
                        </ul>

                        <p style="margin-top: 12px;"><strong>Step 2: Check spatial consistency</strong></p>
                        <ul style="margin-left: 20px; color: #aaa;">
                            <li>Can "East is south of West" coexist with middle constraints?</li>
                            <li>SAT solver validates: YES (no contradiction)</li>
                        </ul>

                        <p style="margin-top: 12px;"><strong>Step 3: Equivalence check with n-2-back</strong></p>
                        <ul style="margin-left: 20px; color: #aaa;">
                            <li>N-2: "West is north of East" ‚Üí "West" north of "East"</li>
                            <li>Current: "East is south of West" ‚Üí "East" south of "West"</li>
                            <li>Invertible mapping: (West‚ÜîEast, north‚Üîsouth) ‚Üí <strong>MATCH!</strong></li>
                        </ul>
                    </div>

                    <h4>Why This is Level 5 Difficulty</h4>
                    <ul>
                        <li><strong>Abstract spatial reasoning:</strong> Direction words have no semantic meaning‚Äîpure relational logic</li>
                        <li><strong>Constraint graph navigation:</strong> Must track multiple simultaneous spatial dependencies</li>
                        <li><strong>Variable outcomes:</strong> Same premise pattern yields different results based on middle-window context</li>
                        <li><strong>No memorizable patterns:</strong> Combinatorial explosion prevents gaming</li>
                        <li><strong>Multi-step derivation:</strong> Up to k=2 atoms creating complex constraint chains</li>
                    </ul>

                    <h4>N-Back Matching</h4>
                    <p>Uses standard atomic equivalence logic from Levels 1-5:</p>
                    <ul>
                        <li><strong>Parity check:</strong> Atom count must match</li>
                        <li><strong>Invertible mapping:</strong> Must find consistent letter‚Üîletter and axis‚Üîaxis mapping</li>
                        <li><strong>Shared anchors:</strong> At least 2 shared direction-word letters</li>
                        <li><strong>SAT validation:</strong> Combined premises must be spatially consistent</li>
                        <li><strong>Mid-window check:</strong> Premises not derivable from middle atoms alone</li>
                    </ul>

                    <h4>Practice Examples</h4>
                    <p><strong>Example 1 (k=1):</strong> <code>West is north of East</code></p>
                    <ul>
                        <li>Single atom, simple spatial relationship</li>
                        <li>Match if n-back has invertible mapping (e.g., "East is south of West")</li>
                    </ul>

                    <p><strong>Example 2 (k=2):</strong> <code>West is north of East, East is west of South</code></p>
                    <ul>
                        <li>Two atoms create constraint chain: West‚Üí(north)‚ÜíEast‚Üí(west)‚ÜíSouth</li>
                        <li>Requires tracking multiple relationships simultaneously</li>
                        <li>Middle atoms may establish additional constraints</li>
                    </ul>

                    <h4>How to Enable</h4>
                    <p>Check the <strong>"Force Meta-Relational Trials (Level 6: g-Leap)"</strong> checkbox before starting a session. Despite the name, this now activates direction-word spatial reasoning.</p>
                `,
                speech: 'Level Six: Direction-Word Spatial Reasoning, Advanced g-Leap. Level six introduces direction words as spatial letters, a radical cognitive challenge requiring sixth-order relational reasoning across abstract directional concepts. What You Will See: Instead of regular letters like A, B, C, you will see direction words used as spatial coordinates. For example: West is north of East, East is west of South. How It Works: The four compass directions, North, South, East, West, become letters in spatial relationships. You must: One, Build a constraint graph from middle-window atoms establishing spatial positions. Two, Verify spatial consistency of the current premise using SAT solving. Three, Match with n-back premise using standard equivalence logic including invertible mapping, shared anchors, and mid-window derivability. Example Walkthrough: Trial five with n equals two. Middle atoms from trials three to four: North is south of South. N-two-back premise from trial three: West is north of East. Current premise in trial five: East is south of West. Step one: Build constraint model from middle atoms. North is positioned south of South, establishing vertical relationship. Step two: Check spatial consistency. Can East is south of West coexist with middle constraints? SAT solver validates: yes, no contradiction. Step three: Equivalence check with n-two-back. N-two-back: West is north of East. Current: East is south of West. Invertible mapping: West maps to East, East maps to West, north maps to south, south maps to north. Result: MATCH. Why This is Level Five Difficulty: Abstract spatial reasoning, direction words have no semantic meaning, pure relational logic. Constraint graph navigation, must track multiple simultaneous spatial dependencies. Variable outcomes, same premise pattern yields different results based on middle-window context. No memorizable patterns, combinatorial explosion prevents gaming. Multi-step derivation, up to k equals two atoms creating complex constraint chains. N-Back Matching uses standard atomic equivalence logic from Levels one to five: Parity check, atom count must match. Invertible mapping, must find consistent letter to letter and axis to axis mapping. Shared anchors, at least two shared direction-word letters. SAT validation, combined premises must be spatially consistent. Mid-window check, premises not derivable from middle atoms alone. Practice Examples: Example one, k equals one: West is north of East. Single atom, simple spatial relationship. Match if n-back has invertible mapping, for example, East is south of West. Example two, k equals two: West is north of East, East is west of South. Two atoms create constraint chain: West to north to East to west to South. Requires tracking multiple relationships simultaneously. Middle atoms may establish additional constraints. How to Enable: Check the Force Meta-Relational Trials, Level six g-Leap, checkbox before starting a session. Despite the name, this now activates direction-word spatial reasoning.'
            },
            {
                id: 'level7',
                title: 'Level 7: Compound Operator Relational',
                html: `
                    <h3>Level 7: Compound Operator Relational (Maximum g-Load)</h3>
                    <p>This is the <strong>ultimate cognitive challenge</strong>‚Äîcombining abstract operator sequences, semantic anchoring, meta-relational reasoning, and working memory into a single unified task. Level 7 achieves <strong>7th-order reasoning</strong>.</p>

                    <h4>The Concept</h4>
                    <p>Level 7 premises look like this: <code>"north-west is north of south-east"</code></p>
                    <p>This combines:</p>
                    <ul>
                        <li><strong>Compound operators:</strong> "north-west" is a sequence of transformations (north, then west)</li>
                        <li><strong>Meta-relationships:</strong> The compound operators themselves are related by a meta-operator (north)</li>
                        <li><strong>Semantic anchoring:</strong> You mentally anchor and transform concepts through the sequences</li>
                        <li><strong>Abstract pairing:</strong> The two compound operators form a unified relational structure</li>
                    </ul>

                    <h4>How It Works (Purely Mental)</h4>
                    <p><strong>Example: "north-west is north of south-east"</strong></p>
                    <ol>
                        <li><strong>Pick a seed concept for left side:</strong> "Order"</li>
                        <li><strong>Apply north-west transformation:</strong>
                            <ul>
                                <li>North(Order) = up-shift ‚Üí "System" (generalization)</li>
                                <li>West(System) = opposite ‚Üí "Chaos" (counterpart)</li>
                                <li><strong>Result:</strong> north-west := "Chaos"</li>
                            </ul>
                        </li>
                        <li><strong>Pick a seed concept for right side:</strong> "Calm"</li>
                        <li><strong>Apply south-east transformation:</strong>
                            <ul>
                                <li>South(Calm) = down-shift ‚Üí "Stillness" (concrete instance)</li>
                                <li>East(Stillness) = analogue ‚Üí "Peace" (sibling concept)</li>
                                <li><strong>Result:</strong> south-east := "Peace"</li>
                            </ul>
                        </li>
                        <li><strong>Evaluate meta-relationship:</strong>
                            <ul>
                                <li>Is "Chaos" north of "Peace"?</li>
                                <li>Is Chaos a generalization of Peace?</li>
                                <li><strong>Your judgment:</strong> Perhaps... Chaos is a broader state that can contain peaceful moments?</li>
                            </ul>
                        </li>
                        <li><strong>Decide: MATCH or NO MATCH</strong> (based on your semantic model)</li>
                    </ol>

                    <h4>The 7th-Order Reasoning</h4>
                    <p>This achieves 7 layers of abstraction:</p>
                    <ol>
                        <li><strong>1st-order:</strong> Concrete concepts (Order, Calm, Chaos, Peace)</li>
                        <li><strong>2nd-order:</strong> Basic transformations (north = up-shift, west = opposite)</li>
                        <li><strong>3rd-order:</strong> Sequential composition (north-west = up-shift then opposite)</li>
                        <li><strong>4th-order:</strong> Compound transformations as entities (north-west becomes "Chaos")</li>
                        <li><strong>5th-order:</strong> Meta-relationships between entities (Chaos is north of Peace)</li>
                        <li><strong>6th-order:</strong> Abstract pairing (north-west and south-east form unified structure)</li>
                        <li><strong>7th-order:</strong> Self-generated semantic evaluation across n-back trials</li>
                    </ol>

                    <h4>k Parameter Controls Complexity</h4>
                    <p>The k slider controls <strong>number of compound atoms per premise</strong> (just like in atomic mode):</p>
                    <ul>
                        <li><strong>k=1:</strong> Single compound atom (e.g., "north-west is south of east-north")</li>
                        <li><strong>k=2:</strong> Two compound atoms (e.g., "north-west is south of east-north; north-west is east of south-west")</li>
                        <li><strong>k=3:</strong> Three compound atoms</li>
                        <li><strong>k=4:</strong> Four compound atoms</li>
                    </ul>
                    <p>Note: Compound operators are <strong>always 2 operators</strong> (like "north-west"). Higher k creates multi-atom premises where compound operators appear in multiple relationships.</p>

                    <h4>N-Back Matching</h4>
                    <p>Because there's no formal truth value (evaluation is semantic), matching works differently:</p>
                    <ul>
                        <li>You make a judgment: MATCH or NO MATCH (based on your mental model)</li>
                        <li>System tracks YOUR judgment</li>
                        <li>N trials later, you must <strong>recall YOUR previous judgment</strong></li>
                        <li>If current and n-back both MATCH ‚Üí correct response is MATCH</li>
                        <li>If both NO MATCH ‚Üí correct response is MATCH</li>
                        <li>If one MATCH and one NO MATCH ‚Üí correct response is NO MATCH</li>
                    </ul>

                    <h4>Why This is Maximum g-Load</h4>
                    <p>Level 7 combines ALL cognitive demands simultaneously:</p>
                    <ol>
                        <li><strong>Sequential transformation:</strong> Apply 2-4 operators in sequence</li>
                        <li><strong>Semantic anchoring:</strong> Generate mental concepts for seeds</li>
                        <li><strong>Working memory:</strong> Maintain transformation state across steps</li>
                        <li><strong>Meta-reasoning:</strong> Evaluate relationships between compound results</li>
                        <li><strong>Abstract pairing:</strong> Unified relational structure (not separate examples)</li>
                        <li><strong>Subjective judgment:</strong> No formal answer‚Äîtrust your mental model</li>
                        <li><strong>N-back recall:</strong> Remember YOUR judgments across trials</li>
                    </ol>

                    <h4>Tips for Success</h4>
                    <ul>
                        <li><strong>Visualize the transformations:</strong> Actually imagine each step (Order‚ÜíSystem‚ÜíChaos)</li>
                        <li><strong>Use vivid seeds:</strong> Pick concrete concepts you can mentally manipulate</li>
                        <li><strong>Trust your intuition:</strong> There's no "correct" answer‚Äîyour semantic model is what matters</li>
                        <li><strong>Be consistent:</strong> Use similar seed types to maintain coherence</li>
                        <li><strong>Track your pattern:</strong> Notice if you tend to say MATCH or NO MATCH more often</li>
                    </ul>

                    <h4>How to Enable</h4>
                    <p>Check the <strong>"Force Compound Operator Trials (Level 7: Maximum g-Load)"</strong> checkbox in the controls panel before starting a session. This automatically disables Level 6 (they're mutually exclusive).</p>

                    <p><strong>Recommended settings for maximum challenge:</strong> n=5, k=4 (5-back with 4 compound atoms per premise)</p>
                `,
                speech: 'Level Seven: Compound Operator Relational, Maximum g-Load. This is the ultimate cognitive challenge, combining abstract operator sequences, semantic anchoring, meta-relational reasoning, and working memory into a single unified task. Level seven achieves seventh-order reasoning. The Concept: Level seven premises look like this: north-west is north of south-east. This combines compound operators like north-west which is a sequence of exactly two transformations, meta-relationships where compound operators are related by a meta-operator, semantic anchoring where you mentally anchor and transform concepts through sequences, and abstract pairing where the two compound operators form a unified relational structure. How It Works, Purely Mental: Example: north-west is north of south-east. Step one, Pick a seed concept for left side: Order. Step two, Apply north-west transformation: North of Order equals up-shift to System. West of System equals opposite to Chaos. Result: north-west equals Chaos. Step three, Pick a seed concept for right side: Calm. Step four, Apply south-east transformation: South of Calm equals down-shift to Stillness. East of Stillness equals analogue to Peace. Result: south-east equals Peace. Step five, Evaluate meta-relationship: Is Chaos north of Peace? Is Chaos a generalization of Peace? Your judgment decides. Step six, Decide: MATCH or NO MATCH based on your semantic model. Why This is Maximum g-Load: Level seven combines all cognitive demands simultaneously. Sequential transformation: apply two operators in sequence for each compound. Semantic anchoring: generate mental concepts for seeds. Working memory: maintain transformation state across steps. Meta-reasoning: evaluate relationships between compound results. Abstract pairing: unified relational structure, not separate examples. Subjective judgment: no formal answer, trust your mental model. N-back recall: remember your judgments across trials. How to Enable: Check the Force Compound Operator Trials, Level seven Maximum g-Load, checkbox in the controls panel before starting a session. Recommended settings for maximum challenge: n equals five, k equals four, five-back with four compound atoms per premise.'
            },
            {
                id: 'level8',
                title: 'Level 8: 8-Direction Meta-Compound Operators (Octo-Leap)',
                html: `
                    <h3>Level 8: 8-Direction Meta-Compound Operators (Octo-Leap)</h3>
                    <p>This is <strong>the ultimate expansion of spatial reasoning</strong>. Level 8 extends the 4-direction compass to <strong>8 directions</strong>, adding diagonal operators that YOU must creatively interpret.</p>

                    <h4>The Concept: Generative Semantics</h4>
                    <p>Level 8 premises look like this:</p>
                    <p style="text-align: center; font-size: 1.2rem; color: #e74c3c; margin: 20px 0;"><code>"northeast-southwest is north of southeast-northwest"</code></p>

                    <p>This combines:</p>
                    <ul>
                        <li><strong>8-direction compound operators:</strong> Sequences drawn from N, NE, E, SE, S, SW, W, NW (56 possible compounds: 8√ó7)</li>
                        <li><strong>4-direction meta-operators:</strong> The meta-relationship remains N, S, E, W</li>
                        <li><strong>Generative interpretation:</strong> YOU invent meanings for diagonal directions (NE, SE, SW, NW)</li>
                        <li><strong>Semantic anchoring at scale:</strong> Create and maintain an 8-direction mental model</li>
                    </ul>

                    <h4>The 8 Directions</h4>
                    <p>You already know the cardinal directions:</p>
                    <ul>
                        <li><strong>N (North):</strong> Up-shift, generalization, abstraction</li>
                        <li><strong>S (South):</strong> Down-shift, specification, concretization</li>
                        <li><strong>E (East):</strong> Analogue, sibling, parallel role</li>
                        <li><strong>W (West):</strong> Opposite, antonym, counter-role</li>
                    </ul>

                    <p><strong>The diagonal directions are OPEN for YOUR interpretation:</strong></p>
                    <ul>
                        <li><strong>NE (Northeast):</strong> What does "up-shift + analogue" mean to you? Generalizing sideways? Abstract sibling?</li>
                        <li><strong>SE (Southeast):</strong> Down-shift + analogue? Concrete parallel? Specific example of similar thing?</li>
                        <li><strong>SW (Southwest):</strong> Down-shift + opposite? Concrete antithesis? Specific counter-example?</li>
                        <li><strong>NW (Northwest):</strong> Up-shift + opposite? Abstract antonym? Generalized negation?</li>
                    </ul>

                    <p><strong>Critical insight:</strong> There is no "correct" interpretation. The cognitive training comes from <strong>inventing a coherent 8-direction model</strong> and <strong>maintaining it across trials</strong>.</p>

                    <h4>How It Works (Purely Mental)</h4>
                    <p><strong>Example:</strong> "northeast-southwest is north of southeast-northwest"</p>

                    <ol>
                        <li><strong>Pick a seed concept for left side:</strong> "Order"</li>
                        <li><strong>Apply NE transformation:</strong>
                            <ul>
                                <li>You've decided NE = "abstract sibling"</li>
                                <li>Abstract sibling of "Order" ‚Üí "Structure"</li>
                            </ul>
                        </li>
                        <li><strong>Apply SW transformation:</strong>
                            <ul>
                                <li>You've decided SW = "concrete opposite"</li>
                                <li>Concrete opposite of "Structure" ‚Üí "Spontaneity"</li>
                                <li>Result: northeast-southwest = "Spontaneity"</li>
                            </ul>
                        </li>
                        <li><strong>Pick a seed concept for right side:</strong> "Plan"</li>
                        <li><strong>Apply SE transformation:</strong>
                            <ul>
                                <li>You've decided SE = "concrete analogue"</li>
                                <li>Concrete analogue of "Plan" ‚Üí "Blueprint"</li>
                            </ul>
                        </li>
                        <li><strong>Apply NW transformation:</strong>
                            <ul>
                                <li>You've decided NW = "abstract opposite"</li>
                                <li>Abstract opposite of "Blueprint" ‚Üí "Improvisation"</li>
                                <li>Result: southeast-northwest = "Improvisation"</li>
                            </ul>
                        </li>
                        <li><strong>Evaluate meta-relationship:</strong> Is "Spontaneity" north of "Improvisation"? (Is Spontaneity a generalization of Improvisation?)</li>
                        <li><strong>Your judgment decides:</strong> MATCH or NO MATCH</li>
                    </ol>

                    <h4>Why This is Beyond Maximum g-Load</h4>
                    <p>Level 8 adds cognitive demands on top of Level 7:</p>
                    <ol>
                        <li><strong>Generative semantics:</strong> YOU create the meaning of 4 new operators</li>
                        <li><strong>8-way spatial reasoning:</strong> Maintain a coherent 8-direction model</li>
                        <li><strong>Combinatorial explosion:</strong> 56 possible compounds (vs. 12 in Level 7)</li>
                        <li><strong>Diagonal abstraction:</strong> Diagonals combine two axes‚Äîrequires higher-order thinking</li>
                        <li><strong>Consistency maintenance:</strong> Your interpretations must remain coherent across trials</li>
                        <li><strong>All Level 7 demands:</strong> Sequential transformation, semantic anchoring, meta-reasoning, n-back recall</li>
                    </ol>

                    <h4>Tips for Success</h4>
                    <ul>
                        <li><strong>Define your diagonals early:</strong> Before starting, decide what NE, SE, SW, NW mean to you</li>
                        <li><strong>Write them down (initially):</strong> For first few sessions, keep a reference of your diagonal interpretations</li>
                        <li><strong>Use compositional logic:</strong> NE = N+E, so combine their meanings (e.g., "up-shift an analogue")</li>
                        <li><strong>Be systematic:</strong> If NE = "abstract sibling", then SW should be its opposite: "concrete opposite"</li>
                        <li><strong>Test coherence:</strong> Do your interpretations create consistent transformations?</li>
                        <li><strong>Internalize gradually:</strong> After practice, you should no longer need written reference</li>
                    </ul>

                    <h4>Example Diagonal Interpretation Systems</h4>
                    <p><strong>System 1 (Compositional):</strong></p>
                    <ul>
                        <li>NE = "Generalize + Analogue" = "Abstract Sibling" (e.g., Theory‚ÜíTheorem)</li>
                        <li>SE = "Specify + Analogue" = "Concrete Parallel" (e.g., Example‚ÜíInstance)</li>
                        <li>SW = "Specify + Opposite" = "Concrete Antithesis" (e.g., Light‚ÜíDarkness)</li>
                        <li>NW = "Generalize + Opposite" = "Abstract Negation" (e.g., Order‚ÜíEntropy)</li>
                    </ul>

                    <p><strong>System 2 (Spatial Metaphor):</strong></p>
                    <ul>
                        <li>NE = "Rising to the side" = "Elevated alternative"</li>
                        <li>SE = "Descending to the side" = "Grounded variant"</li>
                        <li>SW = "Descending away" = "Diminished opposite"</li>
                        <li>NW = "Rising away" = "Transcendent opposite"</li>
                    </ul>

                    <p><strong>System 3 (Narrative):</strong></p>
                    <ul>
                        <li>NE = "Allied improvement"</li>
                        <li>SE = "Practical example"</li>
                        <li>SW = "Grounded counterpoint"</li>
                        <li>NW = "Ideological antithesis"</li>
                    </ul>

                    <h4>K Parameter in Level 8</h4>
                    <ul>
                        <li><strong>k=1:</strong> Single 8D compound atom</li>
                        <li><strong>k=2:</strong> Two 8D compound atoms</li>
                        <li><strong>k=3:</strong> Three 8D compound atoms</li>
                        <li><strong>k=4:</strong> Four 8D compound atoms (extreme challenge)</li>
                    </ul>

                    <h4>How to Enable</h4>
                    <p>Check the <strong>"Force 8-Direction Compound Operator Trials (Level 8: Octo-Leap)"</strong> checkbox in the controls panel before starting a session. This automatically disables Level 6 and Level 7 (they're mutually exclusive).</p>

                    <p><strong>Recommended settings for ultimate challenge:</strong> n=4, k=3 (4-back with 3 eight-directional compound atoms)</p>

                    <p style="color: #e74c3c; font-weight: bold; margin-top: 20px;">WARNING: Level 8 is cognitively demanding beyond measure. Start with n=2, k=1 and gradually increase difficulty as you internalize your 8-direction model.</p>
                `,
                speech: 'Level Eight: Eight-Direction Meta-Compound Operators, Octo-Leap. This is the ultimate expansion of spatial reasoning, extending the compass to eight directions with diagonal operators that you must creatively interpret. The Concept, Generative Semantics: Level eight premises look like this: northeast-southwest is north of southeast-northwest. This combines eight-direction compound operators drawn from N, NE, E, SE, S, SW, W, NW, creating fifty-six possible compounds. Meta-operators remain four-directional: N, S, E, W. The breakthrough is generative interpretation: you invent meanings for diagonal directions. The Eight Directions: You know the cardinals. North: up-shift, generalization. South: down-shift, specification. East: analogue, sibling. West: opposite, antonym. The diagonal directions are open for your interpretation. Northeast: What does up-shift plus analogue mean to you? Abstract sibling? Southeast: Down-shift plus analogue? Concrete parallel? Southwest: Down-shift plus opposite? Concrete antithesis? Northwest: Up-shift plus opposite? Abstract negation? Critical insight: There is no correct interpretation. The cognitive training comes from inventing a coherent eight-direction model and maintaining it across trials. How It Works, Purely Mental: Example: northeast-southwest is north of southeast-northwest. Pick a seed concept for left side: Order. Apply NE transformation. You decided NE equals abstract sibling. Abstract sibling of Order is Structure. Apply SW transformation. You decided SW equals concrete opposite. Concrete opposite of Structure is Spontaneity. Result: northeast-southwest equals Spontaneity. Pick a seed for right side: Plan. Apply SE transformation. You decided SE equals concrete analogue. Concrete analogue of Plan is Blueprint. Apply NW transformation. You decided NW equals abstract opposite. Abstract opposite of Blueprint is Improvisation. Result: southeast-northwest equals Improvisation. Evaluate meta-relationship: Is Spontaneity north of Improvisation? Your judgment decides: MATCH or NO MATCH. Why This is Beyond Maximum g-Load: Level eight adds demands on top of Level seven. Generative semantics: you create meaning for four new operators. Eight-way spatial reasoning: maintain coherent eight-direction model. Combinatorial explosion: fifty-six possible compounds versus twelve in Level seven. Diagonal abstraction: diagonals combine two axes, requiring higher-order thinking. Consistency maintenance: your interpretations must remain coherent across trials. Plus all Level seven demands: sequential transformation, semantic anchoring, meta-reasoning, n-back recall. Tips for Success: Define your diagonals early before starting. Write them down initially for reference. Use compositional logic: NE equals N plus E, so combine their meanings. Be systematic: if NE equals abstract sibling, then SW should be concrete opposite. Test coherence in your interpretations. Internalize gradually until you no longer need written reference. How to Enable: Check the Force Eight-Direction Compound Operator Trials, Level eight Octo-Leap, checkbox in the controls panel. This disables Level six and Level seven as they are mutually exclusive. Recommended settings for ultimate challenge: n equals four, k equals three, four-back with three eight-directional compound atoms. Warning: Level eight is cognitively demanding beyond measure. Start with n equals two, k equals one and gradually increase difficulty as you internalize your eight-direction model.'
            },
            {
                id: 'level8-instructions',
                title: 'Level 8 Instructions: Imaginative Abstraction Method',
                html: `
                    <h3>Level 8 Instructions: Imaginative Abstraction Method</h3>

                    <h4>Introduction: The Generative Imagination Engine</h4>
                    <p>Level 8 demands that you become an <strong>architect of meaning</strong>. You will invent a complete 8-direction semantic system using vivid, sensory-rich transformations. This tutorial demonstrates the imaginative abstraction method through a complete n-2-back walkthrough.</p>

                    <p><strong>Core principle:</strong> Start with a living, breathing seed concept. Apply compound transformations as if you're watching a movie in your mind. Each direction becomes a creative force that reshapes your mental image.</p>

                    <h4>The 8-Direction Invention System</h4>
                    <p><strong>Cardinal Directions (Given):</strong></p>
                    <ul>
                        <li><strong>N (North):</strong> Up-shift, generalization, expansion, intensification</li>
                        <li><strong>S (South):</strong> Down-shift, specification, reduction, materialization</li>
                        <li><strong>E (East):</strong> Analogue, parallel role, sibling concept, lateral shift</li>
                        <li><strong>W (West):</strong> Opposite, antithesis, negation, mirror inverse</li>
                    </ul>

                    <p><strong>Diagonal Directions (Your Invention):</strong></p>
                    <ul>
                        <li><strong>NE (Northeast) = N+E:</strong> "Generalize an analogue" ‚Üí Elevated sibling, abstract parallel, transcendent variant</li>
                        <li><strong>SE (Southeast) = S+E:</strong> "Concretize an analogue" ‚Üí Grounded parallel, physical twin, material sibling</li>
                        <li><strong>SW (Southwest) = S+W:</strong> "Concretize an opposite" ‚Üí Material antithesis, physical negation, embodied counter</li>
                        <li><strong>NW (Northwest) = N+W:</strong> "Generalize an opposite" ‚Üí Abstract negation, transcendent antithesis, ideological inverse</li>
                    </ul>

                    <h4>Theme for This Walkthrough: Forces of Consciousness</h4>
                    <p>We'll use <strong>states of consciousness, cognitive forces, and phenomenological experiences</strong> as our seed concepts. Each transformation will create vivid mental imagery.</p>

                    <h4>10-Trial N-2-Back Walkthrough</h4>

                    <div class="sandbox-journal" style="max-height: none; background: rgba(22, 33, 62, 0.8); padding: 16px; margin: 16px 0;">

                    <div class="sandbox-journal-entry">
                    <h5 style="color: #e94560; margin-bottom: 8px;">Trial 1: "northeast-southwest is north of southeast-northwest"</h5>

                    <p><strong>Premise decomposition:</strong> northeast-southwest is north of southeast-northwest</p>

                    <p><strong>Left side (northeast-southwest):</strong></p>
                    <ul style="margin-left: 20px; color: #aaa;">
                        <li><strong>Seed:</strong> "Attention" (a focused cognitive state)</li>
                        <li><strong>Apply NE (elevated sibling):</strong> Attention ‚Üí <strong>"Vigilance"</strong> (abstract parallel of attention‚Äîwatchful awareness at higher scale)</li>
                        <li><strong>Apply SW (material antithesis):</strong> Vigilance ‚Üí <strong>"Distraction"</strong> (physical embodiment of vigilance's opposite‚Äîscattered sensory pull)</li>
                        <li><strong>Result:</strong> northeast-southwest = <strong>"Distraction"</strong></li>
                    </ul>

                    <p><strong>Right side (southeast-northwest):</strong></p>
                    <ul style="margin-left: 20px; color: #aaa;">
                        <li><strong>Seed:</strong> "Awareness" (conscious presence)</li>
                        <li><strong>Apply SE (grounded parallel):</strong> Awareness ‚Üí <strong>"Sensation"</strong> (physical twin of awareness‚Äîembodied noticing)</li>
                        <li><strong>Apply NW (transcendent antithesis):</strong> Sensation ‚Üí <strong>"Numbness"</strong> (abstract negation of sensation‚Äîvoid of feeling)</li>
                        <li><strong>Result:</strong> southeast-northwest = <strong>"Numbness"</strong></li>
                    </ul>

                    <p><strong>Meta-relation verification:</strong></p>
                    <p style="margin-left: 20px;">Is "Distraction" north of "Numbness"?<br>
                    Is Distraction a generalization/intensification of Numbness?<br>
                    <strong>My judgment:</strong> YES. Distraction is the active, generalized state; Numbness is its passive, diminished form. Distraction encompasses scattered attention; Numbness is complete absence. Distraction is "higher" in energy/scale.</p>

                    <p><strong>N-2-back comparison:</strong> N/A (first trial)</p>
                    <p style="color: #2ecc71; font-weight: bold;">JUDGMENT: MATCH (premise holds true in my model)</p>
                    </div>

                    <div class="sandbox-journal-entry">
                    <h5 style="color: #e94560; margin-bottom: 8px;">Trial 2: "southwest-northeast is west of northwest-southeast"</h5>

                    <p><strong>Premise decomposition:</strong> southwest-northeast is west of northwest-southeast</p>

                    <p><strong>Left side (southwest-northeast):</strong></p>
                    <ul style="margin-left: 20px; color: #aaa;">
                        <li><strong>Seed:</strong> "Intention" (directed will)</li>
                        <li><strong>Apply SW (material antithesis):</strong> Intention ‚Üí <strong>"Surrender"</strong> (physical embodiment of intention's opposite‚Äîletting go)</li>
                        <li><strong>Apply NE (elevated sibling):</strong> Surrender ‚Üí <strong>"Acceptance"</strong> (abstract parallel of surrender‚Äîtranscendent yielding)</li>
                        <li><strong>Result:</strong> southwest-northeast = <strong>"Acceptance"</strong></li>
                    </ul>

                    <p><strong>Right side (northwest-southeast):</strong></p>
                    <ul style="margin-left: 20px; color: #aaa;">
                        <li><strong>Seed:</strong> "Control" (mastery over conditions)</li>
                        <li><strong>Apply NW (transcendent antithesis):</strong> Control ‚Üí <strong>"Chaos"</strong> (abstract negation‚Äîideological inverse of control)</li>
                        <li><strong>Apply SE (grounded parallel):</strong> Chaos ‚Üí <strong>"Turbulence"</strong> (material sibling of chaos‚Äîphysical disorder)</li>
                        <li><strong>Result:</strong> northwest-southeast = <strong>"Turbulence"</strong></li>
                    </ul>

                    <p><strong>Meta-relation verification:</strong></p>
                    <p style="margin-left: 20px;">Is "Acceptance" west of "Turbulence"?<br>
                    Is Acceptance the opposite/antithesis of Turbulence?<br>
                    <strong>My judgment:</strong> YES. Acceptance is calm integration; Turbulence is chaotic disruption. They are opposing forces‚Äîone finds peace in disorder, the other IS the disorder.</p>

                    <p><strong>N-2-back comparison:</strong> N/A (trial 2, need trial 0)</p>
                    <p style="color: #2ecc71; font-weight: bold;">JUDGMENT: MATCH (premise holds true in my model)</p>
                    </div>

                    <div class="sandbox-journal-entry">
                    <h5 style="color: #e94560; margin-bottom: 8px;">Trial 3: "southeast-northwest is east of northeast-southwest"</h5>

                    <p><strong>Premise decomposition:</strong> southeast-northwest is east of northeast-southwest</p>

                    <p><strong>Left side (southeast-northwest):</strong></p>
                    <ul style="margin-left: 20px; color: #aaa;">
                        <li><strong>Seed:</strong> "Curiosity" (exploratory drive)</li>
                        <li><strong>Apply SE (grounded parallel):</strong> Curiosity ‚Üí <strong>"Investigation"</strong> (material sibling‚Äîphysical act of exploring)</li>
                        <li><strong>Apply NW (transcendent antithesis):</strong> Investigation ‚Üí <strong>"Certainty"</strong> (abstract negation‚Äîideological inverse of investigation)</li>
                        <li><strong>Result:</strong> southeast-northwest = <strong>"Certainty"</strong></li>
                    </ul>

                    <p><strong>Right side (northeast-southwest):</strong></p>
                    <ul style="margin-left: 20px; color: #aaa;">
                        <li><strong>Seed:</strong> "Inquiry" (questioning stance)</li>
                        <li><strong>Apply NE (elevated sibling):</strong> Inquiry ‚Üí <strong>"Philosophy"</strong> (abstract parallel‚Äîtranscendent questioning)</li>
                        <li><strong>Apply SW (material antithesis):</strong> Philosophy ‚Üí <strong>"Dogma"</strong> (physical embodiment of philosophy's opposite‚Äîrigid belief)</li>
                        <li><strong>Result:</strong> northeast-southwest = <strong>"Dogma"</strong></li>
                    </ul>

                    <p><strong>Meta-relation verification:</strong></p>
                    <p style="margin-left: 20px;">Is "Certainty" east of "Dogma"?<br>
                    Is Certainty an analogue/parallel role to Dogma?<br>
                    <strong>My judgment:</strong> YES. Both represent fixed conviction. Certainty is the psychological state; Dogma is the systematized belief. They're siblings in the family of "settled knowing."</p>

                    <p><strong>N-2-back comparison:</strong> Compare to Trial 1<br>
                    Trial 1 judgment: MATCH | Trial 3 judgment: MATCH<br>
                    <strong>Both MATCH ‚Üí Correct response: MATCH</strong></p>
                    <p style="color: #2ecc71; font-weight: bold;">N-BACK ANSWER: MATCH ‚úì</p>
                    </div>

                    <div class="sandbox-journal-entry">
                    <h5 style="color: #e94560; margin-bottom: 8px;">Trial 4: "northwest-southeast is south of southwest-northeast"</h5>

                    <p><strong>Premise decomposition:</strong> northwest-southeast is south of southwest-northeast</p>

                    <p><strong>Left side (northwest-southeast):</strong></p>
                    <ul style="margin-left: 20px; color: #aaa;">
                        <li><strong>Seed:</strong> "Hope" (future-oriented expectation)</li>
                        <li><strong>Apply NW (transcendent antithesis):</strong> Hope ‚Üí <strong>"Despair"</strong> (abstract negation‚Äîideological inverse)</li>
                        <li><strong>Apply SE (grounded parallel):</strong> Despair ‚Üí <strong>"Grief"</strong> (material sibling‚Äîphysical twin of despair)</li>
                        <li><strong>Result:</strong> northwest-southeast = <strong>"Grief"</strong></li>
                    </ul>

                    <p><strong>Right side (southwest-northeast):</strong></p>
                    <ul style="margin-left: 20px; color: #aaa;">
                        <li><strong>Seed:</strong> "Joy" (expansive positive affect)</li>
                        <li><strong>Apply SW (material antithesis):</strong> Joy ‚Üí <strong>"Sorrow"</strong> (physical embodiment of joy's opposite)</li>
                        <li><strong>Apply NE (elevated sibling):</strong> Sorrow ‚Üí <strong>"Melancholy"</strong> (abstract parallel‚Äîtranscendent sadness)</li>
                        <li><strong>Result:</strong> southwest-northeast = <strong>"Melancholy"</strong></li>
                    </ul>

                    <p><strong>Meta-relation verification:</strong></p>
                    <p style="margin-left: 20px;">Is "Grief" south of "Melancholy"?<br>
                    Is Grief a specification/concretization of Melancholy?<br>
                    <strong>My judgment:</strong> NO. Grief feels more intense, more specific‚Äîit's the acute loss. But Melancholy is the diffuse, atmospheric sadness. They're not in a hierarchical relationship; Grief is actually MORE specific than Melancholy already. The premise inverts this.</p>

                    <p><strong>N-2-back comparison:</strong> Compare to Trial 2<br>
                    Trial 2 judgment: MATCH | Trial 4 judgment: NO MATCH<br>
                    <strong>One MATCH, one NO MATCH ‚Üí Correct response: NO MATCH</strong></p>
                    <p style="color: #e67e22; font-weight: bold;">N-BACK ANSWER: NO MATCH ‚úì</p>
                    </div>

                    <div class="sandbox-journal-entry">
                    <h5 style="color: #e94560; margin-bottom: 8px;">Trial 5: "northeast-southwest is north of southeast-northwest"</h5>

                    <p><strong>Premise decomposition:</strong> northeast-southwest is north of southeast-northwest</p>

                    <p><strong>Left side (northeast-southwest):</strong></p>
                    <ul style="margin-left: 20px; color: #aaa;">
                        <li><strong>Seed:</strong> "Memory" (retained experience)</li>
                        <li><strong>Apply NE (elevated sibling):</strong> Memory ‚Üí <strong>"Knowledge"</strong> (abstract parallel‚Äîtranscendent retention)</li>
                        <li><strong>Apply SW (material antithesis):</strong> Knowledge ‚Üí <strong>"Ignorance"</strong> (physical embodiment of knowledge's opposite‚Äîabsence of knowing)</li>
                        <li><strong>Result:</strong> northeast-southwest = <strong>"Ignorance"</strong></li>
                    </ul>

                    <p><strong>Right side (southeast-northwest):</strong></p>
                    <ul style="margin-left: 20px; color: #aaa;">
                        <li><strong>Seed:</strong> "Thought" (mental activity)</li>
                        <li><strong>Apply SE (grounded parallel):</strong> Thought ‚Üí <strong>"Cognition"</strong> (material sibling‚Äîphysical brain process)</li>
                        <li><strong>Apply NW (transcendent antithesis):</strong> Cognition ‚Üí <strong>"Emptiness"</strong> (abstract negation‚Äîvoid of mental content)</li>
                        <li><strong>Result:</strong> southeast-northwest = <strong>"Emptiness"</strong></li>
                    </ul>

                    <p><strong>Meta-relation verification:</strong></p>
                    <p style="margin-left: 20px;">Is "Ignorance" north of "Emptiness"?<br>
                    Is Ignorance a generalization/intensification of Emptiness?<br>
                    <strong>My judgment:</strong> YES. Ignorance is the populated void‚Äîfilled with wrong information, misconceptions. Emptiness is pure absence. Ignorance is "larger," more complex‚Äîit's Emptiness with content. Ignorance encompasses and exceeds Emptiness.</p>

                    <p><strong>N-2-back comparison:</strong> Compare to Trial 3<br>
                    Trial 3 judgment: MATCH | Trial 5 judgment: MATCH<br>
                    <strong>Both MATCH ‚Üí Correct response: MATCH</strong></p>
                    <p style="color: #2ecc71; font-weight: bold;">N-BACK ANSWER: MATCH ‚úì</p>
                    </div>

                    <div class="sandbox-journal-entry">
                    <h5 style="color: #e94560; margin-bottom: 8px;">Trial 6: "southwest-northeast is east of northwest-southeast"</h5>

                    <p><strong>Premise decomposition:</strong> southwest-northeast is east of northwest-southeast</p>

                    <p><strong>Left side (southwest-northeast):</strong></p>
                    <ul style="margin-left: 20px; color: #aaa;">
                        <li><strong>Seed:</strong> "Power" (capacity to act)</li>
                        <li><strong>Apply SW (material antithesis):</strong> Power ‚Üí <strong>"Weakness"</strong> (physical embodiment of power's opposite)</li>
                        <li><strong>Apply NE (elevated sibling):</strong> Weakness ‚Üí <strong>"Vulnerability"</strong> (abstract parallel‚Äîtranscendent openness)</li>
                        <li><strong>Result:</strong> southwest-northeast = <strong>"Vulnerability"</strong></li>
                    </ul>

                    <p><strong>Right side (northwest-southeast):</strong></p>
                    <ul style="margin-left: 20px; color: #aaa;">
                        <li><strong>Seed:</strong> "Dominance" (control over others)</li>
                        <li><strong>Apply NW (transcendent antithesis):</strong> Dominance ‚Üí <strong>"Submission"</strong> (abstract negation)</li>
                        <li><strong>Apply SE (grounded parallel):</strong> Submission ‚Üí <strong>"Compliance"</strong> (material sibling‚Äîphysical yielding)</li>
                        <li><strong>Result:</strong> northwest-southeast = <strong>"Compliance"</strong></li>
                    </ul>

                    <p><strong>Meta-relation verification:</strong></p>
                    <p style="margin-left: 20px;">Is "Vulnerability" east of "Compliance"?<br>
                    Is Vulnerability an analogue/parallel role to Compliance?<br>
                    <strong>My judgment:</strong> NO. Vulnerability is the capacity to be wounded‚Äîan openness. Compliance is following orders‚Äîa behavior. They're not siblings. Vulnerability can exist without compliance; they operate in different domains. This premise fails.</p>

                    <p><strong>N-2-back comparison:</strong> Compare to Trial 4<br>
                    Trial 4 judgment: NO MATCH | Trial 6 judgment: NO MATCH<br>
                    <strong>Both NO MATCH ‚Üí Correct response: MATCH</strong></p>
                    <p style="color: #2ecc71; font-weight: bold;">N-BACK ANSWER: MATCH ‚úì</p>
                    </div>

                    <div class="sandbox-journal-entry">
                    <h5 style="color: #e94560; margin-bottom: 8px;">Trial 7: "southeast-northwest is west of northeast-southwest"</h5>

                    <p><strong>Premise decomposition:</strong> southeast-northwest is west of northeast-southwest</p>

                    <p><strong>Left side (southeast-northwest):</strong></p>
                    <ul style="margin-left: 20px; color: #aaa;">
                        <li><strong>Seed:</strong> "Desire" (wanting state)</li>
                        <li><strong>Apply SE (grounded parallel):</strong> Desire ‚Üí <strong>"Craving"</strong> (material sibling‚Äîphysical hunger)</li>
                        <li><strong>Apply NW (transcendent antithesis):</strong> Craving ‚Üí <strong>"Satiation"</strong> (abstract negation‚Äîfulfilled state)</li>
                        <li><strong>Result:</strong> southeast-northwest = <strong>"Satiation"</strong></li>
                    </ul>

                    <p><strong>Right side (northeast-southwest):</strong></p>
                    <ul style="margin-left: 20px; color: #aaa;">
                        <li><strong>Seed:</strong> "Aspiration" (upward striving)</li>
                        <li><strong>Apply NE (elevated sibling):</strong> Aspiration ‚Üí <strong>"Ambition"</strong> (abstract parallel‚Äîtranscendent drive)</li>
                        <li><strong>Apply SW (material antithesis):</strong> Ambition ‚Üí <strong>"Contentment"</strong> (physical embodiment of ambition's opposite‚Äîsettled satisfaction)</li>
                        <li><strong>Result:</strong> northeast-southwest = <strong>"Contentment"</strong></li>
                    </ul>

                    <p><strong>Meta-relation verification:</strong></p>
                    <p style="margin-left: 20px;">Is "Satiation" west of "Contentment"?<br>
                    Is Satiation the opposite/antithesis of Contentment?<br>
                    <strong>My judgment:</strong> NO. They're actually siblings! Satiation is temporary fullness; Contentment is sustained peace. They're both "fulfilled" states, just different flavors. They're parallels, not opposites. The premise fails.</p>

                    <p><strong>N-2-back comparison:</strong> Compare to Trial 5<br>
                    Trial 5 judgment: MATCH | Trial 7 judgment: NO MATCH<br>
                    <strong>One MATCH, one NO MATCH ‚Üí Correct response: NO MATCH</strong></p>
                    <p style="color: #e67e22; font-weight: bold;">N-BACK ANSWER: NO MATCH ‚úì</p>
                    </div>

                    <div class="sandbox-journal-entry">
                    <h5 style="color: #e94560; margin-bottom: 8px;">Trial 8: "northwest-southeast is north of southwest-northeast"</h5>

                    <p><strong>Premise decomposition:</strong> northwest-southeast is north of southwest-northeast</p>

                    <p><strong>Left side (northwest-southeast):</strong></p>
                    <ul style="margin-left: 20px; color: #aaa;">
                        <li><strong>Seed:</strong> "Trust" (relational confidence)</li>
                        <li><strong>Apply NW (transcendent antithesis):</strong> Trust ‚Üí <strong>"Suspicion"</strong> (abstract negation)</li>
                        <li><strong>Apply SE (grounded parallel):</strong> Suspicion ‚Üí <strong>"Wariness"</strong> (material sibling‚Äîphysical caution)</li>
                        <li><strong>Result:</strong> northwest-southeast = <strong>"Wariness"</strong></li>
                    </ul>

                    <p><strong>Right side (southwest-northeast):</strong></p>
                    <ul style="margin-left: 20px; color: #aaa;">
                        <li><strong>Seed:</strong> "Security" (safe condition)</li>
                        <li><strong>Apply SW (material antithesis):</strong> Security ‚Üí <strong>"Danger"</strong> (physical embodiment of security's opposite)</li>
                        <li><strong>Apply NE (elevated sibling):</strong> Danger ‚Üí <strong>"Risk"</strong> (abstract parallel‚Äîtranscendent uncertainty)</li>
                        <li><strong>Result:</strong> southwest-northeast = <strong>"Risk"</strong></li>
                    </ul>

                    <p><strong>Meta-relation verification:</strong></p>
                    <p style="margin-left: 20px;">Is "Wariness" north of "Risk"?<br>
                    Is Wariness a generalization/intensification of Risk?<br>
                    <strong>My judgment:</strong> NO. Risk is the abstract possibility of harm. Wariness is the embodied response to risk. Risk is actually MORE general‚Äîit's the condition that CREATES wariness. The hierarchy is inverted. Premise fails.</p>

                    <p><strong>N-2-back comparison:</strong> Compare to Trial 6<br>
                    Trial 6 judgment: NO MATCH | Trial 8 judgment: NO MATCH<br>
                    <strong>Both NO MATCH ‚Üí Correct response: MATCH</strong></p>
                    <p style="color: #2ecc71; font-weight: bold;">N-BACK ANSWER: MATCH ‚úì</p>
                    </div>

                    <div class="sandbox-journal-entry">
                    <h5 style="color: #e94560; margin-bottom: 8px;">Trial 9: "northeast-southwest is east of southeast-northwest"</h5>

                    <p><strong>Premise decomposition:</strong> northeast-southwest is east of southeast-northwest</p>

                    <p><strong>Left side (northeast-southwest):</strong></p>
                    <ul style="margin-left: 20px; color: #aaa;">
                        <li><strong>Seed:</strong> "Perception" (sensory intake)</li>
                        <li><strong>Apply NE (elevated sibling):</strong> Perception ‚Üí <strong>"Interpretation"</strong> (abstract parallel‚Äîmental processing)</li>
                        <li><strong>Apply SW (material antithesis):</strong> Interpretation ‚Üí <strong>"Misperception"</strong> (physical embodiment of interpretation's opposite‚Äîdistorted seeing)</li>
                        <li><strong>Result:</strong> northeast-southwest = <strong>"Misperception"</strong></li>
                    </ul>

                    <p><strong>Right side (southeast-northwest):</strong></p>
                    <ul style="margin-left: 20px; color: #aaa;">
                        <li><strong>Seed:</strong> "Observation" (witnessing act)</li>
                        <li><strong>Apply SE (grounded parallel):</strong> Observation ‚Üí <strong>"Monitoring"</strong> (material sibling‚Äîsustained watching)</li>
                        <li><strong>Apply NW (transcendent antithesis):</strong> Monitoring ‚Üí <strong>"Blindness"</strong> (abstract negation‚Äîabsence of sight)</li>
                        <li><strong>Result:</strong> southeast-northwest = <strong>"Blindness"</strong></li>
                    </ul>

                    <p><strong>Meta-relation verification:</strong></p>
                    <p style="margin-left: 20px;">Is "Misperception" east of "Blindness"?<br>
                    Is Misperception an analogue/parallel role to Blindness?<br>
                    <strong>My judgment:</strong> YES. Both are failures of seeing. Misperception sees wrongly; Blindness doesn't see at all. They're siblings in the domain of "seeing-failure"‚Äîdifferent modes of not-seeing-correctly. They play parallel roles in epistemological breakdown.</p>

                    <p><strong>N-2-back comparison:</strong> Compare to Trial 7<br>
                    Trial 7 judgment: NO MATCH | Trial 9 judgment: MATCH<br>
                    <strong>One NO MATCH, one MATCH ‚Üí Correct response: NO MATCH</strong></p>
                    <p style="color: #e67e22; font-weight: bold;">N-BACK ANSWER: NO MATCH ‚úì</p>
                    </div>

                    <div class="sandbox-journal-entry">
                    <h5 style="color: #e94560; margin-bottom: 8px;">Trial 10: "southwest-northeast is south of northwest-southeast"</h5>

                    <p><strong>Premise decomposition:</strong> southwest-northeast is south of northwest-southeast</p>

                    <p><strong>Left side (southwest-northeast):</strong></p>
                    <ul style="margin-left: 20px; color: #aaa;">
                        <li><strong>Seed:</strong> "Love" (connective force)</li>
                        <li><strong>Apply SW (material antithesis):</strong> Love ‚Üí <strong>"Hatred"</strong> (physical embodiment of love's opposite)</li>
                        <li><strong>Apply NE (elevated sibling):</strong> Hatred ‚Üí <strong>"Resentment"</strong> (abstract parallel‚Äîtranscendent bitterness)</li>
                        <li><strong>Result:</strong> southwest-northeast = <strong>"Resentment"</strong></li>
                    </ul>

                    <p><strong>Right side (northwest-southeast):</strong></p>
                    <ul style="margin-left: 20px; color: #aaa;">
                        <li><strong>Seed:</strong> "Connection" (relational bond)</li>
                        <li><strong>Apply NW (transcendent antithesis):</strong> Connection ‚Üí <strong>"Alienation"</strong> (abstract negation)</li>
                        <li><strong>Apply SE (grounded parallel):</strong> Alienation ‚Üí <strong>"Isolation"</strong> (material sibling‚Äîphysical separation)</li>
                        <li><strong>Result:</strong> northwest-southeast = <strong>"Isolation"</strong></li>
                    </ul>

                    <p><strong>Meta-relation verification:</strong></p>
                    <p style="margin-left: 20px;">Is "Resentment" south of "Isolation"?<br>
                    Is Resentment a specification/concretization of Isolation?<br>
                    <strong>My judgment:</strong> YES. Isolation is the broader condition‚Äîbeing separate. Resentment is a specific emotional state that can emerge FROM isolation‚Äîthe bitter feeling within separateness. Resentment is the materialized, specific form; Isolation is the general condition. The premise holds.</p>

                    <p><strong>N-2-back comparison:</strong> Compare to Trial 8<br>
                    Trial 8 judgment: NO MATCH | Trial 10 judgment: MATCH<br>
                    <strong>One NO MATCH, one MATCH ‚Üí Correct response: NO MATCH</strong></p>
                    <p style="color: #e67e22; font-weight: bold;">N-BACK ANSWER: NO MATCH ‚úì</p>
                    </div>

                    </div>

                    <h4>Summary of Results</h4>
                    <table style="width: 100%; border-collapse: collapse; margin: 20px 0; font-size: 0.9rem;">
                        <tr style="background: rgba(52, 152, 219, 0.2);">
                            <th style="padding: 8px; border: 1px solid #555;">Trial</th>
                            <th style="padding: 8px; border: 1px solid #555;">Premise Judgment</th>
                            <th style="padding: 8px; border: 1px solid #555;">N-2 Comparison</th>
                            <th style="padding: 8px; border: 1px solid #555;">N-Back Answer</th>
                        </tr>
                        <tr>
                            <td style="padding: 8px; border: 1px solid #555;">1</td>
                            <td style="padding: 8px; border: 1px solid #555;">MATCH</td>
                            <td style="padding: 8px; border: 1px solid #555;">N/A</td>
                            <td style="padding: 8px; border: 1px solid #555;">‚Äî</td>
                        </tr>
                        <tr>
                            <td style="padding: 8px; border: 1px solid #555;">2</td>
                            <td style="padding: 8px; border: 1px solid #555;">MATCH</td>
                            <td style="padding: 8px; border: 1px solid #555;">N/A</td>
                            <td style="padding: 8px; border: 1px solid #555;">‚Äî</td>
                        </tr>
                        <tr>
                            <td style="padding: 8px; border: 1px solid #555;">3</td>
                            <td style="padding: 8px; border: 1px solid #555;">MATCH</td>
                            <td style="padding: 8px; border: 1px solid #555;">Trial 1: MATCH</td>
                            <td style="padding: 8px; border: 1px solid #555; color: #2ecc71; font-weight: bold;">MATCH ‚úì</td>
                        </tr>
                        <tr>
                            <td style="padding: 8px; border: 1px solid #555;">4</td>
                            <td style="padding: 8px; border: 1px solid #555;">NO MATCH</td>
                            <td style="padding: 8px; border: 1px solid #555;">Trial 2: MATCH</td>
                            <td style="padding: 8px; border: 1px solid #555; color: #e67e22; font-weight: bold;">NO MATCH ‚úì</td>
                        </tr>
                        <tr>
                            <td style="padding: 8px; border: 1px solid #555;">5</td>
                            <td style="padding: 8px; border: 1px solid #555;">MATCH</td>
                            <td style="padding: 8px; border: 1px solid #555;">Trial 3: MATCH</td>
                            <td style="padding: 8px; border: 1px solid #555; color: #2ecc71; font-weight: bold;">MATCH ‚úì</td>
                        </tr>
                        <tr>
                            <td style="padding: 8px; border: 1px solid #555;">6</td>
                            <td style="padding: 8px; border: 1px solid #555;">NO MATCH</td>
                            <td style="padding: 8px; border: 1px solid #555;">Trial 4: NO MATCH</td>
                            <td style="padding: 8px; border: 1px solid #555; color: #2ecc71; font-weight: bold;">MATCH ‚úì</td>
                        </tr>
                        <tr>
                            <td style="padding: 8px; border: 1px solid #555;">7</td>
                            <td style="padding: 8px; border: 1px solid #555;">NO MATCH</td>
                            <td style="padding: 8px; border: 1px solid #555;">Trial 5: MATCH</td>
                            <td style="padding: 8px; border: 1px solid #555; color: #e67e22; font-weight: bold;">NO MATCH ‚úì</td>
                        </tr>
                        <tr>
                            <td style="padding: 8px; border: 1px solid #555;">8</td>
                            <td style="padding: 8px; border: 1px solid #555;">NO MATCH</td>
                            <td style="padding: 8px; border: 1px solid #555;">Trial 6: NO MATCH</td>
                            <td style="padding: 8px; border: 1px solid #555; color: #2ecc71; font-weight: bold;">MATCH ‚úì</td>
                        </tr>
                        <tr>
                            <td style="padding: 8px; border: 1px solid #555;">9</td>
                            <td style="padding: 8px; border: 1px solid #555;">MATCH</td>
                            <td style="padding: 8px; border: 1px solid #555;">Trial 7: NO MATCH</td>
                            <td style="padding: 8px; border: 1px solid #555; color: #e67e22; font-weight: bold;">NO MATCH ‚úì</td>
                        </tr>
                        <tr>
                            <td style="padding: 8px; border: 1px solid #555;">10</td>
                            <td style="padding: 8px; border: 1px solid #555;">MATCH</td>
                            <td style="padding: 8px; border: 1px solid #555;">Trial 8: NO MATCH</td>
                            <td style="padding: 8px; border: 1px solid #555; color: #e67e22; font-weight: bold;">NO MATCH ‚úì</td>
                        </tr>
                    </table>

                    <h4>Key Insights from This Walkthrough</h4>
                    <ul>
                        <li><strong>Diagonal semantics are compositional:</strong> NE = "elevated sibling" consistently means "abstract parallel"‚Äîcombining North's generalization with East's analogue</li>
                        <li><strong>Vivid seeds enable transformation:</strong> Starting with concrete concepts like "Attention," "Hope," "Trust" makes the compound operators feel real and traceable</li>
                        <li><strong>Consistency maintenance is paramount:</strong> If SW = "material antithesis," it MUST mean that across all trials. Any variation breaks the system</li>
                        <li><strong>Meta-relations require semantic reasoning:</strong> "Is X north of Y?" has no formal answer‚ÄîYOU decide based on your phenomenological model</li>
                        <li><strong>N-back recall is the true challenge:</strong> Remembering your judgments from 2 trials ago while processing new transformations taxes working memory maximally</li>
                    </ul>

                    <h4>Tips for Maintaining Your 8-Direction Model</h4>
                    <ul>
                        <li><strong>Write your diagonal definitions:</strong> Before session 1, document NE, SE, SW, NW meanings. Keep them visible initially.</li>
                        <li><strong>Use sensory imagery:</strong> Don't just think "abstract parallel"‚ÄîSEE the transformation happening. Visualize Attention ‚Üí Vigilance ‚Üí Distraction as a movie.</li>
                        <li><strong>Rehearse compound sequences:</strong> Practice SW-NE offline: "Material antithesis, then elevated sibling." Speak it aloud until automatic.</li>
                        <li><strong>Track your judgment patterns:</strong> Notice if you're biased toward MATCH or NO MATCH. Aim for ~50/50 distribution to maximize challenge.</li>
                        <li><strong>Accept semantic ambiguity:</strong> There's no "right" answer. Your model is valid if it's CONSISTENT and COHERENT across trials.</li>
                        <li><strong>Gradually internalize:</strong> After 5-10 sessions, remove your written reference. By session 20, your 8-direction model should be automatic.</li>
                    </ul>

                    <h4>How to Practice This Method</h4>
                    <ol>
                        <li>Enable Level 8 in controls: Check <strong>"Force 8-Direction Compound Operator Trials (Level 8: Octo-Leap)"</strong></li>
                        <li>Start conservatively: n=2, k=1, 10 trials (exactly like this walkthrough)</li>
                        <li>Define your diagonals: Write down your NE, SE, SW, NW interpretations BEFORE clicking Start</li>
                        <li>Apply this method: For each premise, pick vivid seeds, apply transformations cinematically, evaluate meta-relations phenomenologically</li>
                        <li>Track your sessions: After each session, review your judgment consistency. Did your diagonal meanings stay coherent?</li>
                        <li>Gradually increase difficulty: Once comfortable at n=2, k=1, try n=3, k=2, then n=4, k=3</li>
                    </ol>

                    <p style="color: #e94560; font-weight: bold; margin-top: 20px;">Remember: Level 8 is not about "getting it right." It's about training your mind to maintain a complex, generative semantic system under cognitive load. The transformation IS the training.</p>
                `,
                speech: 'Level Eight Instructions: Imaginative Abstraction Method. Introduction: The Generative Imagination Engine. Level eight demands that you become an architect of meaning. You will invent a complete eight-direction semantic system using vivid, sensory-rich transformations. This tutorial demonstrates the imaginative abstraction method through a complete n-2-back walkthrough. Core principle: Start with a living, breathing seed concept. Apply compound transformations as if you are watching a movie in your mind. Each direction becomes a creative force that reshapes your mental image. The Eight-Direction Invention System. Cardinal Directions, Given: North: up-shift, generalization, expansion, intensification. South: down-shift, specification, reduction, materialization. East: analogue, parallel role, sibling concept, lateral shift. West: opposite, antithesis, negation, mirror inverse. Diagonal Directions, Your Invention: Northeast equals N plus E: Generalize an analogue. Elevated sibling, abstract parallel, transcendent variant. Southeast equals S plus E: Concretize an analogue. Grounded parallel, physical twin, material sibling. Southwest equals S plus W: Concretize an opposite. Material antithesis, physical negation, embodied counter. Northwest equals N plus W: Generalize an opposite. Abstract negation, transcendent antithesis, ideological inverse. Theme for This Walkthrough: Forces of Consciousness. We will use states of consciousness, cognitive forces, and phenomenological experiences as our seed concepts. Each transformation will create vivid mental imagery. This walkthrough demonstrates ten trials of n-2-back using the Forces of Consciousness theme. Each trial shows seed concept selection, compound transformation application, meta-relation evaluation, and n-back comparison. The walkthrough achieves five correct MATCH responses and five correct NO MATCH responses, demonstrating balanced judgment distribution. Key Insights: Diagonal semantics are compositional. NE equals elevated sibling consistently means abstract parallel, combining North\'s generalization with East\'s analogue. Vivid seeds enable transformation. Starting with concrete concepts like Attention, Hope, Trust makes the compound operators feel real and traceable. Consistency maintenance is paramount. If SW equals material antithesis, it must mean that across all trials. Any variation breaks the system. Meta-relations require semantic reasoning. Is X north of Y has no formal answer. You decide based on your phenomenological model. N-back recall is the true challenge. Remembering your judgments from two trials ago while processing new transformations taxes working memory maximally. Tips for Maintaining Your Eight-Direction Model: Write your diagonal definitions before session one. Document NE, SE, SW, NW meanings. Keep them visible initially. Use sensory imagery. Do not just think abstract parallel. See the transformation happening. Visualize transformations as a movie. Rehearse compound sequences. Practice SW-NE offline: Material antithesis, then elevated sibling. Speak it aloud until automatic. Track your judgment patterns. Notice if you are biased toward MATCH or NO MATCH. Aim for fifty-fifty distribution to maximize challenge. Accept semantic ambiguity. There is no right answer. Your model is valid if it is consistent and coherent across trials. Gradually internalize. After five to ten sessions, remove your written reference. By session twenty, your eight-direction model should be automatic. How to Practice This Method: Enable Level eight in controls by checking Force Eight-Direction Compound Operator Trials, Level eight Octo-Leap. Start conservatively: n equals two, k equals one, ten trials, exactly like this walkthrough. Define your diagonals: Write down your NE, SE, SW, NW interpretations before clicking Start. Apply this method: For each premise, pick vivid seeds, apply transformations cinematically, evaluate meta-relations phenomenologically. Track your sessions: After each session, review your judgment consistency. Did your diagonal meanings stay coherent? Gradually increase difficulty: Once comfortable at n equals two, k equals one, try n equals three, k equals two, then n equals four, k equals three. Remember: Level eight is not about getting it right. It is about training your mind to maintain a complex, generative semantic system under cognitive load. The transformation is the training.'
            },
            {
                id: 'level9',
                title: 'Level 9: 16-Direction Triple-Nested Compositional Invention (Hexa-Leap)',
                html: `
                    <h3>Level 9: 16-Direction Triple-Nested Compositional Invention (Hexa-Leap)</h3>
                    <p>This is the <strong>apex of cognitive training</strong>‚Äîthe ultimate expansion of spatial reasoning, generative semantics, and working memory into a 16-direction, triple-compound operator system.</p>

                    <h4>The Concept: Triple-Nested Compositional Invention</h4>
                    <p>Level 9 premises look like this:</p>
                    <p style="text-align: center; font-size: 1.2rem; color: #8b00ff; margin: 20px 0;"><code>"NNE-ESE-SSW is north of ENE-SSE-WSW"</code></p>

                    <p>This combines:</p>
                    <ul>
                        <li><strong>16-direction operators:</strong> N, NNE, NE, ENE, E, ESE, SE, SSE, S, SSW, SW, WSW, W, WNW, NW, NNW</li>
                        <li><strong>Triple-compound sequences:</strong> Three DIFFERENT operators per compound (3,360 possible combinations: 16√ó15√ó14)</li>
                        <li><strong>8-direction meta-operators:</strong> Meta-relationships use all 8 directions (N, NE, E, SE, S, SW, W, NW) - diagonal progression from Level 8</li>
                        <li><strong>Generative 12-direction invention:</strong> YOU invent meanings for 12 intermediate directions (all except N, E, S, W)</li>
                        <li><strong>Triple-nested transformation chains:</strong> Apply THREE sequential transformations per compound</li>
                    </ul>

                    <h4>The 16 Directions</h4>
                    <p><strong>Cardinal Directions (Given):</strong></p>
                    <ul>
                        <li><strong>N (North):</strong> Up-shift, generalization, abstraction</li>
                        <li><strong>E (East):</strong> Analogue, sibling, parallel role</li>
                        <li><strong>S (South):</strong> Down-shift, specification, concretization</li>
                        <li><strong>W (West):</strong> Opposite, antonym, counter-role</li>
                    </ul>

                    <p><strong>Intermediate Directions (YOUR INVENTION):</strong></p>
                    <p>You must invent coherent meanings for 12 directions. Here's a compositional framework:</p>
                    <ul>
                        <li><strong>NNE:</strong> "North+North+East" = Double up-shift + analogue = Highly abstract sibling</li>
                        <li><strong>NE:</strong> "North+East" = Up-shift + analogue = Abstract sibling (from Level 8)</li>
                        <li><strong>ENE:</strong> "East+North+East" = Analogue + up-shift + analogue = Lateral then elevated parallel</li>
                        <li><strong>ESE:</strong> "East+South+East" = Analogue + down-shift + analogue = Lateral then grounded parallel</li>
                        <li><strong>SE:</strong> "South+East" = Down-shift + analogue = Concrete sibling (from Level 8)</li>
                        <li><strong>SSE:</strong> "South+South+East" = Double down-shift + analogue = Highly concrete sibling</li>
                        <li><strong>SSW:</strong> "South+South+West" = Double down-shift + opposite = Highly concrete opposite</li>
                        <li><strong>SW:</strong> "South+West" = Down-shift + opposite = Concrete opposite (from Level 8)</li>
                        <li><strong>WSW:</strong> "West+South+West" = Opposite + down-shift + opposite = Counter-role then grounded inversion</li>
                        <li><strong>WNW:</strong> "West+North+West" = Opposite + up-shift + opposite = Counter-role then elevated inversion</li>
                        <li><strong>NW:</strong> "North+West" = Up-shift + opposite = Abstract opposite (from Level 8)</li>
                        <li><strong>NNW:</strong> "North+North+West" = Double up-shift + opposite = Highly abstract opposite</li>
                    </ul>

                    <p><strong>Critical insight:</strong> The compositional framework above is ONE possible system. You can invent your own. The training comes from maintaining YOUR system coherently across trials.</p>

                    <h4>How It Works (Purely Mental)</h4>
                    <p><strong>Example:</strong> "NNE-ESE-SSW is north of ENE-SSE-WSW"</p>

                    <ol>
                        <li><strong>Pick a seed concept:</strong> "Order"</li>
                        <li><strong>Apply NNE:</strong> Highly abstract sibling of Order ‚Üí "Harmony"</li>
                        <li><strong>Apply ESE:</strong> Lateral then grounded parallel of Harmony ‚Üí "Rhythm"</li>
                        <li><strong>Apply SSW:</strong> Highly concrete opposite of Rhythm ‚Üí "Chaos"</li>
                        <li><strong>Result: NNE-ESE-SSW = "Chaos"</strong></li>
                        <li><strong>Pick new seed:</strong> "Plan"</li>
                        <li><strong>Apply ENE:</strong> Lateral then elevated parallel of Plan ‚Üí "Strategy"</li>
                        <li><strong>Apply SSE:</strong> Highly concrete sibling of Strategy ‚Üí "Tactic"</li>
                        <li><strong>Apply WSW:</strong> Counter-role then grounded inversion of Tactic ‚Üí "Improvisation"</li>
                        <li><strong>Result: ENE-SSE-WSW = "Improvisation"</strong></li>
                        <li><strong>Evaluate meta-relationship:</strong> Is Chaos north of Improvisation?</li>
                        <li><strong>Your judgment decides:</strong> MATCH or NO MATCH</li>
                    </ol>

                    <h4>Why This is Beyond All Previous Levels</h4>
                    <p>Level 9 adds cognitive demands beyond Level 8:</p>
                    <ol>
                        <li><strong>16-way spatial model:</strong> Double the directional complexity of Level 8</li>
                        <li><strong>12 new operator definitions:</strong> Invent meanings for NNE, ENE, ESE, SSE, SSW, WSW, WNW, NNW (plus the 4 diagonals from Level 8)</li>
                        <li><strong>Triple-nested composition:</strong> Three sequential transformations per compound (vs. two in Level 8)</li>
                        <li><strong>Combinatorial explosion:</strong> 3,360 possible compounds (vs. 56 in Level 8, 60√ó increase)</li>
                        <li><strong>Working memory expansion:</strong> Track three transformation steps mentally</li>
                        <li><strong>Fine-grained directional reasoning:</strong> Distinguish between NE (abstract sibling) and NNE (highly abstract sibling)</li>
                        <li><strong>All Level 8 demands:</strong> Generative semantics, semantic anchoring, meta-reasoning, n-back recall</li>
                    </ol>

                    <h4>Tips for Success</h4>
                    <ul>
                        <li><strong>Build on Level 8 mastery:</strong> Only attempt Level 9 after mastering 8-direction reasoning</li>
                        <li><strong>Define all 12 directions early:</strong> Write down your complete 16-direction system before starting</li>
                        <li><strong>Use compositional logic:</strong> NNE = N+N+E helps maintain consistency</li>
                        <li><strong>Practice triple chains offline:</strong> Test NNE-ESE-SSW sequences on paper first</li>
                        <li><strong>Visualize each step:</strong> Don't skip any of the three transformations‚Äîsee each one happen</li>
                        <li><strong>Start extremely conservatively:</strong> n=2, k=1 for first 10+ sessions</li>
                        <li><strong>Track consistency rigorously:</strong> Did your 16-direction model hold coherent across all trials?</li>
                    </ul>

                    <h4>Example 16-Direction System (Compositional)</h4>
                    <p><strong>Fine-Grained Intensity Model:</strong></p>
                    <ul>
                        <li><strong>N ‚Üí NNE ‚Üí NE ‚Üí ENE ‚Üí E:</strong> "High abstract ‚Üí Very high abstract sibling ‚Üí High abstract sibling ‚Üí Moderately abstract sibling ‚Üí Sibling"</li>
                        <li><strong>E ‚Üí ESE ‚Üí SE ‚Üí SSE ‚Üí S:</strong> "Sibling ‚Üí Moderately concrete sibling ‚Üí Concrete sibling ‚Üí Very concrete sibling ‚Üí High concrete"</li>
                        <li><strong>S ‚Üí SSW ‚Üí SW ‚Üí WSW ‚Üí W:</strong> "High concrete ‚Üí Very concrete opposite ‚Üí Concrete opposite ‚Üí Moderately concrete opposite ‚Üí Opposite"</li>
                        <li><strong>W ‚Üí WNW ‚Üí NW ‚Üí NNW ‚Üí N:</strong> "Opposite ‚Üí Moderately abstract opposite ‚Üí Abstract opposite ‚Üí Very abstract opposite ‚Üí High abstract"</li>
                    </ul>

                    <h4>K Parameter in Level 9</h4>
                    <ul>
                        <li><strong>k=1:</strong> Single 16D triple-compound atom (recommended starting point)</li>
                        <li><strong>k=2:</strong> Two 16D triple-compound atoms (significant challenge)</li>
                        <li><strong>k=3:</strong> Three 16D triple-compound atoms (extreme challenge)</li>
                        <li><strong>k=4:</strong> Four 16D triple-compound atoms (maximum theoretical challenge)</li>
                    </ul>

                    <h4>How to Enable</h4>
                    <p>Check the <strong>"Force 16-Direction Triple-Compound Operator Trials (Level 9: Hexa-Leap)"</strong> checkbox in the controls panel before starting a session. This automatically disables Levels 6, 7, and 8 (they're mutually exclusive).</p>

                    <p><strong>Mandatory starting settings:</strong> n=2, k=1, 10 trials</p>
                    <p><strong>Advanced challenge (after 20+ sessions):</strong> n=3, k=2</p>
                    <p><strong>Theoretical maximum (after 50+ sessions):</strong> n=4, k=3</p>

                    <p style="color: #8b00ff; font-weight: bold; margin-top: 20px;">WARNING: Level 9 is the apex of cognitive training. It may feel impossible initially. Start with n=2, k=1 and expect months of practice before fluency. This level represents the absolute ceiling of human working memory and generative semantic capacity under n-back load.</p>
                `,
                speech: 'Level Nine: Sixteen-Direction Triple-Nested Compositional Invention, Hexa-Leap. This is the apex of cognitive training, the ultimate expansion of spatial reasoning, generative semantics, and working memory into a sixteen-direction, triple-compound operator system. The Concept, Triple-Nested Compositional Invention: Level nine premises look like this: NNE-ESE-SSW is north of ENE-SSE-WSW. This combines sixteen-direction operators: N, NNE, NE, ENE, E, ESE, SE, SSE, S, SSW, SW, WSW, W, WNW, NW, NNW. Triple-compound sequences: three different operators per compound, creating three thousand three hundred sixty possible combinations, sixteen times fifteen times fourteen. Meta-operators expanded to eight-directional: N, NE, E, SE, S, SW, W, NW, following Level eight\'s diagonal progression. Generative twelve-direction invention: you invent meanings for twelve intermediate directions, all except N, E, S, W. Triple-nested transformation chains: apply three sequential transformations per compound. The Sixteen Directions. Cardinal Directions, Given: North: up-shift, generalization, abstraction. East: analogue, sibling, parallel role. South: down-shift, specification, concretization. West: opposite, antonym, counter-role. Intermediate Directions, Your Invention: You must invent coherent meanings for twelve directions. Here is a compositional framework. NNE: North plus North plus East equals double up-shift plus analogue equals highly abstract sibling. NE: North plus East equals up-shift plus analogue equals abstract sibling, from Level eight. ENE: East plus North plus East equals analogue plus up-shift plus analogue equals lateral then elevated parallel. ESE: East plus South plus East equals analogue plus down-shift plus analogue equals lateral then grounded parallel. SE: South plus East equals down-shift plus analogue equals concrete sibling, from Level eight. SSE: South plus South plus East equals double down-shift plus analogue equals highly concrete sibling. SSW: South plus South plus West equals double down-shift plus opposite equals highly concrete opposite. SW: South plus West equals down-shift plus opposite equals concrete opposite, from Level eight. WSW: West plus South plus West equals opposite plus down-shift plus opposite equals counter-role then grounded inversion. WNW: West plus North plus West equals opposite plus up-shift plus opposite equals counter-role then elevated inversion. NW: North plus West equals up-shift plus opposite equals abstract opposite, from Level eight. NNW: North plus North plus West equals double up-shift plus opposite equals highly abstract opposite. Critical insight: The compositional framework above is one possible system. You can invent your own. The training comes from maintaining your system coherently across trials. How It Works, Purely Mental. Example: NNE-ESE-SSW is north of ENE-SSE-WSW. Pick a seed concept: Order. Apply NNE: Highly abstract sibling of Order is Harmony. Apply ESE: Lateral then grounded parallel of Harmony is Rhythm. Apply SSW: Highly concrete opposite of Rhythm is Chaos. Result: NNE-ESE-SSW equals Chaos. Pick new seed: Plan. Apply ENE: Lateral then elevated parallel of Plan is Strategy. Apply SSE: Highly concrete sibling of Strategy is Tactic. Apply WSW: Counter-role then grounded inversion of Tactic is Improvisation. Result: ENE-SSE-WSW equals Improvisation. Evaluate meta-relationship: Is Chaos north of Improvisation? Your judgment decides: MATCH or NO MATCH. Why This is Beyond All Previous Levels: Level nine adds cognitive demands beyond Level eight. Sixteen-way spatial model: double the directional complexity of Level eight. Twelve new operator definitions: invent meanings for NNE, ENE, ESE, SSE, SSW, WSW, WNW, NNW, plus the four diagonals from Level eight. Triple-nested composition: three sequential transformations per compound, versus two in Level eight. Combinatorial explosion: three thousand three hundred sixty possible compounds versus fifty-six in Level eight, sixty times increase. Working memory expansion: track three transformation steps mentally. Fine-grained directional reasoning: distinguish between NE, abstract sibling, and NNE, highly abstract sibling. Plus all Level eight demands: generative semantics, semantic anchoring, meta-reasoning, n-back recall. Tips for Success: Build on Level eight mastery. Only attempt Level nine after mastering eight-direction reasoning. Define all twelve directions early. Write down your complete sixteen-direction system before starting. Use compositional logic. NNE equals N plus N plus E helps maintain consistency. Practice triple chains offline. Test NNE-ESE-SSW sequences on paper first. Visualize each step. Do not skip any of the three transformations. See each one happen. Start extremely conservatively: n equals two, k equals one for first ten plus sessions. Track consistency rigorously. Did your sixteen-direction model hold coherent across all trials? How to Enable: Check the Force Sixteen-Direction Triple-Compound Operator Trials, Level nine Hexa-Leap, checkbox in the controls panel before starting a session. This disables Levels six, seven, and eight as they are mutually exclusive. Mandatory starting settings: n equals two, k equals one, ten trials. Advanced challenge after twenty plus sessions: n equals three, k equals two. Theoretical maximum after fifty plus sessions: n equals four, k equals three. Warning: Level nine is the apex of cognitive training. It may feel impossible initially. Start with n equals two, k equals one and expect months of practice before fluency. This level represents the absolute ceiling of human working memory and generative semantic capacity under n-back load.'
            },
            {
                id: 'level9-instructions',
                title: 'Level 9 Instructions: Triple-Nested Compositional Invention Method',
                html: `
                    <h3>Level 9 Instructions: Triple-Nested Compositional Invention Method</h3>

                    <h4>Introduction: The 16-Direction Generative Engine</h4>
                    <p>Level 9 is the <strong>apex of cognitive training</strong>‚Äîthe ultimate test of working memory, semantic invention, and spatial reasoning. You will create a complete 16-direction system and execute <strong>triple-nested transformation chains</strong> while maintaining n-back recall across trials.</p>

                    <p><strong>Core principle:</strong> Start with a vivid seed concept. Apply THREE sequential transformations using your 16-direction operator system. Each transformation must be compositionally coherent and phenomenologically rich. This tutorial demonstrates the method through a complete n-2-back walkthrough.</p>

                    <h4>The 16-Direction Invention System</h4>
                    <p><strong>Cardinal Directions (Given):</strong></p>
                    <ul>
                        <li><strong>N (North):</strong> Up-shift, generalization, abstraction, intensification</li>
                        <li><strong>S (South):</strong> Down-shift, specification, concretization, materialization</li>
                        <li><strong>E (East):</strong> Analogue, parallel role, sibling concept, lateral shift</li>
                        <li><strong>W (West):</strong> Opposite, antithesis, negation, mirror inverse</li>
                    </ul>

                    <p><strong>Intermediate Directions (Your Invention):</strong></p>
                    <p>You must define 12 additional directions using compositional logic:</p>
                    <ul>
                        <li><strong>NNE = N+N+E:</strong> Double up-shift + analogue ‚Üí Highly abstract sibling</li>
                        <li><strong>NE = N+E:</strong> Up-shift + analogue ‚Üí Abstract sibling (from Level 8)</li>
                        <li><strong>ENE = E+N+E:</strong> Analogue + up-shift + analogue ‚Üí Lateral then elevated parallel</li>
                        <li><strong>ESE = E+S+E:</strong> Analogue + down-shift + analogue ‚Üí Lateral then grounded parallel</li>
                        <li><strong>SE = S+E:</strong> Down-shift + analogue ‚Üí Concrete sibling (from Level 8)</li>
                        <li><strong>SSE = S+S+E:</strong> Double down-shift + analogue ‚Üí Highly concrete sibling</li>
                        <li><strong>SSW = S+S+W:</strong> Double down-shift + opposite ‚Üí Highly concrete opposite</li>
                        <li><strong>SW = S+W:</strong> Down-shift + opposite ‚Üí Concrete opposite (from Level 8)</li>
                        <li><strong>WSW = W+S+W:</strong> Opposite + down-shift + opposite ‚Üí Counter-role then grounded inversion</li>
                        <li><strong>WNW = W+N+W:</strong> Opposite + up-shift + opposite ‚Üí Counter-role then elevated inversion</li>
                        <li><strong>NW = N+W:</strong> Up-shift + opposite ‚Üí Abstract opposite (from Level 8)</li>
                        <li><strong>NNW = N+N+W:</strong> Double up-shift + opposite ‚Üí Highly abstract opposite</li>
                    </ul>

                    <h4>Meta-Operators: 8-Direction System</h4>
                    <p>The meta-relationship uses <strong>8 directions</strong> (all cardinals + all diagonals):</p>
                    <ul>
                        <li><strong>N, NE, E, SE, S, SW, W, NW</strong></li>
                    </ul>
                    <p>This is a diagonal progression from Level 8's 4-direction meta-operator system.</p>

                    <h4>Theme for This Walkthrough: Cognitive Architectures</h4>
                    <p>We'll use <strong>mental structures, cognitive processes, and modes of thinking</strong> as seed concepts. Each triple-nested chain will create vivid phenomenological transformations.</p>

                    <h4>10-Trial N-2-Back Walkthrough</h4>

                    <div class="sandbox-journal" style="max-height: none; background: rgba(22, 33, 62, 0.8); padding: 16px; margin: 16px 0;">

                    <div class="sandbox-journal-entry">
                    <h5 style="color: #8b00ff; margin-bottom: 8px;">Trial 1: "NNE-ESE-SSW is northeast of ENE-SSE-WSW"</h5>

                    <p><strong>Premise decomposition:</strong> NNE-ESE-SSW is northeast of ENE-SSE-WSW</p>

                    <p><strong>Left side (NNE-ESE-SSW):</strong></p>
                    <ul style="margin-left: 20px; color: #aaa;">
                        <li><strong>Seed:</strong> "Logic" (structured reasoning)</li>
                        <li><strong>Apply NNE (highly abstract sibling):</strong> Logic ‚Üí <strong>"Mathematics"</strong> (highly abstract parallel form of structured thought)</li>
                        <li><strong>Apply ESE (lateral then grounded parallel):</strong> Mathematics ‚Üí <strong>"Geometry"</strong> (grounded spatial sibling of mathematics)</li>
                        <li><strong>Apply SSW (highly concrete opposite):</strong> Geometry ‚Üí <strong>"Chaos"</strong> (material negation of geometric order‚Äîcomplete disorder)</li>
                        <li><strong>Result:</strong> NNE-ESE-SSW = <strong>"Chaos"</strong></li>
                    </ul>

                    <p><strong>Right side (ENE-SSE-WSW):</strong></p>
                    <ul style="margin-left: 20px; color: #aaa;">
                        <li><strong>Seed:</strong> "Reason" (rational thought)</li>
                        <li><strong>Apply ENE (lateral then elevated parallel):</strong> Reason ‚Üí <strong>"Philosophy"</strong> (parallel but elevated form of reasoning)</li>
                        <li><strong>Apply SSE (highly concrete sibling):</strong> Philosophy ‚Üí <strong>"Ethics"</strong> (grounded practical sibling of philosophy)</li>
                        <li><strong>Apply WSW (counter-role then grounded inversion):</strong> Ethics ‚Üí <strong>"Impulse"</strong> (material counter-role‚Äîopposite of ethical deliberation)</li>
                        <li><strong>Result:</strong> ENE-SSE-WSW = <strong>"Impulse"</strong></li>
                    </ul>

                    <p><strong>Meta-relation verification:</strong></p>
                    <p style="margin-left: 20px;">Is "Chaos" northeast of "Impulse"?<br>
                    Is Chaos an elevated sibling/abstract parallel of Impulse?<br>
                    <strong>My judgment:</strong> YES. Both are forms of disorder, but Chaos is the larger, more abstract concept. Impulse is individual momentary action; Chaos is systemic absence of order. Chaos generalizes what Impulse manifests. They're siblings in the disorder family, with Chaos as the transcendent form.</p>

                    <p><strong>N-2-back comparison:</strong> N/A (first trial)</p>
                    <p style="color: #2ecc71; font-weight: bold;">JUDGMENT: MATCH (premise holds true in my model)</p>
                    </div>

                    <div class="sandbox-journal-entry">
                    <h5 style="color: #8b00ff; margin-bottom: 8px;">Trial 2: "WSW-NNW-ENE is south of NW-SE-SSW"</h5>

                    <p><strong>Premise decomposition:</strong> WSW-NNW-ENE is south of NW-SE-SSW</p>

                    <p><strong>Left side (WSW-NNW-ENE):</strong></p>
                    <ul style="margin-left: 20px; color: #aaa;">
                        <li><strong>Seed:</strong> "Focus" (concentrated attention)</li>
                        <li><strong>Apply WSW (counter-role then grounded inversion):</strong> Focus ‚Üí <strong>"Distraction"</strong> (material opposite‚Äîscattered attention)</li>
                        <li><strong>Apply NNW (highly abstract opposite):</strong> Distraction ‚Üí <strong>"Mindfulness"</strong> (abstract inverse of distraction‚Äîpresent awareness)</li>
                        <li><strong>Apply ENE (lateral then elevated parallel):</strong> Mindfulness ‚Üí <strong>"Meditation"</strong> (elevated parallel practice of mindfulness)</li>
                        <li><strong>Result:</strong> WSW-NNW-ENE = <strong>"Meditation"</strong></li>
                    </ul>

                    <p><strong>Right side (NW-SE-SSW):</strong></p>
                    <ul style="margin-left: 20px; color: #aaa;">
                        <li><strong>Seed:</strong> "Control" (directed regulation)</li>
                        <li><strong>Apply NW (abstract opposite):</strong> Control ‚Üí <strong>"Freedom"</strong> (abstract inverse‚Äîabsence of constraint)</li>
                        <li><strong>Apply SE (concrete sibling):</strong> Freedom ‚Üí <strong>"Choice"</strong> (grounded parallel‚Äîembodied freedom)</li>
                        <li><strong>Apply SSW (highly concrete opposite):</strong> Choice ‚Üí <strong>"Compulsion"</strong> (material negation‚Äîabsence of choice)</li>
                        <li><strong>Result:</strong> NW-SE-SSW = <strong>"Compulsion"</strong></li>
                    </ul>

                    <p><strong>Meta-relation verification:</strong></p>
                    <p style="margin-left: 20px;">Is "Meditation" south of "Compulsion"?<br>
                    Is Meditation a specification/concretization of Compulsion?<br>
                    <strong>My judgment:</strong> NO. Meditation is a deliberate practice with structure and intention. Compulsion is driven, uncontrollable urge. Meditation is MORE refined, MORE intentional‚Äîit's actually north of Compulsion if anything. The premise reverses this hierarchy.</p>

                    <p><strong>N-2-back comparison:</strong> N/A (trial 2, need trial 0)</p>
                    <p style="color: #e67e22; font-weight: bold;">JUDGMENT: NO MATCH (premise contradicts my model)</p>
                    </div>

                    <div class="sandbox-journal-entry">
                    <h5 style="color: #8b00ff; margin-bottom: 8px;">Trial 3: "SSE-WNW-NE is west of ENE-SW-NNE"</h5>

                    <p><strong>Premise decomposition:</strong> SSE-WNW-NE is west of ENE-SW-NNE</p>

                    <p><strong>Left side (SSE-WNW-NE):</strong></p>
                    <ul style="margin-left: 20px; color: #aaa;">
                        <li><strong>Seed:</strong> "Memory" (retained experience)</li>
                        <li><strong>Apply SSE (highly concrete sibling):</strong> Memory ‚Üí <strong>"Habit"</strong> (grounded automatic sibling‚Äîembodied memory)</li>
                        <li><strong>Apply WNW (counter-role then elevated inversion):</strong> Habit ‚Üí <strong>"Novelty"</strong> (abstract opposite‚Äînew experience)</li>
                        <li><strong>Apply NE (abstract sibling):</strong> Novelty ‚Üí <strong>"Discovery"</strong> (elevated parallel‚Äîtranscendent newness)</li>
                        <li><strong>Result:</strong> SSE-WNW-NE = <strong>"Discovery"</strong></li>
                    </ul>

                    <p><strong>Right side (ENE-SW-NNE):</strong></p>
                    <ul style="margin-left: 20px; color: #aaa;">
                        <li><strong>Seed:</strong> "Knowledge" (accumulated understanding)</li>
                        <li><strong>Apply ENE (lateral then elevated parallel):</strong> Knowledge ‚Üí <strong>"Wisdom"</strong> (elevated parallel form‚Äîdeeper knowing)</li>
                        <li><strong>Apply SW (concrete opposite):</strong> Wisdom ‚Üí <strong>"Foolishness"</strong> (material antithesis‚Äîgrounded ignorance)</li>
                        <li><strong>Apply NNE (highly abstract sibling):</strong> Foolishness ‚Üí <strong>"Naivety"</strong> (highly abstract parallel‚Äîinnocent lack of knowing)</li>
                        <li><strong>Result:</strong> ENE-SW-NNE = <strong>"Naivety"</strong></li>
                    </ul>

                    <p><strong>Meta-relation verification:</strong></p>
                    <p style="margin-left: 20px;">Is "Discovery" west of "Naivety"?<br>
                    Is Discovery the opposite/antithesis of Naivety?<br>
                    <strong>My judgment:</strong> YES. Discovery requires active seeking and finding; Naivety is passive lack of knowledge. Discovery reveals truth; Naivety remains innocent of it. They're opposing forces in how we relate to knowledge.</p>

                    <p><strong>N-2-back comparison:</strong> Compare to Trial 1<br>
                    Trial 1 judgment: MATCH | Trial 3 judgment: MATCH<br>
                    <strong>Both MATCH ‚Üí Correct response: MATCH</strong></p>
                    <p style="color: #2ecc71; font-weight: bold;">N-BACK ANSWER: MATCH</p>
                    </div>

                    <div class="sandbox-journal-entry">
                    <h5 style="color: #8b00ff; margin-bottom: 8px;">Trial 4: "NE-SSW-ENE is southeast of WNW-ESE-NNW"</h5>

                    <p><strong>Premise decomposition:</strong> NE-SSW-ENE is southeast of WNW-ESE-NNW</p>

                    <p><strong>Left side (NE-SSW-ENE):</strong></p>
                    <ul style="margin-left: 20px; color: #aaa;">
                        <li><strong>Seed:</strong> "Analysis" (breaking down structure)</li>
                        <li><strong>Apply NE (abstract sibling):</strong> Analysis ‚Üí <strong>"Deconstruction"</strong> (elevated parallel‚Äîphilosophical analysis)</li>
                        <li><strong>Apply SSW (highly concrete opposite):</strong> Deconstruction ‚Üí <strong>"Synthesis"</strong> (material antithesis‚Äîbuilding up rather than breaking down)</li>
                        <li><strong>Apply ENE (lateral then elevated parallel):</strong> Synthesis ‚Üí <strong>"Integration"</strong> (elevated parallel‚Äîunified combining)</li>
                        <li><strong>Result:</strong> NE-SSW-ENE = <strong>"Integration"</strong></li>
                    </ul>

                    <p><strong>Right side (WNW-ESE-NNW):</strong></p>
                    <ul style="margin-left: 20px; color: #aaa;">
                        <li><strong>Seed:</strong> "Unity" (wholeness, oneness)</li>
                        <li><strong>Apply WNW (counter-role then elevated inversion):</strong> Unity ‚Üí <strong>"Division"</strong> (abstract opposite‚Äîseparation)</li>
                        <li><strong>Apply ESE (lateral then grounded parallel):</strong> Division ‚Üí <strong>"Partition"</strong> (grounded parallel‚Äîphysical division)</li>
                        <li><strong>Apply NNW (highly abstract opposite):</strong> Partition ‚Üí <strong>"Wholeness"</strong> (highly abstract inverse‚Äîcomplete integration)</li>
                        <li><strong>Result:</strong> WNW-ESE-NNW = <strong>"Wholeness"</strong></li>
                    </ul>

                    <p><strong>Meta-relation verification:</strong></p>
                    <p style="margin-left: 20px;">Is "Integration" southeast of "Wholeness"?<br>
                    Is Integration a concrete sibling of Wholeness?<br>
                    <strong>My judgment:</strong> YES. Integration is the active process of creating wholeness‚Äîit's the grounded, actionable parallel. Wholeness is the state; Integration is the method. They're siblings, with Integration as the concrete manifestation.</p>

                    <p><strong>N-2-back comparison:</strong> Compare to Trial 2<br>
                    Trial 2 judgment: NO MATCH | Trial 4 judgment: MATCH<br>
                    <strong>One MATCH, one NO MATCH ‚Üí Correct response: NO MATCH</strong></p>
                    <p style="color: #e67e22; font-weight: bold;">N-BACK ANSWER: NO MATCH</p>
                    </div>

                    <div class="sandbox-journal-entry">
                    <h5 style="color: #8b00ff; margin-bottom: 8px;">Trial 5: "NNE-ESE-SSW is northeast of ENE-SSE-WSW"</h5>

                    <p><strong>Premise decomposition:</strong> NNE-ESE-SSW is northeast of ENE-SSE-WSW (SAME AS TRIAL 1 STRUCTURE)</p>

                    <p><strong>Left side (NNE-ESE-SSW):</strong></p>
                    <ul style="margin-left: 20px; color: #aaa;">
                        <li><strong>Seed:</strong> "Abstraction" (conceptual removal from concrete)</li>
                        <li><strong>Apply NNE (highly abstract sibling):</strong> Abstraction ‚Üí <strong>"Theory"</strong> (highly abstract parallel‚Äîsystematic abstraction)</li>
                        <li><strong>Apply ESE (lateral then grounded parallel):</strong> Theory ‚Üí <strong>"Model"</strong> (grounded parallel‚Äîapplied theory)</li>
                        <li><strong>Apply SSW (highly concrete opposite):</strong> Model ‚Üí <strong>"Reality"</strong> (material opposite‚Äîactual vs. represented)</li>
                        <li><strong>Result:</strong> NNE-ESE-SSW = <strong>"Reality"</strong></li>
                    </ul>

                    <p><strong>Right side (ENE-SSE-WSW):</strong></p>
                    <ul style="margin-left: 20px; color: #aaa;">
                        <li><strong>Seed:</strong> "Concept" (mental construct)</li>
                        <li><strong>Apply ENE (lateral then elevated parallel):</strong> Concept ‚Üí <strong>"Idea"</strong> (elevated parallel‚Äîcreative concept)</li>
                        <li><strong>Apply SSE (highly concrete sibling):</strong> Idea ‚Üí <strong>"Plan"</strong> (grounded sibling‚Äîactionable idea)</li>
                        <li><strong>Apply WSW (counter-role then grounded inversion):</strong> Plan ‚Üí <strong>"Accident"</strong> (material counter-role‚Äîunplanned occurrence)</li>
                        <li><strong>Result:</strong> ENE-SSE-WSW = <strong>"Accident"</strong></li>
                    </ul>

                    <p><strong>Meta-relation verification:</strong></p>
                    <p style="margin-left: 20px;">Is "Reality" northeast of "Accident"?<br>
                    Is Reality an elevated sibling of Accident?<br>
                    <strong>My judgment:</strong> YES. Reality encompasses all events, including accidents. Reality is the larger abstract framework; Accident is a specific unplanned event within it. Reality is the transcendent category containing Accident as one manifestation.</p>

                    <p><strong>N-2-back comparison:</strong> Compare to Trial 3<br>
                    Trial 3 judgment: MATCH | Trial 5 judgment: MATCH<br>
                    <strong>Both MATCH ‚Üí Correct response: MATCH</strong></p>
                    <p style="color: #2ecc71; font-weight: bold;">N-BACK ANSWER: MATCH</p>
                    </div>

                    <div class="sandbox-journal-entry">
                    <h5 style="color: #8b00ff; margin-bottom: 8px;">Trial 6: "SW-NNE-WSW is southwest of SE-NW-ESE"</h5>

                    <p><strong>Premise decomposition:</strong> SW-NNE-WSW is southwest of SE-NW-ESE</p>

                    <p><strong>Left side (SW-NNE-WSW):</strong></p>
                    <ul style="margin-left: 20px; color: #aaa;">
                        <li><strong>Seed:</strong> "Clarity" (clear understanding)</li>
                        <li><strong>Apply SW (concrete opposite):</strong> Clarity ‚Üí <strong>"Confusion"</strong> (grounded antithesis‚Äîlack of clarity)</li>
                        <li><strong>Apply NNE (highly abstract sibling):</strong> Confusion ‚Üí <strong>"Mystery"</strong> (highly abstract parallel‚Äîtranscendent unknown)</li>
                        <li><strong>Apply WSW (counter-role then grounded inversion):</strong> Mystery ‚Üí <strong>"Revelation"</strong> (material counter-role‚Äîunveiled truth)</li>
                        <li><strong>Result:</strong> SW-NNE-WSW = <strong>"Revelation"</strong></li>
                    </ul>

                    <p><strong>Right side (SE-NW-ESE):</strong></p>
                    <ul style="margin-left: 20px; color: #aaa;">
                        <li><strong>Seed:</strong> "Truth" (accurate representation of reality)</li>
                        <li><strong>Apply SE (concrete sibling):</strong> Truth ‚Üí <strong>"Fact"</strong> (grounded parallel‚Äîspecific truth)</li>
                        <li><strong>Apply NW (abstract opposite):</strong> Fact ‚Üí <strong>"Fiction"</strong> (abstract antithesis‚Äîimagined rather than factual)</li>
                        <li><strong>Apply ESE (lateral then grounded parallel):</strong> Fiction ‚Üí <strong>"Story"</strong> (grounded parallel‚Äînarrative fiction)</li>
                        <li><strong>Result:</strong> SE-NW-ESE = <strong>"Story"</strong></li>
                    </ul>

                    <p><strong>Meta-relation verification:</strong></p>
                    <p style="margin-left: 20px;">Is "Revelation" southwest of "Story"?<br>
                    Is Revelation a concrete opposite of Story?<br>
                    <strong>My judgment:</strong> NO. Revelation unveils deep truth; Story creates narrative. They're not opposites in a grounded way. Revelation is more abstract, more profound. If anything, Story is a grounded form of Revelation (how we share revealed truths), making them siblings rather than opposites.</p>

                    <p><strong>N-2-back comparison:</strong> Compare to Trial 4<br>
                    Trial 4 judgment: MATCH | Trial 6 judgment: NO MATCH<br>
                    <strong>One MATCH, one NO MATCH ‚Üí Correct response: NO MATCH</strong></p>
                    <p style="color: #e67e22; font-weight: bold;">N-BACK ANSWER: NO MATCH</p>
                    </div>

                    <div class="sandbox-journal-entry">
                    <h5 style="color: #8b00ff; margin-bottom: 8px;">Trial 7: "ENE-SSW-NNW is east of ESE-SW-WNW"</h5>

                    <p><strong>Premise decomposition:</strong> ENE-SSW-NNW is east of ESE-SW-WNW</p>

                    <p><strong>Left side (ENE-SSW-NNW):</strong></p>
                    <ul style="margin-left: 20px; color: #aaa;">
                        <li><strong>Seed:</strong> "Perception" (sensory awareness)</li>
                        <li><strong>Apply ENE (lateral then elevated parallel):</strong> Perception ‚Üí <strong>"Intuition"</strong> (elevated parallel‚Äînon-sensory knowing)</li>
                        <li><strong>Apply SSW (highly concrete opposite):</strong> Intuition ‚Üí <strong>"Calculation"</strong> (material opposite‚Äîalgorithmic rather than intuitive)</li>
                        <li><strong>Apply NNW (highly abstract opposite):</strong> Calculation ‚Üí <strong>"Creativity"</strong> (highly abstract inverse‚Äîemergent rather than computed)</li>
                        <li><strong>Result:</strong> ENE-SSW-NNW = <strong>"Creativity"</strong></li>
                    </ul>

                    <p><strong>Right side (ESE-SW-WNW):</strong></p>
                    <ul style="margin-left: 20px; color: #aaa;">
                        <li><strong>Seed:</strong> "Observation" (directed noticing)</li>
                        <li><strong>Apply ESE (lateral then grounded parallel):</strong> Observation ‚Üí <strong>"Inspection"</strong> (grounded parallel‚Äîdetailed observation)</li>
                        <li><strong>Apply SW (concrete opposite):</strong> Inspection ‚Üí <strong>"Blindness"</strong> (grounded antithesis‚Äîinability to see)</li>
                        <li><strong>Apply WNW (counter-role then elevated inversion):</strong> Blindness ‚Üí <strong>"Insight"</strong> (abstract counter-role‚Äîseeing truth without physical sight)</li>
                        <li><strong>Result:</strong> ESE-SW-WNW = <strong>"Insight"</strong></li>
                    </ul>

                    <p><strong>Meta-relation verification:</strong></p>
                    <p style="margin-left: 20px;">Is "Creativity" east of "Insight"?<br>
                    Is Creativity an analogue/parallel of Insight?<br>
                    <strong>My judgment:</strong> YES. Both are forms of non-linear knowing. Creativity generates novelty; Insight perceives hidden patterns. They're siblings in the realm of transcendent cognition‚Äîparallel modes of accessing truth beyond logic.</p>

                    <p><strong>N-2-back comparison:</strong> Compare to Trial 5<br>
                    Trial 5 judgment: MATCH | Trial 7 judgment: MATCH<br>
                    <strong>Both MATCH ‚Üí Correct response: MATCH</strong></p>
                    <p style="color: #2ecc71; font-weight: bold;">N-BACK ANSWER: MATCH</p>
                    </div>

                    <div class="sandbox-journal-entry">
                    <h5 style="color: #8b00ff; margin-bottom: 8px;">Trial 8: "SSE-NW-ENE is north of WSW-SE-SSE"</h5>

                    <p><strong>Premise decomposition:</strong> SSE-NW-ENE is north of WSW-SE-SSE</p>

                    <p><strong>Left side (SSE-NW-ENE):</strong></p>
                    <ul style="margin-left: 20px; color: #aaa;">
                        <li><strong>Seed:</strong> "Discipline" (structured practice)</li>
                        <li><strong>Apply SSE (highly concrete sibling):</strong> Discipline ‚Üí <strong>"Routine"</strong> (grounded parallel‚Äîhabitual discipline)</li>
                        <li><strong>Apply NW (abstract opposite):</strong> Routine ‚Üí <strong>"Spontaneity"</strong> (abstract antithesis‚Äîunplanned action)</li>
                        <li><strong>Apply ENE (lateral then elevated parallel):</strong> Spontaneity ‚Üí <strong>"Improvisation"</strong> (elevated parallel‚Äîskilled spontaneity)</li>
                        <li><strong>Result:</strong> SSE-NW-ENE = <strong>"Improvisation"</strong></li>
                    </ul>

                    <p><strong>Right side (WSW-SE-SSE):</strong></p>
                    <ul style="margin-left: 20px; color: #aaa;">
                        <li><strong>Seed:</strong> "Order" (structured arrangement)</li>
                        <li><strong>Apply WSW (counter-role then grounded inversion):</strong> Order ‚Üí <strong>"Disorder"</strong> (material counter-role‚Äîlack of structure)</li>
                        <li><strong>Apply SE (concrete sibling):</strong> Disorder ‚Üí <strong>"Mess"</strong> (grounded parallel‚Äîphysical disorder)</li>
                        <li><strong>Apply SSE (highly concrete sibling):</strong> Mess ‚Üí <strong>"Rubble"</strong> (highly concrete parallel‚Äîextreme physical disorder)</li>
                        <li><strong>Result:</strong> WSW-SE-SSE = <strong>"Rubble"</strong></li>
                    </ul>

                    <p><strong>Meta-relation verification:</strong></p>
                    <p style="margin-left: 20px;">Is "Improvisation" north of "Rubble"?<br>
                    Is Improvisation a generalization/abstraction of Rubble?<br>
                    <strong>My judgment:</strong> YES. Improvisation is creative disorder with skill and intention. Rubble is pure physical destruction. Improvisation is the abstract, intentional form of what Rubble represents materially‚Äîboth involve breaking structure, but Improvisation is the elevated, purposeful version.</p>

                    <p><strong>N-2-back comparison:</strong> Compare to Trial 6<br>
                    Trial 6 judgment: NO MATCH | Trial 8 judgment: MATCH<br>
                    <strong>One MATCH, one NO MATCH ‚Üí Correct response: NO MATCH</strong></p>
                    <p style="color: #e67e22; font-weight: bold;">N-BACK ANSWER: NO MATCH</p>
                    </div>

                    <div class="sandbox-journal-entry">
                    <h5 style="color: #8b00ff; margin-bottom: 8px;">Trial 9: "WNW-SSE-NE is northwest of ESE-NNW-SE"</h5>

                    <p><strong>Premise decomposition:</strong> WNW-SSE-NE is northwest of ESE-NNW-SE</p>

                    <p><strong>Left side (WNW-SSE-NE):</strong></p>
                    <ul style="margin-left: 20px; color: #aaa;">
                        <li><strong>Seed:</strong> "Belief" (held conviction)</li>
                        <li><strong>Apply WNW (counter-role then elevated inversion):</strong> Belief ‚Üí <strong>"Skepticism"</strong> (abstract counter-role‚Äîquestioning rather than accepting)</li>
                        <li><strong>Apply SSE (highly concrete sibling):</strong> Skepticism ‚Üí <strong>"Cynicism"</strong> (grounded parallel‚Äîhardened skepticism)</li>
                        <li><strong>Apply NE (abstract sibling):</strong> Cynicism ‚Üí <strong>"Disillusionment"</strong> (elevated parallel‚Äîphilosophical loss of illusion)</li>
                        <li><strong>Result:</strong> WNW-SSE-NE = <strong>"Disillusionment"</strong></li>
                    </ul>

                    <p><strong>Right side (ESE-NNW-SE):</strong></p>
                    <ul style="margin-left: 20px; color: #aaa;">
                        <li><strong>Seed:</strong> "Faith" (trust without evidence)</li>
                        <li><strong>Apply ESE (lateral then grounded parallel):</strong> Faith ‚Üí <strong>"Devotion"</strong> (grounded parallel‚Äîenacted faith)</li>
                        <li><strong>Apply NNW (highly abstract opposite):</strong> Devotion ‚Üí <strong>"Apostasy"</strong> (highly abstract inverse‚Äîrejection of faith)</li>
                        <li><strong>Apply SE (concrete sibling):</strong> Apostasy ‚Üí <strong>"Betrayal"</strong> (grounded parallel‚Äîenacted rejection)</li>
                        <li><strong>Result:</strong> ESE-NNW-SE = <strong>"Betrayal"</strong></li>
                    </ul>

                    <p><strong>Meta-relation verification:</strong></p>
                    <p style="margin-left: 20px;">Is "Disillusionment" northwest of "Betrayal"?<br>
                    Is Disillusionment an abstract opposite of Betrayal?<br>
                    <strong>My judgment:</strong> YES. Disillusionment is internal awakening to false belief. Betrayal is external breaking of trust. They're opposing forces‚Äîone is self-directed philosophical shift (abstract), the other is relational violation (concrete). Disillusionment is the abstract negation of what Betrayal enacts materially.</p>

                    <p><strong>N-2-back comparison:</strong> Compare to Trial 7<br>
                    Trial 7 judgment: MATCH | Trial 9 judgment: MATCH<br>
                    <strong>Both MATCH ‚Üí Correct response: MATCH</strong></p>
                    <p style="color: #2ecc71; font-weight: bold;">N-BACK ANSWER: MATCH</p>
                    </div>

                    <div class="sandbox-journal-entry">
                    <h5 style="color: #8b00ff; margin-bottom: 8px;">Trial 10: "NNE-WSW-ESE is south of SSW-ENE-WNW"</h5>

                    <p><strong>Premise decomposition:</strong> NNE-WSW-ESE is south of SSW-ENE-WNW</p>

                    <p><strong>Left side (NNE-WSW-ESE):</strong></p>
                    <ul style="margin-left: 20px; color: #aaa;">
                        <li><strong>Seed:</strong> "Mastery" (complete skill)</li>
                        <li><strong>Apply NNE (highly abstract sibling):</strong> Mastery ‚Üí <strong>"Genius"</strong> (highly abstract parallel‚Äîtranscendent mastery)</li>
                        <li><strong>Apply WSW (counter-role then grounded inversion):</strong> Genius ‚Üí <strong>"Incompetence"</strong> (material counter-role‚Äîlack of skill)</li>
                        <li><strong>Apply ESE (lateral then grounded parallel):</strong> Incompetence ‚Üí <strong>"Clumsiness"</strong> (grounded parallel‚Äîphysical incompetence)</li>
                        <li><strong>Result:</strong> NNE-WSW-ESE = <strong>"Clumsiness"</strong></li>
                    </ul>

                    <p><strong>Right side (SSW-ENE-WNW):</strong></p>
                    <ul style="margin-left: 20px; color: #aaa;">
                        <li><strong>Seed:</strong> "Excellence" (superior quality)</li>
                        <li><strong>Apply SSW (highly concrete opposite):</strong> Excellence ‚Üí <strong>"Mediocrity"</strong> (material opposite‚Äîaverage quality)</li>
                        <li><strong>Apply ENE (lateral then elevated parallel):</strong> Mediocrity ‚Üí <strong>"Adequacy"</strong> (elevated parallel‚Äîsufficient mediocrity)</li>
                        <li><strong>Apply WNW (counter-role then elevated inversion):</strong> Adequacy ‚Üí <strong>"Exceptionalism"</strong> (abstract counter-role‚Äîsurpassing adequacy)</li>
                        <li><strong>Result:</strong> SSW-ENE-WNW = <strong>"Exceptionalism"</strong></li>
                    </ul>

                    <p><strong>Meta-relation verification:</strong></p>
                    <p style="margin-left: 20px;">Is "Clumsiness" south of "Exceptionalism"?<br>
                    Is Clumsiness a specification/concretization of Exceptionalism?<br>
                    <strong>My judgment:</strong> NO. These are opposites, not hierarchical. Clumsiness is the embodiment of failure; Exceptionalism is the embodiment of extraordinary success. Clumsiness can't be derived from Exceptionalism through down-shift. They're antithetical rather than nested.</p>

                    <p><strong>N-2-back comparison:</strong> Compare to Trial 8<br>
                    Trial 8 judgment: MATCH | Trial 10 judgment: NO MATCH<br>
                    <strong>One MATCH, one NO MATCH ‚Üí Correct response: NO MATCH</strong></p>
                    <p style="color: #e67e22; font-weight: bold;">N-BACK ANSWER: NO MATCH</p>
                    </div>

                    </div>

                    <h4>Key Insights from This Walkthrough</h4>

                    <ol>
                        <li><strong>Triple-nested chains create dramatic conceptual journeys:</strong> Three transformations allow for complex semantic narratives (Logic ‚Üí Mathematics ‚Üí Geometry ‚Üí Chaos)</li>
                        <li><strong>16-direction fine-grained distinctions:</strong> NNE vs. NE vs. ENE create nuanced gradations of meaning</li>
                        <li><strong>Compositional logic maintains consistency:</strong> Using N+N+E formulas helps ensure coherent directional definitions</li>
                        <li><strong>8-direction meta-operators increase complexity:</strong> Diagonal meta-relationships (NE, SE, SW, NW) add subtle relational categories</li>
                        <li><strong>Working memory challenge is extreme:</strong> Tracking three steps per compound while maintaining n-back recall pushes cognitive limits</li>
                        <li><strong>Semantic flexibility is paramount:</strong> Some trials required generous interpretation to find valid mappings</li>
                        <li><strong>The system is YOUR invention:</strong> My "Cognitive Architectures" theme is one approach‚Äîyou can invent any 16-direction system that maintains coherence</li>
                    </ol>

                    <h4>Tips for Your Level 9 Practice</h4>

                    <ul>
                        <li><strong>Write down your complete 16-direction system before starting</strong> (use compositional formulas like NNE = N+N+E)</li>
                        <li><strong>Practice triple-nested chains offline first</strong> (test 10-20 sequences on paper before live trials)</li>
                        <li><strong>Visualize each transformation step-by-step</strong> (never skip a step‚Äîsee all three transformations happen)</li>
                        <li><strong>Choose a thematically rich domain</strong> (cognitive processes, emotional states, artistic forms, etc.)</li>
                        <li><strong>Start conservatively: n=2, k=1, 10 trials</strong> (Level 9 is brutally difficult initially)</li>
                        <li><strong>Track your directional consistency rigorously</strong> (did NNE always mean the same transformation?)</li>
                        <li><strong>Expect months of practice before fluency</strong> (this is the apex of human cognitive training)</li>
                        <li><strong>Build on Level 8 mastery</strong> (only attempt Level 9 after fluency in 8-direction reasoning)</li>
                    </ul>

                    <p style="color: #8b00ff; font-weight: bold; margin-top: 20px;">Level 9 represents the absolute ceiling of working memory and generative semantic capacity under n-back load. The triple-nested compositional chains combined with 16-direction spatial reasoning create a cognitive challenge unmatched in any other training paradigm. Embrace the difficulty‚Äîthis is where minds transcend.</p>
                `,
                speech: 'Level Nine Instructions: Triple-Nested Compositional Invention Method. Introduction: The Sixteen-Direction Generative Engine. Level Nine is the apex of cognitive training, the ultimate test of working memory, semantic invention, and spatial reasoning. You will create a complete sixteen-direction system and execute triple-nested transformation chains while maintaining n-back recall across trials. Core principle: Start with a vivid seed concept. Apply three sequential transformations using your sixteen-direction operator system. Each transformation must be compositionally coherent and phenomenologically rich. This tutorial demonstrates the method through a complete n-two-back walkthrough. The Sixteen-Direction Invention System. Cardinal Directions, Given: North: up-shift, generalization, abstraction, intensification. South: down-shift, specification, concretization, materialization. East: analogue, parallel role, sibling concept, lateral shift. West: opposite, antithesis, negation, mirror inverse. Intermediate Directions, Your Invention: You must define twelve additional directions using compositional logic. NNE equals N plus N plus E: double up-shift plus analogue equals highly abstract sibling. NE equals N plus E: up-shift plus analogue equals abstract sibling, from Level eight. ENE equals E plus N plus E: analogue plus up-shift plus analogue equals lateral then elevated parallel. ESE equals E plus S plus E: analogue plus down-shift plus analogue equals lateral then grounded parallel. SE equals S plus E: down-shift plus analogue equals concrete sibling, from Level eight. SSE equals S plus S plus E: double down-shift plus analogue equals highly concrete sibling. SSW equals S plus S plus W: double down-shift plus opposite equals highly concrete opposite. SW equals S plus W: down-shift plus opposite equals concrete opposite, from Level eight. WSW equals W plus S plus W: opposite plus down-shift plus opposite equals counter-role then grounded inversion. WNW equals W plus N plus W: opposite plus up-shift plus opposite equals counter-role then elevated inversion. NW equals N plus W: up-shift plus opposite equals abstract opposite, from Level eight. NNW equals N plus N plus W: double up-shift plus opposite equals highly abstract opposite. Meta-Operators: Eight-Direction System. The meta-relationship uses eight directions, all cardinals plus all diagonals: N, NE, E, SE, S, SW, W, NW. This is a diagonal progression from Level eight\'s four-direction meta-operator system. For a complete walkthrough demonstrating triple-nested compositional invention with ten n-two-back trials using cognitive architecture concepts, please read the full visual tutorial. Key insights: Triple-nested chains create dramatic conceptual journeys. Sixteen-direction fine-grained distinctions provide nuanced gradations of meaning. Compositional logic maintains consistency. Eight-direction meta-operators increase complexity. Working memory challenge is extreme. Tips for practice: Write down your complete sixteen-direction system before starting. Practice triple-nested chains offline first. Visualize each transformation step by step. Choose a thematically rich domain. Start conservatively: n equals two, k equals one, ten trials. Track directional consistency rigorously. Expect months of practice before fluency. Build on Level eight mastery. Level Nine represents the absolute ceiling of working memory and generative semantic capacity under n-back load. Embrace the difficulty, this is where minds transcend.'
            },
            {
                id: 'davinci-method',
                title: 'Da Vinci does Imagi-World',
                html: `
                    <h3>Da Vinci does Imagi-World</h3>

                    <p>Leonardo da Vinci's genius was not handling complexity‚Äîit was <strong>seeing connections across domains</strong>. This tutorial teaches you to apply his cross-domain synthesis method to <strong>every level</strong> of Imagi-World, from Level 1 to Level 9.</p>

                    <h4>The Core Principle: Cross-Domain Transformation</h4>
                    <p>Da Vinci didn't just study birds‚Äîhe studied birds to design flying machines. He didn't just paint‚Äîhe studied optics to perfect sfumato. <strong>Every transformation crossed domains.</strong></p>

                    <p><strong>You can do this at ANY level:</strong></p>
                    <ul>
                        <li><strong>Level 1:</strong> Single atoms ‚Üí 2-3 domain jumps</li>
                        <li><strong>Level 3:</strong> Chains ‚Üí 4-5 domain jumps</li>
                        <li><strong>Level 6:</strong> Meta-relational ‚Üí 6-8 domain jumps</li>
                        <li><strong>Level 9:</strong> Triple compounds ‚Üí 8-12 domain jumps</li>
                    </ul>

                    <h4>Level 1: Da Vinci Solves "X is north of Y"</h4>
                    <div class="sandbox-journal" style="background: rgba(22, 33, 62, 0.8); padding: 16px; margin: 16px 0;">
                        <p><strong>Example 1:</strong> Y := "Bird wing feather" (Ornithology) ‚Üí North ‚Üí X := "Mechanical pen nib" (Engineering/Writing Instruments)</p>
                        <p style="margin-left: 20px; color: #aaa;">Da Vinci's connection: In Codex Atlanticus, da Vinci sketched bird feathers alongside pen designs, recognizing that both use flexible vanes/tines to control flow‚Äîair for feathers, ink for nibs. The generalization is "flexible flow control mechanisms." Domain jump: Ornithology ‚Üí Engineering. Total: <strong>2 radically different domains</strong>.</p>

                        <p style="margin-top: 16px;"><strong>Example 2:</strong> Y := "Water mill wheel" (Hydraulic Engineering) ‚Üí South ‚Üí X := "Human heart valve" (Cardiovascular Anatomy)</p>
                        <p style="margin-left: 20px; color: #aaa;">Da Vinci's connection: Da Vinci's anatomical drawings (c. 1513) show heart valves modeled after mill wheel mechanics‚Äîboth prevent backflow through rhythmic opening/closing. The specification is "one-way flow gate." Domain jump: Hydraulic Engineering ‚Üí Medicine. Total: <strong>2 completely different domains</strong>.</p>

                        <p style="margin-top: 16px; color: #8b00ff;"><strong>Level 1 domain count: 4 unique fields traversed in simple premises‚Äîbut now with TRUE cross-domain leaps, not subdomain drift.</strong></p>
                    </div>

                    <h4>Level 2: Da Vinci Solves "X is north of Y is east of Z"</h4>
                    <div class="sandbox-journal" style="background: rgba(22, 33, 62, 0.8); padding: 16px; margin: 16px 0;">
                        <p><strong>Cross-domain chain:</strong> Z := "Snail shell spiral" (Malacology/Biology) ‚Üí North ‚Üí Y := "Golden ratio mathematics" (Geometry) ‚Üí East ‚Üí X := "Cathedral dome architecture" (Civil Engineering/Architecture)</p>
                        <p style="margin-left: 20px; color: #aaa;">Da Vinci's connection: Da Vinci measured snail shells, extracted the œÜ (phi) ratio, and applied it to architectural proportions in his church designs. Three radically different domains crossed in one chain: Biology ‚Üí Mathematics ‚Üí Architecture. Total: <strong>3 completely different domains</strong>.</p>

                        <p style="margin-top: 16px;"><strong>Historical note:</strong> Da Vinci's notebooks (Codex Madrid II) contain sketches of nautilus shells with geometric overlays, demonstrating his recognition that biological growth patterns encode universal mathematical proportions applicable to human architecture.</p>
                    </div>

                    <h4>Level 3: Da Vinci Solves Multi-Atom Chains</h4>
                    <div class="sandbox-journal" style="background: rgba(22, 33, 62, 0.8); padding: 16px; margin: 16px 0;">
                        <p><strong>Four-concept cross-domain chain:</strong></p>
                        <p>A := "Eagle embryo wing bud" (Embryology) ‚Üí North ‚Üí B := "Hydraulic piston expansion" (Mechanical Engineering) ‚Üí East ‚Üí C := "Organ pipe bellows" (Music/Acoustics) ‚Üí South ‚Üí D := "Respiratory diaphragm" (Human Anatomy)</p>
                        <p style="margin-left: 20px; color: #aaa;">
                            1. Wing bud ‚Üí Hydraulic piston (biological tissue growth generalized to mechanical expansion principle)<br>
                            2. Hydraulic piston ‚Üí Organ bellows (mechanical analogue: both are pressure-driven expansion chambers)<br>
                            3. Organ bellows ‚Üí Diaphragm (musical instrument specified to its biological counterpart)<br>
                            Domain progression: Embryology ‚Üí Engineering ‚Üí Music ‚Üí Anatomy. Total: <strong>4 radically different domains</strong>.
                        </p>

                        <p style="margin-top: 16px; color: #2ecc71;"><strong>Da Vinci actually did this:</strong> His anatomical notebooks (Windsor Collection, c. 1510-1513) show embryonic development studies alongside hydraulic machines. He designed organ bellows for musical instruments while simultaneously dissecting human lungs. He recognized expansion/contraction as a universal principle across biology, engineering, music, and medicine.</p>
                    </div>

                    <h4>Level 6: Da Vinci Solves Direction-Word Spatial Reasoning</h4>
                    <div class="sandbox-journal" style="background: rgba(22, 33, 62, 0.8); padding: 16px; margin: 16px 0;">
                        <p><strong>Premise:</strong> "West is north of East, East is west of South"</p>
                        <p><strong>Middle atoms:</strong> "North is south of South"</p>

                        <p style="margin-top: 12px;"><strong>Da Vinci's approach to abstract spatial reasoning:</strong></p>

                        <p style="margin-left: 20px; color: #aaa;"><strong>Step 1: Anchor direction words to spatial positions</strong></p>
                        <ul style="margin-left: 40px; color: #aaa;">
                            <li>North := Concept of "upward abstraction" anchored at spatial position (0,1)</li>
                            <li>South := Concept of "downward specification" anchored at spatial position (0,0)</li>
                            <li>East := Concept of "lateral analogue" anchored at spatial position (1,0)</li>
                            <li>West := Concept of "lateral opposite" anchored at spatial position (-1,0)</li>
                        </ul>

                        <p style="margin-top: 12px; margin-left: 20px; color: #aaa;"><strong>Step 2: Build constraint graph from middle atoms</strong></p>
                        <ul style="margin-left: 40px; color: #aaa;">
                            <li>Middle: "North is south of South" establishes North must be positioned below South</li>
                            <li>This creates vertical dependency: South(0,1), North(0,0)</li>
                        </ul>

                        <p style="margin-top: 12px; margin-left: 20px; color: #aaa;"><strong>Step 3: Verify current premise spatial consistency</strong></p>
                        <ul style="margin-left: 40px; color: #aaa;">
                            <li>"West is north of East" ‚Üí West must be above East (vertical relationship)</li>
                            <li>"East is west of South" ‚Üí East must be left of South (horizontal relationship)</li>
                            <li>SAT solver validates: No contradiction with established constraints</li>
                        </ul>

                        <p style="margin-top: 12px; margin-left: 20px; color: #aaa;"><strong>Step 4: Cross-domain insight</strong></p>
                        <ul style="margin-left: 40px; color: #aaa;">
                            <li>Direction words represent <strong>transformation operators</strong> from his Treatise on Painting</li>
                            <li>Spatial relationships encode <strong>conceptual hierarchies</strong> from his anatomical studies</li>
                            <li>Constraint solving mirrors his <strong>geometric proofs</strong> in Codex Atlanticus</li>
                        </ul>

                        <p style="margin-top: 16px; color: #2ecc71;"><strong>Da Vinci's actual method:</strong> In Manuscript A (c. 1492), da Vinci used directional operators (alto/basso = up/down, destra/sinistra = right/left) to encode spatial transformations in architectural designs. He combined these with constraint satisfaction to ensure structural integrity‚Äîthe exact reasoning Level 6 demands.</p>

                        <p style="margin-top: 16px; color: #8b00ff;"><strong>Level 6 demands 4-6 domain jumps:</strong> Spatial Geometry ‚Üí Logical Constraints ‚Üí Transformation Theory ‚Üí Abstract Reasoning ‚Üí Pattern Recognition ‚Üí Meta-Cognitive Monitoring.</p>
                    </div>

                    <h4>Level 7: Da Vinci Solves Compound Operators</h4>
                    <div class="sandbox-journal" style="background: rgba(22, 33, 62, 0.8); padding: 16px; margin: 16px 0;">
                        <p><strong>Premise:</strong> "north-south is east of east-west"</p>

                        <p><strong>Left compound (north-south):</strong></p>
                        <p style="margin-left: 20px;">
                            Seed := "Telescope lens" (Optics/Astronomy)<br>
                            ‚Üí Apply North: "Human eye anatomy" (Vision Science/Physiology)<br>
                            ‚Üí Apply South: "Painting perspective technique" (Art/Renaissance Technique)<br>
                            Result: <strong>"Painting perspective technique"</strong> (3 domains: Optics ‚Üí Physiology ‚Üí Art)
                        </p>

                        <p style="margin-top: 12px;"><strong>Right compound (east-west):</strong></p>
                        <p style="margin-left: 20px;">
                            Seed := "Ship sail" (Maritime Engineering/Navigation)<br>
                            ‚Üí Apply East: "Bird wing" (Ornithology/Flight Mechanics)<br>
                            ‚Üí Apply West: "Wind pattern analysis" (Meteorology/Atmospheric Science)<br>
                            Result: <strong>"Wind pattern analysis"</strong> (3 domains: Maritime Engineering ‚Üí Ornithology ‚Üí Meteorology)
                        </p>

                        <p style="margin-top: 12px;"><strong>Meta-relation:</strong> Is "Painting perspective technique" east (analogue) of "Wind pattern analysis"?</p>
                        <p style="margin-left: 20px; color: #aaa;">YES‚ÄîDa Vinci's insight: Both are systems for mapping invisible forces onto visible surfaces. Perspective painting captures spatial depth (3D‚Üí2D optical projection). Wind analysis captures air currents (invisible flow‚Üívisible effects). Both translate hidden structure into perceivable form through geometric/observational methods.</p>

                        <p style="margin-top: 16px; color: #2ecc71;"><strong>Level 7 total: 6 domains</strong> (Optics, Physiology, Art, Maritime Engineering, Ornithology, Meteorology)</p>

                        <p style="margin-top: 12px;"><strong>Historical validation:</strong> Da Vinci's Treatise on Painting directly connects telescope optics to eye anatomy to develop perspective laws. His studies of bird flight (Codex on Flight) explicitly compare sail mechanics to wing aerodynamics. Both transformation chains appear in his actual notebooks.</p>
                    </div>

                    <h4>Level 8: Da Vinci Solves 8-Direction Diagonals</h4>
                    <div class="sandbox-journal" style="background: rgba(22, 33, 62, 0.8); padding: 16px; margin: 16px 0;">
                        <p><strong>Premise:</strong> "northeast-southwest is north of southeast-northwest"</p>

                        <p><strong>Left compound (northeast-southwest):</strong></p>
                        <p style="margin-left: 20px;">
                            Seed := "Violin string vibration" (Acoustics/Music Theory)<br>
                            ‚Üí Apply NE (elevated analogue): "Light wave propagation" (Optics/Physics)<br>
                            ‚Üí Apply SW (material opposite): "Marble quarry silence" (Geology/Architecture)<br>
                            Result: <strong>"Marble quarry silence"</strong>
                        </p>

                        <p style="margin-top: 12px;"><strong>Right compound (southeast-northwest):</strong></p>
                        <p style="margin-left: 20px;">
                            Seed := "Flowing river current" (Hydrology/Fluid Dynamics)<br>
                            ‚Üí Apply SE (concrete analogue): "Blood vessel circulation" (Cardiovascular Medicine)<br>
                            ‚Üí Apply NW (abstract opposite): "Contemplative stillness meditation" (Philosophy/Contemplative Practice)<br>
                            Result: <strong>"Contemplative stillness meditation"</strong>
                        </p>

                        <p style="margin-top: 12px;"><strong>Meta-relation:</strong> Is "Marble quarry silence" north of "Contemplative stillness meditation"?</p>
                        <p style="margin-left: 20px; color: #aaa;">NO‚ÄîFALSE. Contemplative meditation is the generalized (abstract) form of intentional silence. Marble quarry is the material (concrete) instance of passive silence. The meditation is north of the quarry, not vice versa. The premise is FALSE‚Äîforcing you to recognize the abstraction hierarchy across these radically different domains.</p>

                        <p style="margin-top: 16px; color: #8b00ff;"><strong>Level 8 total: 7 domains</strong> (Acoustics, Optics, Geology, Hydrology, Medicine, Philosophy, Contemplative Practice). This is Renaissance-level synthesis.</p>

                        <p style="margin-top: 16px;"><strong>Historical note:</strong> Da Vinci studied violin string vibrations in Manuscript H (c. 1494), compared wave propagation across sound/light in his optics treatise, analyzed marble quarry stone selection for architecture (notes on Duomo di Milano), compared river flow to blood in Codex Leicester, and advocated meditative observation in his painting instructions. He explicitly connected acoustic waves to light waves to material properties to fluid dynamics to contemplative practice‚Äîall seven domains unified.</p>
                    </div>

                    <h4>Level 9: Da Vinci's Peak‚ÄîTriple-Nested Compounds</h4>
                    <div class="sandbox-journal" style="background: rgba(22, 33, 62, 0.8); padding: 16px; margin: 16px 0;">
                        <p><strong>Example from DaVinci_Does_9.md:</strong></p>
                        <p><strong>Premise:</strong> "SE-E-SW is northeast of E-NNE-SSW"</p>

                        <p><strong>Left compound (SE-E-SW):</strong></p>
                        <p style="margin-left: 20px;">
                            Seed: "Bird wing" (Ornithology)<br>
                            ‚Üí SE: "Human arm anatomy" (Human Anatomy)<br>
                            ‚Üí E: "Mechanical lever" (Engineering)<br>
                            ‚Üí SW: "Hydraulic piston" (Hydraulic Engineering)<br>
                            <strong>Result: "Hydraulic piston"</strong>
                        </p>

                        <p style="margin-top: 12px;"><strong>Right compound (E-NNE-SSW):</strong></p>
                        <p style="margin-left: 20px;">
                            Seed: "Flowing river" (Hydrology)<br>
                            ‚Üí E: "Bloodstream" (Cardiovascular Anatomy)<br>
                            ‚Üí NNE: "Musical harmony propagation" (Music Theory/Acoustics)<br>
                            ‚Üí SSW: "Stone quarry silence" (Geology/Architecture)<br>
                            <strong>Result: "Stone quarry silence"</strong>
                        </p>

                        <p style="margin-top: 12px;"><strong>Meta-relation:</strong> Is "Hydraulic piston" northeast of "Stone quarry silence"?</p>
                        <p style="margin-left: 20px; color: #aaa;">
                            <strong>Da Vinci's analysis:</strong> Both represent states of potential energy. The piston contains pressurized water ready to release force (dynamic potential). The quarry contains stone ready to be shaped into architecture (material potential). The piston is the abstract elevated analogue‚Äîgeneralized potential (northeast = abstract + analogue). <strong>TRUE‚ÄîMATCH.</strong>
                        </p>

                        <p style="margin-top: 16px; color: #e67e22; font-weight: bold;">Level 9 total: 8 unique domains (Ornithology, Human Anatomy, Mechanical Engineering, Hydraulic Engineering, Hydrology, Cardiovascular Anatomy, Music Theory, Geology/Architecture)</p>

                        <p style="margin-top: 12px; color: #2ecc71;"><strong>Historical validation:</strong> Every transformation above appears in Leonardo's actual notebooks:</p>
                        <ul style="margin-left: 20px; color: #aaa; margin-top: 8px;">
                            <li>Bird wing ‚Üí Human arm: Codex on Flight of Birds (comparative anatomy)</li>
                            <li>Arm ‚Üí Lever: Codex Arundel (biomechanics)</li>
                            <li>Lever ‚Üí Hydraulic: Codex Leicester (solid to fluid mechanics)</li>
                            <li>River ‚Üí Blood: Anatomical drawings (c. 1513)</li>
                            <li>Blood ‚Üí Music: Treatise on sound (pulse as tempo)</li>
                            <li>Music ‚Üí Stone: Architectural designs (acoustic mass vs. resonance)</li>
                        </ul>
                    </div>

                    <h4>Da Vinci's 10 Principles for Cross-Domain Synthesis</h4>
                    <ol>
                        <li><strong>Start concrete, not abstract:</strong> "Thunder cracking oak" not "kinetic energy transfer"</li>
                        <li><strong>Force domain jumps:</strong> Every transformation must cross fields (Biology ‚Üí Engineering, not Biology ‚Üí Biology)</li>
                        <li><strong>Use sensory anchors:</strong> You must be able to see, hear, touch, smell it (even if abstract, ground it first)</li>
                        <li><strong>Study comparatively:</strong> Bird wing = human arm = mechanical lever (find the pattern)</li>
                        <li><strong>Invert for insight:</strong> Solid ‚Üí Fluid, Structure ‚Üí Chaos, Presence ‚Üí Absence</li>
                        <li><strong>Track analogies rigorously:</strong> River = blood = sound waves = light rays (same propagation principle)</li>
                        <li><strong>Hold multiple domains simultaneously:</strong> Physics + Art + Engineering in working memory at once</li>
                        <li><strong>Find underlying patterns:</strong> Spirals in shells, water vortices, hair, galaxies (same mathematics)</li>
                        <li><strong>Cross-pollinate relentlessly:</strong> Use architecture insights for anatomy, anatomy for painting, painting for optics</li>
                        <li><strong>Document connections:</strong> Build your personal knowledge graph (Leonardo's 13,000 notebook pages)</li>
                    </ol>

                    <h4>Building Your Domain Vocabulary</h4>
                    <p>Da Vinci actively worked across <strong>50+ domains</strong>. Start with 10-15, expand to 30+ over time:</p>

                    <table style="width: 100%; border-collapse: collapse; margin: 16px 0; font-size: 0.85rem;">
                        <tr style="background: rgba(52, 152, 219, 0.2);">
                            <th style="padding: 8px; border: 1px solid #555; text-align: left;">Category</th>
                            <th style="padding: 8px; border: 1px solid #555; text-align: left;">Domains (Beginner Set)</th>
                        </tr>
                        <tr>
                            <td style="padding: 8px; border: 1px solid #555;"><strong>Natural Sciences</strong></td>
                            <td style="padding: 8px; border: 1px solid #555;">Physics, Chemistry, Biology, Astronomy, Geology, Meteorology</td>
                        </tr>
                        <tr>
                            <td style="padding: 8px; border: 1px solid #555;"><strong>Engineering</strong></td>
                            <td style="padding: 8px; border: 1px solid #555;">Mechanical, Hydraulic, Civil, Architecture, Optics, Acoustics</td>
                        </tr>
                        <tr>
                            <td style="padding: 8px; border: 1px solid #555;"><strong>Arts</strong></td>
                            <td style="padding: 8px; border: 1px solid #555;">Painting, Sculpture, Music Theory, Literature, Calligraphy</td>
                        </tr>
                        <tr>
                            <td style="padding: 8px; border: 1px solid #555;"><strong>Human Sciences</strong></td>
                            <td style="padding: 8px; border: 1px solid #555;">Anatomy, Psychology, Medicine, Philosophy, Theology</td>
                        </tr>
                        <tr>
                            <td style="padding: 8px; border: 1px solid #555;"><strong>Mathematics</strong></td>
                            <td style="padding: 8px; border: 1px solid #555;">Geometry, Algebra, Logic, Statistics</td>
                        </tr>
                        <tr>
                            <td style="padding: 8px; border: 1px solid #555;"><strong>Practical Arts</strong></td>
                            <td style="padding: 8px; border: 1px solid #555;">Agriculture, Viticulture, Metallurgy, Textiles, Navigation</td>
                        </tr>
                    </table>

                    <p style="color: #aaa; margin-top: 12px;"><strong>Advanced domains (Level 8-9):</strong> Neuroscience, Thermodynamics, Ecology, Cosmology, Epistemology, Symbolic Logic, Game Theory, Cognitive Science, Information Theory, Cryptography, Jurisprudence, Political Science, Economics, Anthropology, Linguistics</p>

                    <h4>Practice Progression Timeline</h4>
                    <div class="sandbox-journal" style="background: rgba(22, 33, 62, 0.8); padding: 16px; margin: 16px 0;">
                        <p><strong>Week 1-2: Level 1-3 Foundation</strong> (2-3 domains per trial)</p>
                        <ul style="margin-left: 20px; color: #aaa;">
                            <li>Build core vocabulary across 10-15 domains</li>
                            <li>Practice single transformations (Apple ‚Üí Fruit, Pigment ‚Üí Ultramarine)</li>
                            <li>Master concrete-to-abstract and abstract-to-concrete jumps</li>
                            <li>Document your transformations (journal format)</li>
                            <li>Goal: 90% accuracy, 5-second response time</li>
                        </ul>

                        <p style="margin-top: 16px;"><strong>Week 3-4: Level 4-6 Cross-Field Synthesis</strong> (4-6 domains)</p>
                        <ul style="margin-left: 20px; color: #aaa;">
                            <li>Force domain jumps on every transformation</li>
                            <li>Chain three concepts across different fields</li>
                            <li>Begin meta-relational reasoning (operator analysis)</li>
                            <li>Expand vocabulary to 20-25 domains</li>
                            <li>Goal: Fluent cross-pollination, no same-domain chains</li>
                        </ul>

                        <p style="margin-top: 16px;"><strong>Week 5-8: Level 7-8 Renaissance Thinking</strong> (6-8 domains)</p>
                        <ul style="margin-left: 20px; color: #aaa;">
                            <li>Execute compound transformations (two sequential operators)</li>
                            <li>Invent diagonal operator meanings (NE, SE, SW, NW)</li>
                            <li>Maintain 8-direction semantic consistency across trials</li>
                            <li>Master vocabulary of 30+ domains</li>
                            <li>Study historical cross-domain thinkers (da Vinci, Goethe, Feynman)</li>
                            <li>Goal: Simultaneous multi-domain reasoning, rapid switching</li>
                        </ul>

                        <p style="margin-top: 16px;"><strong>Week 9+: Level 9 Da Vinci Mastery</strong> (8-12 domains)</p>
                        <ul style="margin-left: 20px; color: #aaa;">
                            <li>Triple-nested transformation chains (three sequential operators)</li>
                            <li>16-direction fine-grained operator system</li>
                            <li>Traverse 8+ domains in single premise</li>
                            <li>Active vocabulary: 40-50 domains, passive: 60+</li>
                            <li>Read da Vinci's notebooks for inspiration (Codex Leicester, Codex Arundel)</li>
                            <li>Goal: Peak fluid intelligence, universal pattern recognition</li>
                        </ul>
                    </div>

                    <h4>Comparing Levels: Domain Traversal Counts</h4>
                    <table style="width: 100%; border-collapse: collapse; margin: 20px 0; font-size: 0.9rem;">
                        <tr style="background: rgba(52, 152, 219, 0.2);">
                            <th style="padding: 8px; border: 1px solid #555;">Level</th>
                            <th style="padding: 8px; border: 1px solid #555;">Premise Type</th>
                            <th style="padding: 8px; border: 1px solid #555;">Typical Domains</th>
                            <th style="padding: 8px; border: 1px solid #555;">Example</th>
                        </tr>
                        <tr>
                            <td style="padding: 8px; border: 1px solid #555;">Level 1</td>
                            <td style="padding: 8px; border: 1px solid #555;">Single atom</td>
                            <td style="padding: 8px; border: 1px solid #555;">2</td>
                            <td style="padding: 8px; border: 1px solid #555;">Bird feather (Ornithology) ‚Üí Pen nib (Engineering)</td>
                        </tr>
                        <tr>
                            <td style="padding: 8px; border: 1px solid #555;">Level 2</td>
                            <td style="padding: 8px; border: 1px solid #555;">Two atoms</td>
                            <td style="padding: 8px; border: 1px solid #555;">3</td>
                            <td style="padding: 8px; border: 1px solid #555;">Snail shell ‚Üí Golden ratio ‚Üí Cathedral dome</td>
                        </tr>
                        <tr>
                            <td style="padding: 8px; border: 1px solid #555;">Level 3</td>
                            <td style="padding: 8px; border: 1px solid #555;">Multi-atom chains</td>
                            <td style="padding: 8px; border: 1px solid #555;">4</td>
                            <td style="padding: 8px; border: 1px solid #555;">Eagle embryo ‚Üí Hydraulic piston ‚Üí Organ bellows ‚Üí Diaphragm</td>
                        </tr>
                        <tr>
                            <td style="padding: 8px; border: 1px solid #555;">Level 4-5</td>
                            <td style="padding: 8px; border: 1px solid #555;">Complex chains + foils</td>
                            <td style="padding: 8px; border: 1px solid #555;">4-6</td>
                            <td style="padding: 8px; border: 1px solid #555;">Similar to Level 3, more atoms</td>
                        </tr>
                        <tr>
                            <td style="padding: 8px; border: 1px solid #555;">Level 6</td>
                            <td style="padding: 8px; border: 1px solid #555;">Meta-relational (g-Leap)</td>
                            <td style="padding: 8px; border: 1px solid #555;">5-8</td>
                            <td style="padding: 8px; border: 1px solid #555;">Analyzing operator relationships across domains</td>
                        </tr>
                        <tr>
                            <td style="padding: 8px; border: 1px solid #555;">Level 7</td>
                            <td style="padding: 8px; border: 1px solid #555;">Compound operators</td>
                            <td style="padding: 8px; border: 1px solid #555;">6-8</td>
                            <td style="padding: 8px; border: 1px solid #555;">Order ‚Üí Hierarchy ‚Üí Manager (3 domains √ó 2 compounds)</td>
                        </tr>
                        <tr>
                            <td style="padding: 8px; border: 1px solid #555;">Level 8</td>
                            <td style="padding: 8px; border: 1px solid #555;">8-direction diagonals</td>
                            <td style="padding: 8px; border: 1px solid #555;">6-9</td>
                            <td style="padding: 8px; border: 1px solid #555;">Electricity ‚Üí Neural ‚Üí Meditation (NE-SW chain)</td>
                        </tr>
                        <tr>
                            <td style="padding: 8px; border: 1px solid #555;">Level 9</td>
                            <td style="padding: 8px; border: 1px solid #555;">Triple-nested 16-direction</td>
                            <td style="padding: 8px; border: 1px solid #555;">8-12</td>
                            <td style="padding: 8px; border: 1px solid #555;">Bird wing ‚Üí Arm ‚Üí Lever ‚Üí Hydraulic piston (4 domains √ó 2 compounds)</td>
                        </tr>
                    </table>

                    <h4>The Da Vinci Mindset: Simultaneous Multi-Domain Awareness</h4>
                    <p>When Leonardo looked at a bird, he saw:</p>
                    <ul style="margin-left: 20px; color: #aaa;">
                        <li><strong>Anatomy:</strong> Bone structure, muscle attachment, feather arrangement</li>
                        <li><strong>Physics:</strong> Lift, drag, thrust, air pressure differential</li>
                        <li><strong>Engineering:</strong> Wing as lever, body as aerodynamic form</li>
                        <li><strong>Mathematics:</strong> Wing-beat frequency, glide ratios, turning radius</li>
                        <li><strong>Painting:</strong> Light on feathers, color gradients, motion blur</li>
                        <li><strong>Philosophy:</strong> Freedom, transcendence, escape from earth</li>
                    </ul>
                    <p style="margin-top: 12px;"><strong>All simultaneously.</strong> This is Level 1 applied with da Vinci consciousness.</p>

                    <h4>Your Challenge: Cross-Domain from Trial One</h4>
                    <p style="color: #fff; background: rgba(139, 0, 255, 0.2); padding: 12px; border-left: 4px solid #8b00ff; margin: 20px 0;">
                        <strong>Do not wait for Level 9 to think like da Vinci.</strong><br><br>
                        On your very next Level 1 trial, when you see "X is north of Y":<br>
                        <strong>1.</strong> Anchor Y to something concrete from a specific domain (e.g., "Chisel" from Sculpture)<br>
                        <strong>2.</strong> Force a domain jump for X (e.g., "Tool" from Engineering, not "Sculpture tool")<br>
                        <strong>3.</strong> Document: "Chisel (Sculpture) ‚Üí Tool (Engineering) = 2 domains"<br><br>
                        You just did da Vinci-level cross-domain synthesis. At Level 1. In 3 seconds.
                    </p>

                    <h4>Historical Validation: Da Vinci's Actual Cross-Domain Jumps</h4>
                    <p>These transformations appear verbatim in Leonardo's notebooks:</p>
                    <table style="width: 100%; border-collapse: collapse; margin: 16px 0; font-size: 0.85rem;">
                        <tr style="background: rgba(52, 152, 219, 0.2);">
                            <th style="padding: 8px; border: 1px solid #555;">Transformation</th>
                            <th style="padding: 8px; border: 1px solid #555;">Domains</th>
                            <th style="padding: 8px; border: 1px solid #555;">Source</th>
                        </tr>
                        <tr>
                            <td style="padding: 8px; border: 1px solid #555;">Bird wing ‚Üí Human arm ‚Üí Lever</td>
                            <td style="padding: 8px; border: 1px solid #555;">Ornithology ‚Üí Anatomy ‚Üí Engineering</td>
                            <td style="padding: 8px; border: 1px solid #555;">Codex on Flight (c. 1505)</td>
                        </tr>
                        <tr>
                            <td style="padding: 8px; border: 1px solid #555;">River flow ‚Üí Blood circulation</td>
                            <td style="padding: 8px; border: 1px solid #555;">Hydrology ‚Üí Cardiovascular Anatomy</td>
                            <td style="padding: 8px; border: 1px solid #555;">Anatomical Studies (c. 1513)</td>
                        </tr>
                        <tr>
                            <td style="padding: 8px; border: 1px solid #555;">Water vortex ‚Üí Hair spiral ‚Üí Shell spiral</td>
                            <td style="padding: 8px; border: 1px solid #555;">Fluid Dynamics ‚Üí Art ‚Üí Malacology</td>
                            <td style="padding: 8px; border: 1px solid #555;">Codex Leicester (c. 1508)</td>
                        </tr>
                        <tr>
                            <td style="padding: 8px; border: 1px solid #555;">Eye lens ‚Üí Camera obscura ‚Üí Painting perspective</td>
                            <td style="padding: 8px; border: 1px solid #555;">Anatomy ‚Üí Optics ‚Üí Art</td>
                            <td style="padding: 8px; border: 1px solid #555;">Manuscript D (c. 1508)</td>
                        </tr>
                        <tr>
                            <td style="padding: 8px; border: 1px solid #555;">Hammer on anvil ‚Üí Thunder ‚Üí Cannon blast</td>
                            <td style="padding: 8px; border: 1px solid #555;">Metallurgy ‚Üí Meteorology ‚Üí Military Engineering</td>
                            <td style="padding: 8px; border: 1px solid #555;">Codex Atlanticus (c. 1490)</td>
                        </tr>
                        <tr>
                            <td style="padding: 8px; border: 1px solid #555;">Lute string vibration ‚Üí Air column resonance</td>
                            <td style="padding: 8px; border: 1px solid #555;">Music Theory ‚Üí Acoustics</td>
                            <td style="padding: 8px; border: 1px solid #555;">Manuscript H (c. 1494)</td>
                        </tr>
                    </table>

                    <h4>Final Insight: The Unity of Knowledge</h4>
                    <p style="color: #aaa;">Leonardo's ultimate discovery was that <strong>all knowledge is connected</strong>. Physics, biology, art, music, engineering‚Äîthese are not isolated islands. They are different languages describing the same underlying patterns.</p>

                    <p style="color: #aaa; margin-top: 12px;">When you force cross-domain transformations in Imagi-World, you're not just playing a memory game. You're <strong>training the cognitive architecture of genius</strong>‚Äîthe ability to see the One in the Many, to recognize that:</p>

                    <ul style="margin-left: 20px; color: #aaa;">
                        <li>A bird wing and a hydraulic piston both embody lever mechanics</li>
                        <li>A river and a bloodstream both demonstrate fluid transport networks</li>
                        <li>A spiral shell and a galaxy both follow logarithmic growth</li>
                        <li>A painting and a mathematical proof both reveal hidden truth</li>
                    </ul>

                    <p style="color: #fff; background: rgba(46, 204, 113, 0.2); padding: 12px; border-left: 4px solid #2ecc71; margin: 20px 0; font-weight: bold;">
                        "Once you have tasted flight, you will forever walk the earth with your eyes turned skyward, for there you have been, and there you will always long to return." ‚ÄîLeonardo da Vinci
                    </p>

                    <p style="color: #8b00ff; font-weight: bold; margin-top: 20px;">Da Vinci did not wait for complexity to think cross-domain. He saw a bird and thought of painting, anatomy, engineering, philosophy‚Äîsimultaneously. You can do this at Level 1. Start now.</p>
                `,
                speech: 'Da Vinci does Imagi-World. Leonardo da Vinci\'s genius was not handling complexity, it was seeing connections across domains. This tutorial teaches you to apply his cross-domain synthesis method to every level of Imagi-World, from Level One to Level Nine. The Core Principle: Cross-Domain Transformation. Da Vinci didn\'t just study birds, he studied birds to design flying machines. He didn\'t just paint, he studied optics to perfect sfumato. Every transformation crossed domains. You can do this at any level. Level One: single atoms lead to two to three domain jumps. Level Three: chains lead to four to five domain jumps. Level Six: meta-relational leads to six to eight domain jumps. Level Nine: triple compounds lead to eight to twelve domain jumps. Level One: Da Vinci Solves X is north of Y. Example One: Y equals Bird wing feather from Ornithology, north to X equals Mechanical pen nib from Engineering and Writing Instruments. Da Vinci\'s connection: In Codex Atlanticus, da Vinci sketched bird feathers alongside pen designs, recognizing that both use flexible vanes or tines to control flow, air for feathers, ink for nibs. The generalization is flexible flow control mechanisms. Domain jump from Ornithology to Engineering. Total: two radically different domains. Example Two: Y equals Water mill wheel from Hydraulic Engineering, south to X equals Human heart valve from Cardiovascular Anatomy. Da Vinci\'s connection: Da Vinci\'s anatomical drawings, circa fifteen thirteen, show heart valves modeled after mill wheel mechanics. Both prevent backflow through rhythmic opening and closing. The specification is one-way flow gate. Domain jump from Hydraulic Engineering to Medicine. Total: two completely different domains. Level One domain count: four unique fields traversed in simple premises, but now with true cross-domain leaps, not subdomain drift. Level Two: Da Vinci Solves X is north of Y is east of Z. Cross-domain chain: Z equals Snail shell spiral from Malacology and Biology, north to Y equals Golden ratio mathematics from Geometry, east to X equals Cathedral dome architecture from Civil Engineering and Architecture. Da Vinci\'s connection: Da Vinci measured snail shells, extracted the phi ratio, and applied it to architectural proportions in his church designs. Three radically different domains crossed in one chain: Biology to Mathematics to Architecture. Total: three completely different domains. Historical note: Da Vinci\'s notebooks, Codex Madrid the Second, contain sketches of nautilus shells with geometric overlays, demonstrating his recognition that biological growth patterns encode universal mathematical proportions applicable to human architecture. Level Three: Da Vinci Solves Multi-Atom Chains. Four-concept cross-domain chain: A equals Eagle embryo wing bud from Embryology, north to B equals Hydraulic piston expansion from Mechanical Engineering, east to C equals Organ pipe bellows from Music and Acoustics, south to D equals Respiratory diaphragm from Human Anatomy. One: Wing bud to Hydraulic piston, biological tissue growth generalized to mechanical expansion principle. Two: Hydraulic piston to Organ bellows, mechanical analogue, both are pressure-driven expansion chambers. Three: Organ bellows to Diaphragm, musical instrument specified to its biological counterpart. Domain progression: Embryology to Engineering to Music to Anatomy. Total: four radically different domains. Da Vinci actually did this. His anatomical notebooks, Windsor Collection, circa fifteen ten to fifteen thirteen, show embryonic development studies alongside hydraulic machines. He designed organ bellows for musical instruments while simultaneously dissecting human lungs. He recognized expansion and contraction as a universal principle across biology, engineering, music, and medicine. Level Six: Da Vinci Solves Direction-Word Spatial Reasoning. Premise: West is north of East, East is west of South. Middle atoms: North is south of South. Da Vinci\'s approach to abstract spatial reasoning. Step One: Anchor direction words to spatial positions. North equals Concept of upward abstraction anchored at spatial position zero, one. South equals Concept of downward specification anchored at spatial position zero, zero. East equals Concept of lateral analogue anchored at spatial position one, zero. West equals Concept of lateral opposite anchored at spatial position negative one, zero. Step Two: Build constraint graph from middle atoms. Middle: North is south of South establishes North must be positioned below South. This creates vertical dependency: South at zero, one, North at zero, zero. Step Three: Verify current premise spatial consistency. West is north of East means West must be above East, vertical relationship. East is west of South means East must be left of South, horizontal relationship. SAT solver validates: No contradiction with established constraints. Step Four: Cross-domain insight. Direction words represent transformation operators from his Treatise on Painting. Spatial relationships encode conceptual hierarchies from his anatomical studies. Constraint solving mirrors his geometric proofs in Codex Atlanticus. Da Vinci\'s actual method: In Manuscript A, circa fourteen ninety-two, da Vinci used directional operators, alto and basso equals up and down, destra and sinistra equals right and left, to encode spatial transformations in architectural designs. He combined these with constraint satisfaction to ensure structural integrity, the exact reasoning Level Six demands. Level Six demands four to six domain jumps when you semantically anchor both operator pairs and analyze their meta-relationship across radically different fields. Level Seven: Da Vinci Solves Compound Operators. Premise: north-south is east of east-west. Left compound, north-south: Seed equals Telescope lens from Optics and Astronomy, apply North to Human eye anatomy from Vision Science and Physiology, apply South to Painting perspective technique from Art and Renaissance Technique. Result: Painting perspective technique. Three domains: Optics to Physiology to Art. Right compound, east-west: Seed equals Ship sail from Maritime Engineering and Navigation, apply East to Bird wing from Ornithology and Flight Mechanics, apply West to Wind pattern analysis from Meteorology and Atmospheric Science. Result: Wind pattern analysis. Three domains: Maritime Engineering to Ornithology to Meteorology. Meta-relation: Is Painting perspective technique east, or analogue, of Wind pattern analysis? Yes. Da Vinci\'s insight: Both are systems for mapping invisible forces onto visible surfaces. Perspective painting captures spatial depth, three-dimensional to two-dimensional optical projection. Wind analysis captures air currents, invisible flow to visible effects. Both translate hidden structure into perceivable form through geometric and observational methods. Level Seven total: six domains: Optics, Physiology, Art, Maritime Engineering, Ornithology, Meteorology. Historical validation: Da Vinci\'s Treatise on Painting directly connects telescope optics to eye anatomy to develop perspective laws. His studies of bird flight, Codex on Flight, explicitly compare sail mechanics to wing aerodynamics. Both transformation chains appear in his actual notebooks. Level Eight: Da Vinci Solves Eight-Direction Diagonals. Premise: northeast-southwest is north of southeast-northwest. Left compound, northeast-southwest: Seed equals Violin string vibration from Acoustics and Music Theory, apply NE, elevated analogue, to Light wave propagation from Optics and Physics, apply SW, material opposite, to Marble quarry silence from Geology and Architecture. Result: Marble quarry silence. Right compound, southeast-northwest: Seed equals Flowing river current from Hydrology and Fluid Dynamics, apply SE, concrete analogue, to Blood vessel circulation from Cardiovascular Medicine, apply NW, abstract opposite, to Contemplative stillness meditation from Philosophy and Contemplative Practice. Result: Contemplative stillness meditation. Meta-relation: Is Marble quarry silence north of Contemplative stillness meditation? No, false. Contemplative meditation is the generalized, abstract, form of intentional silence. Marble quarry is the material, concrete, instance of passive silence. The meditation is north of the quarry, not vice versa. The premise is false, forcing you to recognize the abstraction hierarchy across these radically different domains. Level Eight total: seven domains: Acoustics, Optics, Geology, Hydrology, Medicine, Philosophy, Contemplative Practice. This is Renaissance-level synthesis. Historical note: Da Vinci studied violin string vibrations in Manuscript H, circa fourteen ninety-four, compared wave propagation across sound and light in his optics treatise, analyzed marble quarry stone selection for architecture, notes on Duomo di Milano, compared river flow to blood in Codex Leicester, and advocated meditative observation in his painting instructions. He explicitly connected acoustic waves to light waves to material properties to fluid dynamics to contemplative practice. All seven domains unified. Level Nine: Da Vinci\'s Peak, Triple-Nested Compounds. Example from DaVinci_Does_Nine document. Premise: SE-E-SW is northeast of E-NNE-SSW. Left compound, SE-E-SW: Seed is Bird wing from Ornithology, SE to Human arm anatomy from Human Anatomy, E to Mechanical lever from Engineering, SW to Hydraulic piston from Hydraulic Engineering. Result: Hydraulic piston. Right compound, E-NNE-SSW: Seed is Flowing river from Hydrology, E to Bloodstream from Cardiovascular Anatomy, NNE to Musical harmony propagation from Music Theory and Acoustics, SSW to Stone quarry silence from Geology and Architecture. Result: Stone quarry silence. Meta-relation: Is Hydraulic piston northeast of Stone quarry silence? Da Vinci\'s analysis: Both represent states of potential energy. The piston contains pressurized water ready to release force, dynamic potential. The quarry contains stone ready to be shaped into architecture, material potential. The piston is the abstract elevated analogue, generalized potential. Northeast equals abstract plus analogue. True, match. Level Nine total: eight unique domains: Ornithology, Human Anatomy, Mechanical Engineering, Hydraulic Engineering, Hydrology, Cardiovascular Anatomy, Music Theory, Geology and Architecture. Historical validation: Every transformation above appears in Leonardo\'s actual notebooks. Bird wing to Human arm: Codex on Flight of Birds, comparative anatomy. Arm to Lever: Codex Arundel, biomechanics. Lever to Hydraulic: Codex Leicester, solid to fluid mechanics. River to Blood: Anatomical drawings, circa fifteen thirteen. Blood to Music: Treatise on sound, pulse as tempo. Music to Stone: Architectural designs, acoustic mass versus resonance. Da Vinci\'s Ten Principles for Cross-Domain Synthesis. One: Start concrete, not abstract. Thunder cracking oak, not kinetic energy transfer. Two: Force domain jumps. Every transformation must cross fields. Biology to Engineering, not Biology to Biology. Three: Use sensory anchors. You must be able to see, hear, touch, smell it. Even if abstract, ground it first. Four: Study comparatively. Bird wing equals human arm equals mechanical lever. Find the pattern. Five: Invert for insight. Solid to Fluid, Structure to Chaos, Presence to Absence. Six: Track analogies rigorously. River equals blood equals sound waves equals light rays. Same propagation principle. Seven: Hold multiple domains simultaneously. Physics plus Art plus Engineering in working memory at once. Eight: Find underlying patterns. Spirals in shells, water vortices, hair, galaxies. Same mathematics. Nine: Cross-pollinate relentlessly. Use architecture insights for anatomy, anatomy for painting, painting for optics. Ten: Document connections. Build your personal knowledge graph. Leonardo\'s thirteen thousand notebook pages. Building Your Domain Vocabulary. Da Vinci actively worked across fifty plus domains. Start with ten to fifteen, expand to thirty plus over time. The tutorial includes a table categorizing domains: Natural Sciences include Physics, Chemistry, Biology, Astronomy, Geology, Meteorology. Engineering includes Mechanical, Hydraulic, Civil, Architecture, Optics, Acoustics. Arts include Painting, Sculpture, Music Theory, Literature, Calligraphy. Human Sciences include Anatomy, Psychology, Medicine, Philosophy, Theology. Mathematics includes Geometry, Algebra, Logic, Statistics. Practical Arts include Agriculture, Viticulture, Metallurgy, Textiles, Navigation. Advanced domains for Level eight to nine include Neuroscience, Thermodynamics, Ecology, Cosmology, Epistemology, Symbolic Logic, Game Theory, Cognitive Science, Information Theory, Cryptography, Jurisprudence, Political Science, Economics, Anthropology, Linguistics. Practice Progression Timeline. Week one to two: Level one to three Foundation, two to three domains per trial. Build core vocabulary across ten to fifteen domains. Practice single transformations. Master concrete-to-abstract and abstract-to-concrete jumps. Document your transformations in journal format. Goal: ninety percent accuracy, five-second response time. Week three to four: Level four to six Cross-Field Synthesis, four to six domains. Force domain jumps on every transformation. Chain three concepts across different fields. Begin meta-relational reasoning, operator analysis. Expand vocabulary to twenty to twenty-five domains. Goal: Fluent cross-pollination, no same-domain chains. Week five to eight: Level seven to eight Renaissance Thinking, six to eight domains. Execute compound transformations, two sequential operators. Invent diagonal operator meanings: NE, SE, SW, NW. Maintain eight-direction semantic consistency across trials. Master vocabulary of thirty plus domains. Study historical cross-domain thinkers like da Vinci, Goethe, Feynman. Goal: Simultaneous multi-domain reasoning, rapid switching. Week nine plus: Level nine Da Vinci Mastery, eight to twelve domains. Triple-nested transformation chains, three sequential operators. Sixteen-direction fine-grained operator system. Traverse eight plus domains in single premise. Active vocabulary: forty to fifty domains, passive: sixty plus. Read da Vinci\'s notebooks for inspiration: Codex Leicester, Codex Arundel. Goal: Peak fluid intelligence, universal pattern recognition. The Da Vinci Mindset: Simultaneous Multi-Domain Awareness. When Leonardo looked at a bird, he saw: Anatomy, bone structure, muscle attachment, feather arrangement. Physics, lift, drag, thrust, air pressure differential. Engineering, wing as lever, body as aerodynamic form. Mathematics, wing-beat frequency, glide ratios, turning radius. Painting, light on feathers, color gradients, motion blur. Philosophy, freedom, transcendence, escape from earth. All simultaneously. This is Level One applied with da Vinci consciousness. Your Challenge: Cross-Domain from Trial One. Do not wait for Level Nine to think like da Vinci. On your very next Level One trial, when you see X is north of Y: One, anchor Y to something concrete from a specific domain, for example, Chisel from Sculpture. Two, force a domain jump for X, for example, Tool from Engineering, not Sculpture tool. Three, document: Chisel from Sculpture to Tool from Engineering equals two domains. You just did da Vinci-level cross-domain synthesis. At Level One. In three seconds. Historical Validation: Da Vinci\'s Actual Cross-Domain Jumps. These transformations appear verbatim in Leonardo\'s notebooks. Bird wing to Human arm to Lever: Ornithology to Anatomy to Engineering, from Codex on Flight, circa fifteen oh five. River flow to Blood circulation: Hydrology to Cardiovascular Anatomy, from Anatomical Studies, circa fifteen thirteen. Water vortex to Hair spiral to Shell spiral: Fluid Dynamics to Art to Malacology, from Codex Leicester, circa fifteen oh eight. Eye lens to Camera obscura to Painting perspective: Anatomy to Optics to Art, from Manuscript D, circa fifteen oh eight. Hammer on anvil to Thunder to Cannon blast: Metallurgy to Meteorology to Military Engineering, from Codex Atlanticus, circa fourteen ninety. Lute string vibration to Air column resonance: Music Theory to Acoustics, from Manuscript H, circa fourteen ninety-four. Final Insight: The Unity of Knowledge. Leonardo\'s ultimate discovery was that all knowledge is connected. Physics, biology, art, music, engineering, these are not isolated islands. They are different languages describing the same underlying patterns. When you force cross-domain transformations in Imagi-World, you\'re not just playing a memory game. You\'re training the cognitive architecture of genius, the ability to see the One in the Many, to recognize that: A bird wing and a hydraulic piston both embody lever mechanics. A river and a bloodstream both demonstrate fluid transport networks. A spiral shell and a galaxy both follow logarithmic growth. A painting and a mathematical proof both reveal hidden truth. Quote from Leonardo da Vinci: Once you have tasted flight, you will forever walk the earth with your eyes turned skyward, for there you have been, and there you will always long to return. Da Vinci did not wait for complexity to think cross-domain. He saw a bird and thought of painting, anatomy, engineering, philosophy, simultaneously. You can do this at Level One. Start now.'
            },
            {
                id: 'walkthrough-n2-10',
                title: 'n-Back-2: 10-Trial Walkthrough',
                html: '',
                render: (mount) => renderWalkthroughN2(mount),
                speech: walkthroughN2SpeechText()
            }
        ];

        let guidedExamplesRoot = null;

        function renderGuidedExamples() {
            const mount = document.getElementById('instContent');
            if (!mount) return;

            if (guidedExamplesRoot && mount.dataset.examplesLoaded === '1') {
                mount.innerHTML = '';
                mount.appendChild(guidedExamplesRoot);
                return;
            }

            const examples = getBeginnerExamples();
            const container = document.createElement('div');
            container.id = 'guidedExamples';

            const heading = document.createElement('h3');
            heading.textContent = 'Guided Examples';
            container.appendChild(heading);

            const intro = document.createElement('p');
            intro.textContent = 'Study thirty beginner-friendly mappings. Anchor each letter, follow the compass moves, and confirm the resulting mapping with the provided rationale.';
            container.appendChild(intro);

            const filters = document.createElement('div');
            filters.id = 'examplesFilters';
            filters.innerHTML = `
                <strong>Filter:</strong>
                <button data-f="all" class="active">All</button>
                <button data-f="single">Single-atom</button>
                <button data-f="double-same-head">Two-atom (same head)</button>
                <button data-f="double-dual-head">Two-atom (dual heads)</button>
                <button data-f="triple-chain">Three-atom chains</button>
                <button data-f="quad">Four-atom sets</button>
            `;
            container.appendChild(filters);

            const list = document.createElement('ol');
            list.id = 'examplesList';
            container.appendChild(list);

            function renderList(filter = 'all') {
                list.innerHTML = '';
                examples
                    .filter(ex => filter === 'all' ? true : ex.level === filter)
                    .forEach(ex => {
                        const li = document.createElement('li');
                        li.className = `ex ex-${ex.level}`;
                        li.innerHTML = `
                            <h4>Ex ${ex.id}. ${ex.theme}</h4>
                            <p><strong>Premise:</strong> ${ex.premise}</p>
                            <p><strong>Anchors:</strong> ${ex.anchors.map(([L, c]) => `${L} := "${c}"`).join('; ')}</p>
                            <p><strong>Transforms:</strong> ${ex.transforms.join(' ‚Ä¢ ')}</p>
                            <p><strong>Resulting mapping:</strong> ${ex.mapping.map(([L, c]) => `${L} ‚Üí "${c}"`).join('; ')}</p>
                            <p><em>Why it works:</em> ${ex.rationale}</p>
                            <div class="exActions">
                                <button data-speak="${ex.id}">Speak summary</button>
                                <button data-copy="${ex.id}">Copy to clipboard</button>
                            </div>
                        `;
                        list.appendChild(li);
                    });
            }

            renderList('all');

            container.addEventListener('click', (event) => {
                const button = event.target.closest('button');
                if (!button) return;
                const filter = button.dataset.f;
                if (filter) {
                    container.querySelectorAll('#examplesFilters button').forEach(btn => btn.classList.remove('active'));
                    button.classList.add('active');
                    renderList(filter);
                    return;
                }
                if (button.dataset.speak) {
                    const id = parseInt(button.dataset.speak, 10);
                    const example = examples.find(x => x.id === id);
                    if (example) {
                        speakOnce(summarizeExample(example));
                    }
                }
                if (button.dataset.copy) {
                    const id = parseInt(button.dataset.copy, 10);
                    const example = examples.find(x => x.id === id);
                    if (example) {
                        const summary = summarizeExample(example);
                        if (navigator.clipboard && typeof navigator.clipboard.writeText === 'function') {
                            navigator.clipboard.writeText(summary).catch(() => {
                                window.prompt('Copy this example summary:', summary);
                            });
                        } else {
                            window.prompt('Copy this example summary:', summary);
                        }
                    }
                }
            });

            function summarizeExample(ex) {
                const line1 = `Premise: ${ex.premise}`;
                const line2 = `Anchors: ${ex.anchors.map(([L, c]) => `${L} equals ${c}`).join('; ')}.`;
                const line3 = `Mapping: ${ex.mapping.map(([L, c]) => `${L} to ${c}`).join('; ')}.`;
                return `${line1} ${line2} ${line3}`;
            }

            mount.innerHTML = '';
            mount.appendChild(container);
            mount.dataset.examplesLoaded = '1';
            guidedExamplesRoot = container;
        }

        function getBeginnerExamples() {
            return [
                // --- Single-atom (10) ---
                { id:1, level:"single", theme:"Learning ‚Äî Up-shift",
                  premise:"N is north of J.",
                  anchors:[["J","Fact"]],
                  transforms:["North(J‚ÜíN): up-shift Fact ‚Üí Theory"],
                  mapping:[["J","Fact"],["N","Theory"]],
                  rationale:"North is higher abstraction; Theory stands above Fact."
                },
                { id:2, level:"single", theme:"Biology ‚Äî Down-shift",
                  premise:"B is south of A.",
                  anchors:[["A","Animal"]],
                  transforms:["South(A‚ÜíB): down-shift Animal ‚Üí Dog"],
                  mapping:[["A","Animal"],["B","Dog"]],
                  rationale:"South is more specific; Dog is an instance of Animal."
                },
                { id:3, level:"single", theme:"Illumination ‚Äî Analogue",
                  premise:"C is east of D.",
                  anchors:[["D","Candle"]],
                  transforms:["East(D‚ÜíC): analogue of Candle ‚Üí Lantern"],
                  mapping:[["D","Candle"],["C","Lantern"]],
                  rationale:"East is same-role/sibling; Lantern parallels Candle."
                },
                { id:4, level:"single", theme:"Order/Chaos ‚Äî Opposite",
                  premise:"E is west of F.",
                  anchors:[["F","Order"]],
                  transforms:["West(F‚ÜíE): opposite of Order ‚Üí Chaos"],
                  mapping:[["F","Order"],["E","Chaos"]],
                  rationale:"West is counterpart; Chaos opposes Order."
                },
                { id:5, level:"single", theme:"Technology ‚Äî Up-shift",
                  premise:"G is north of H.",
                  anchors:[["H","Program"]],
                  transforms:["North(H‚ÜíG): Program ‚Üí Platform"],
                  mapping:[["H","Program"],["G","Platform"]],
                  rationale:"Platform generalizes programs; higher on the Arc."
                },
                { id:6, level:"single", theme:"Music ‚Äî Down-shift",
                  premise:"I is south of K.",
                  anchors:[["K","Song"]],
                  transforms:["South(K‚ÜíI): Song ‚Üí Verse"],
                  mapping:[["K","Song"],["I","Verse"]],
                  rationale:"Verse is a component of a Song."
                },
                { id:7, level:"single", theme:"Navigation ‚Äî Analogue",
                  premise:"L is east of M.",
                  anchors:[["M","Map"]],
                  transforms:["East(M‚ÜíL): Map ‚Üí Chart"],
                  mapping:[["M","Map"],["L","Chart"]],
                  rationale:"Chart is a sibling format to Map."
                },
                { id:8, level:"single", theme:"Emotion ‚Äî Opposite",
                  premise:"P is west of O.",
                  anchors:[["O","Calm"]],
                  transforms:["West(O‚ÜíP): Calm ‚Üí Agitation"],
                  mapping:[["O","Calm"],["P","Agitation"]],
                  rationale:"Agitation is the counter-state of Calm."
                },
                { id:9, level:"single", theme:"Finance ‚Äî Up-shift",
                  premise:"Q is north of R.",
                  anchors:[["R","Expense"]],
                  transforms:["North(R‚ÜíQ): Expense ‚Üí Budget"],
                  mapping:[["R","Expense"],["Q","Budget"]],
                  rationale:"Budget organizes expenses; higher level."
                },
                { id:10, level:"single", theme:"Astronomy ‚Äî Down-shift",
                  premise:"T is south of S.",
                  anchors:[["S","Galaxy"]],
                  transforms:["South(S‚ÜíT): Galaxy ‚Üí Star"],
                  mapping:[["S","Galaxy"],["T","Star"]],
                  rationale:"A Star is a constituent of a Galaxy."
                },

                // --- Two-atom: same head (8) ---
                { id:11, level:"double-same-head", theme:"Theory & Order ‚Äî Compound",
                  premise:"Z is south of J; Z is west of P.",
                  anchors:[["J","Theory"],["P","Order"]],
                  transforms:["South(J‚ÜíZ): Theory ‚Üí Example","West(P‚ÜíZ): Order ‚Üí Chaos (compound: Chaotic example)"],
                  mapping:[["J","Theory"],["P","Order"],["Z","Chaotic example"]],
                  rationale:"Z must satisfy both; a 'Chaotic example' fits down-shift and opposition."
                },
                { id:12, level:"double-same-head", theme:"Writing ‚Äî Paragraph role",
                  premise:"A is north of B; A is east of C.",
                  anchors:[["B","Sentence"],["C","Section"]],
                  transforms:["North(B‚ÜíA): Sentence ‚Üí Paragraph","East(C‚ÜíA): Section ‚Üí Paragraph (sibling)"],
                  mapping:[["B","Sentence"],["C","Section"],["A","Paragraph"]],
                  rationale:"Paragraph stands above a Sentence and parallels a Section in function."
                },
                { id:13, level:"double-same-head", theme:"Physics ‚Äî Heat vs Cold",
                  premise:"D is south of C; D is west of E.",
                  anchors:[["C","Energy"],["E","Cold"]],
                  transforms:["South(C‚ÜíD): Energy ‚Üí Heat","West(E‚ÜíD): Cold ‚Üí Heat"],
                  mapping:[["C","Energy"],["E","Cold"],["D","Heat"]],
                  rationale:"Heat is a specific form of Energy and the counter to Cold."
                },
                { id:14, level:"double-same-head", theme:"Light ‚Äî Coherent mapping",
                  premise:"H is east of I; H is north of J.",
                  anchors:[["I","Lamp"],["J","Flame"]],
                  transforms:["East(I‚ÜíH): Lamp ‚Üí Lantern","North(J‚ÜíH): Flame ‚Üí Lantern (higher containment)"],
                  mapping:[["I","Lamp"],["J","Flame"],["H","Lantern"]],
                  rationale:"Lantern is a sibling of Lamp, and stands above Flame as container/assembly."
                },
                { id:15, level:"double-same-head", theme:"Ethics ‚Äî Lying as behavior",
                  premise:"K is west of L; K is south of M.",
                  anchors:[["L","Truth"],["M","Behavior"]],
                  transforms:["West(L‚ÜíK): Truth ‚Üí Lie","South(M‚ÜíK): Behavior ‚Üí Lie"],
                  mapping:[["L","Truth"],["M","Behavior"],["K","Lie"]],
                  rationale:"A Lie opposes Truth and is a specific Behavior."
                },
                { id:16, level:"double-same-head", theme:"Literature ‚Äî Forms",
                  premise:"N is east of O; N is south of P.",
                  anchors:[["O","Novel"],["P","Literature"]],
                  transforms:["East(O‚ÜíN): Novel ‚Üí Short story","South(P‚ÜíN): Literature ‚Üí Short story"],
                  mapping:[["O","Novel"],["P","Literature"],["N","Short story"]],
                  rationale:"Short story is a sibling to Novel and a specific of Literature."
                },
                { id:17, level:"double-same-head", theme:"Civics ‚Äî Regulation vs Anarchy",
                  premise:"Q is north of R; Q is west of S.",
                  anchors:[["R","Procedure"],["S","Anarchy"]],
                  transforms:["North(R‚ÜíQ): Procedure ‚Üí Policy","West(S‚ÜíQ): Anarchy ‚Üí Policy"],
                  mapping:[["R","Procedure"],["S","Anarchy"],["Q","Policy"]],
                  rationale:"Policy sits above Procedure and opposes Anarchy's absence of rules."
                },
                { id:18, level:"double-same-head", theme:"Roles ‚Äî Medicine",
                  premise:"T is east of U; T is west of V.",
                  anchors:[["U","Doctor"],["V","Patient"]],
                  transforms:["East(U‚ÜíT): Doctor ‚Üí Physician","West(V‚ÜíT): Patient ‚Üí Physician (counter-role)"],
                  mapping:[["U","Doctor"],["V","Patient"],["T","Physician"]],
                  rationale:"Physician is a synonym/analogue of Doctor and the counter-role to Patient."
                },

                // --- Two-atom: dual heads (6) ---
                { id:19, level:"double-dual-head", theme:"Data & Tools",
                  premise:"W is north of X; Y is east of Z.",
                  anchors:[["X","Data"],["Z","Hammer"]],
                  transforms:["North(X‚ÜíW): Data ‚Üí Information","East(Z‚ÜíY): Hammer ‚Üí Tool"],
                  mapping:[["X","Data"],["W","Information"],["Z","Hammer"],["Y","Tool"]],
                  rationale:"Information abstracts Data; Tool parallels Hammer."
                },
                { id:20, level:"double-dual-head", theme:"Order & Nature",
                  premise:"A is west of B; C is south of D.",
                  anchors:[["B","Order"],["D","Tree"]],
                  transforms:["West(B‚ÜíA): Order ‚Üí Chaos","South(D‚ÜíC): Tree ‚Üí Branch"],
                  mapping:[["B","Order"],["A","Chaos"],["D","Tree"],["C","Branch"]],
                  rationale:"Chaos opposes Order; Branch is part of Tree."
                },
                { id:21, level:"double-dual-head", theme:"Transport & Cities",
                  premise:"E is east of F; G is north of H.",
                  anchors:[["F","Ship"],["H","Town"]],
                  transforms:["East(F‚ÜíE): Ship ‚Üí Boat (sibling craft)","North(H‚ÜíG): Town ‚Üí City"],
                  mapping:[["F","Ship"],["E","Boat"],["H","Town"],["G","City"]],
                  rationale:"Boat parallels Ship; City stands above Town."
                },
                { id:22, level:"double-dual-head", theme:"Light & Art",
                  premise:"I is west of J; K is east of L.",
                  anchors:[["J","Light"],["L","Poem"]],
                  transforms:["West(J‚ÜíI): Light ‚Üí Darkness","East(L‚ÜíK): Poem ‚Üí Song (sibling artform)"],
                  mapping:[["J","Light"],["I","Darkness"],["L","Poem"],["K","Song"]],
                  rationale:"Darkness is the counter-state to Light; Song parallels Poem."
                },
                { id:23, level:"double-dual-head", theme:"Systems & Life",
                  premise:"M is south of N; O is west of P.",
                  anchors:[["N","System"],["P","Life"]],
                  transforms:["South(N‚ÜíM): System ‚Üí Module","West(P‚ÜíO): Life ‚Üí Death"],
                  mapping:[["N","System"],["M","Module"],["P","Life"],["O","Death"]],
                  rationale:"Module is a part of a System; Death opposes Life."
                },
                { id:24, level:"double-dual-head", theme:"Food & Geography",
                  premise:"Q is east of R; S is south of T.",
                  anchors:[["R","Breakfast"],["T","Continent"]],
                  transforms:["East(R‚ÜíQ): Breakfast ‚Üí Brunch (analogue)","South(T‚ÜíS): Continent ‚Üí Country"],
                  mapping:[["R","Breakfast"],["Q","Brunch"],["T","Continent"],["S","Country"]],
                  rationale:"Brunch parallels Breakfast; Country is within a Continent."
                },

                // --- Three-atom chains (4) ---
                { id:25, level:"triple-chain", theme:"Logic ‚Äî Counterexample path",
                  premise:"A is south of B; C is east of A; D is west of C.",
                  anchors:[["B","Theory"]],
                  transforms:["South(B‚ÜíA): Theory ‚Üí Example","East(A‚ÜíC): Example ‚Üí Case study","West(C‚ÜíD): Case study ‚Üí Counterexample"],
                  mapping:[["B","Theory"],["A","Example"],["C","Case study"],["D","Counterexample"]],
                  rationale:"A down; C lateral sibling; D as foil to C‚Äîconsistent chain."
                },
                { id:26, level:"triple-chain", theme:"Projects ‚Äî Work breakdown",
                  premise:"E is north of F; G is south of E; H is east of G.",
                  anchors:[["F","Task"]],
                  transforms:["North(F‚ÜíE): Task ‚Üí Project","South(E‚ÜíG): Project ‚Üí Subtask","East(G‚ÜíH): Subtask ‚Üí Work item"],
                  mapping:[["F","Task"],["E","Project"],["G","Subtask"],["H","Work item"]],
                  rationale:"Up then down then sideways within the same work hierarchy."
                },
                { id:27, level:"triple-chain", theme:"Deception ‚Äî Roles",
                  premise:"I is west of J; K is north of I; L is east of K.",
                  anchors:[["J","Truth"]],
                  transforms:["West(J‚ÜíI): Truth ‚Üí Lie","North(I‚ÜíK): Lie ‚Üí Deception strategy","East(K‚ÜíL): Deception strategy ‚Üí Ruse"],
                  mapping:[["J","Truth"],["I","Lie"],["K","Deception strategy"],["L","Ruse"]],
                  rationale:"Counter-role, then abstraction, then sibling tactic."
                },
                { id:28, level:"triple-chain", theme:"Design ‚Äî Deliverables",
                  premise:"M is east of N; O is north of M; P is south of O.",
                  anchors:[["N","Sketch"]],
                  transforms:["East(N‚ÜíM): Sketch ‚Üí Outline","North(M‚ÜíO): Outline ‚Üí Design","South(O‚ÜíP): Design ‚Üí Wireframe"],
                  mapping:[["N","Sketch"],["M","Outline"],["O","Design"],["P","Wireframe"]],
                  rationale:"Analogue within drafting, then up to Design, then down to a specific artifact."
                },

                // --- Four-atom (2) ---
                { id:29, level:"quad", theme:"Learning ‚Äî Full weave",
                  premise:"H is east of R; Y is north of X; R is south of Y; Z is west of X.",
                  anchors:[["X","Fact"]],
                  transforms:[
                    "North(X‚ÜíY): Fact ‚Üí Theory",
                    "South(Y‚ÜíR): Theory ‚Üí Example",
                    "East(R‚ÜíH): Example ‚Üí Case study",
                    "West(X‚ÜíZ): Fact ‚Üí Fiction"
                  ],
                  mapping:[["X","Fact"],["Y","Theory"],["R","Example"],["H","Case study"],["Z","Fiction"]],
                  rationale:"Classic quartet: up from Fact, down to Example, lateral to Case study, counter to Fiction."
                },
                { id:30, level:"quad", theme:"Education ‚Äî Pedagogy weave",
                  premise:"A is west of D; B is north of A; C is east of B; D is south of C.",
                  anchors:[["A","Play"],["B","Pedagogy"],["C","Andragogy"]],
                  transforms:[
                    "Given A=Play; West requires D to be its structured counterpart ‚Üí Lesson",
                    "North(A‚ÜíB): Play ‚Üí Pedagogy (framework above)",
                    "East(B‚ÜíC): Pedagogy ‚Üí Andragogy (sibling adult-learning)",
                    "South(C‚ÜíD): Andragogy ‚Üí Lesson (specific instructional unit)"
                  ],
                  mapping:[["A","Play"],["B","Pedagogy"],["C","Andragogy"],["D","Lesson"]],
                  rationale:"Play vs Lesson as counter-styles; Pedagogy above Play; Andragogy as sibling to Pedagogy; Lesson as a concrete unit under Andragogy."
                }
            ];
        }

        function walkthroughN2SpeechText() {
            return [
                'n-back two, ten trial walkthrough.',
                'Algorithm reminder: symbol, map a thought, transform by the operation, pair letter and thought, repeat across atoms, recall and update prior pairings when letters return.',
                'Theme: illumination and understanding.',
                'Anchors: J equals Candle; D equals Fireworks; X equals Observation; Y equals Generalization; Z equals Anomaly.',
                'Trial one: D is north of J. Trial two: Z is west of X; Z is south of Y.',
                'Trial three: J is south of D. Match with trial one.',
                'Trial four: X is east of Z; Y is north of Z. Match with trial two.',
                'Trial five: D is east of J. No match with trial three.',
                'Trial six: Z is west of X; Z is south of Y. Match with trial four.',
                'Trial seven: J is west of D. Match with trial five.',
                'Trial eight: X is east of Z. No match with trial six.',
                'Trial nine: D is east of J. Match with trial seven.',
                'Trial ten: Z is west of X. Match with trial eight.',
                'When a letter returns, reuse its concept and update by the new relation; keep coherence across trials.'
            ].join(' ');
        }

        function renderWalkthroughN2(mount = document.getElementById('instContent')) {
            if (!mount) return;

            const html = `
            <div id="walkthroughN2" class="inst-section">
                <h3>n-Back-2: 10-Trial Walkthrough</h3>

                <p class="brandline"><strong>Imagi-World trains maximized imagination across the Arc of Abstraction.</strong> You map lived concepts onto letters and move them North/South/East/West while the logic engine keeps relations exact.</p>

                <h4>Quick Algorithm (repeat this every premise)</h4>
                <ol class="algo">
                    <li><strong>Symbol ‚Üí</strong> Note the letter(s) in the current premise.</li>
                    <li><strong>Map a thought ‚Üí</strong> Anchor each new letter to a vivid concept (your stream of consciousness).</li>
                    <li><strong>Transform ‚Üí</strong> Apply the premise operation to that concept: North = up-shift (more general/intense); South = down-shift (more specific/concrete); East = analogue/sibling; West = opposite/counter-role.</li>
                    <li><strong>Pairing ‚Üí</strong> Record the resulting <em>letter ‚Üî thought</em> pairing for this trial.</li>
                    <li><strong>Rinse/Repeat ‚Üí</strong> For multi-atom premises, repeat for each relation in the utterance (semicolon = tiny pause).</li>
                    <li><strong>Recall & Update ‚Üí</strong> When a letter reappears later, reuse its prior mapping and <em>update</em> it by the new relation (e.g., if K is north of J, then when P is above K you can infer new context linking P and J, too).</li>
                </ol>

                <h4>Theme for this walkthrough</h4>
                <p>We use a coherent theme: <em>Illumination &amp; Understanding</em>. First-time anchors:</p>
                <ul class="anchors">
                    <li>J := Candle (steady light)</li>
                    <li>D := Fireworks (intense/brief light)</li>
                    <li>X := Observation (raw sighting)</li>
                    <li>Y := Generalization (above observations)</li>
                    <li>Z := Anomaly (foil to a typical observation)</li>
                </ul>

                <h4>Ten Trials at n-Back-2 (MATCH means current ‚â° trial t‚àí2 under allowed inversions)</h4>

                <ol class="trials">
                    <li>
                        <p><strong>Trial 1 ‚Äî Premise:</strong> D is north of J.</p>
                        <p><strong>Mapping:</strong> J=Candle; North ‚Üí D=Fireworks (up-shift intensity).</p>
                        <p><strong>n-back-2:</strong> No comparison yet.</p>
                    </li>
                    <li>
                        <p><strong>Trial 2 ‚Äî Premise:</strong> Z is west of X; Z is south of Y.</p>
                        <p><strong>Mapping:</strong> X=Observation; Y=Generalization; West ‚Üí Z=Anomaly (foil to typical observation); South from Y confirms Z is specific.</p>
                        <p><strong>n-back-2:</strong> No comparison yet.</p>
                    </li>
                    <li>
                        <p><strong>Trial 3 ‚Äî Premise:</strong> J is south of D.</p>
                        <p><strong>Mapping:</strong> Reuse J=Candle, D=Fireworks; South means Candle is less intense than Fireworks.</p>
                        <p><strong>n-back-2 vs Trial 1:</strong> <span class="match">MATCH</span> (inverse: D north of J ‚Üî J south of D).</p>
                    </li>
                    <li>
                        <p><strong>Trial 4 ‚Äî Premise:</strong> X is east of Z; Y is north of Z.</p>
                        <p><strong>Mapping:</strong> Reuse X, Y, Z; East: Observation is a sibling to Anomaly; North: Generalization above Anomaly.</p>
                        <p><strong>n-back-2 vs Trial 2:</strong> <span class="match">MATCH</span> (Z west of X ‚Üî X east of Z; Z south of Y ‚Üî Y north of Z).</p>
                    </li>
                    <li>
                        <p><strong>Trial 5 ‚Äî Premise:</strong> D is east of J.</p>
                        <p><strong>Mapping:</strong> Reuse D, J; East: both are light sources (analogue). Optionally note D as "burst light".</p>
                        <p><strong>n-back-2 vs Trial 3:</strong> <span class="nomatch">NO MATCH</span> (Trial 3 was South; axis mismatch, not an allowed inversion).</p>
                    </li>
                    <li>
                        <p><strong>Trial 6 ‚Äî Premise:</strong> Z is west of X; Z is south of Y.</p>
                        <p><strong>Mapping:</strong> Same structure as Trial 2; reuse without re-anchoring.</p>
                        <p><strong>n-back-2 vs Trial 4:</strong> <span class="match">MATCH</span> (inverse pair of atoms holds).</p>
                    </li>
                    <li>
                        <p><strong>Trial 7 ‚Äî Premise:</strong> J is west of D.</p>
                        <p><strong>Mapping:</strong> Reuse J, D; West: Candle as counter to Fireworks (steady vs fleeting).</p>
                        <p><strong>n-back-2 vs Trial 5:</strong> <span class="match">MATCH</span> (D east of J ‚Üî J west of D).</p>
                    </li>
                    <li>
                        <p><strong>Trial 8 ‚Äî Premise:</strong> X is east of Z.</p>
                        <p><strong>Mapping:</strong> Reuse X, Z; East: Observation as sibling to Anomaly.</p>
                        <p><strong>n-back-2 vs Trial 6:</strong> <span class="nomatch">NO MATCH</span> (parity mismatch: k=1 vs k=2).</p>
                    </li>
                    <li>
                        <p><strong>Trial 9 ‚Äî Premise:</strong> D is east of J.</p>
                        <p><strong>Mapping:</strong> Reuse D, J; analogue relation sustained.</p>
                        <p><strong>n-back-2 vs Trial 7:</strong> <span class="match">MATCH</span> (inverse of Trial 7).</p>
                    </li>
                    <li>
                        <p><strong>Trial 10 ‚Äî Premise:</strong> Z is west of X.</p>
                        <p><strong>Mapping:</strong> Reuse Z, X; West: Anomaly as foil to Observation.</p>
                        <p><strong>n-back-2 vs Trial 8:</strong> <span class="match">MATCH</span> (inverse of Trial 8).</p>
                    </li>
                </ol>

                <h4>When the same letter returns: do this</h4>
                <ul class="returns">
                    <li><strong>Reuse</strong> the original concept; don't re-anchor.</li>
                    <li><strong>Check</strong> the new relation versus that concept (N up, S down, E analogue, W opposite).</li>
                    <li>If a letter must satisfy two relations, use a <em>compound nuance</em> ("chaotic example", "burst light") while keeping identity.</li>
                    <li><strong>Reframe</strong> only if the old choice breaks consistency across trials; if you reframe, note it.</li>
                    <li><strong>Infer context across letters:</strong> if K is north of J and P is above K, then P sits above J as well (transitively in your mental map). Keep your analogies coherent with such inferences while remembering the game's logical engine remains the final judge of matches.</li>
                </ul>

                <p class="closing"><strong>Mantra:</strong> Anchor ‚Üí Transform ‚Üí Cohere ‚Üí Commit ‚Üí Recall ‚Üí Update.</p>

                <div class="actions">
                    <button id="walkthroughN2Speak">Read this walkthrough aloud</button>
                    <button id="walkthroughN2Copy">Copy walkthrough text</button>
                </div>
            </div>
            `;

            mount.innerHTML = html;

            const speakBtn = mount.querySelector('#walkthroughN2Speak');
            const copyBtn = mount.querySelector('#walkthroughN2Copy');

            if (speakBtn) {
                speakBtn.addEventListener('click', () => {
                    if (typeof speakOnce === 'function') {
                        speakOnce(walkthroughN2SpeechText());
                    }
                });
            }

            if (copyBtn) {
                copyBtn.addEventListener('click', async () => {
                    const source = mount.querySelector('#walkthroughN2');
                    if (!source) return;
                    const text = source.innerText.trim();
                    try {
                        if (navigator.clipboard && typeof navigator.clipboard.writeText === 'function') {
                            await navigator.clipboard.writeText(text);
                        } else {
                            window.prompt('Copy this walkthrough text:', text);
                        }
                    } catch (err) {
                        console.warn('Clipboard write failed', err);
                        window.prompt('Copy this walkthrough text:', text);
                    }
                });
            }
        }

        (function registerWalkthroughN2Tab() {
            const tabs = document.getElementById('instTabs');
            if (!tabs) return;
            if (tabs.querySelector('button[data-tab="walkthrough-n2-10"]')) {
                return;
            }
            const btn = document.createElement('button');
            btn.textContent = 'n-Back-2: 10-Trial Walkthrough';
            btn.setAttribute('data-tab', 'walkthrough-n2-10');
            tabs.appendChild(btn);
        })();

        async function speakOnce(text) {
            if (!text) return;
            if (!engine || !engine.voice || !engine.voice.voiceReady) return;
            if (typeof engine.voice.cancelAndWait === 'function') {
                await engine.voice.cancelAndWait();
            }
            engine.voice.speak(text, engine.voice.sessionToken);
        }

        const SANDBOX_TRANSFORMS = {
            N: {
                forward: (value) => `Up-shift(${value})`,
                reverse: (value) => `Down-shift(${value})`
            },
            S: {
                forward: (value) => `Down-shift(${value})`,
                reverse: (value) => `Up-shift(${value})`
            },
            E: {
                forward: (value) => `Analogue(${value})`,
                reverse: (value) => `Analogue(${value})`
            },
            W: {
                forward: (value) => `Opposite(${value})`,
                reverse: (value) => `Opposite(${value})`
            }
        };

        const AdvancePolicy = Object.freeze({ ACTIVE: 'active', LISTEN: 'listen' });
        let session = null;

        function makeEpoch() {
            const cryptoSource = (typeof crypto !== 'undefined' && crypto?.getRandomValues)
                ? crypto.getRandomValues(new Uint32Array(1))[0]
                : Date.now();
            const random = Math.floor(Math.random() * 1e9);
            return (cryptoSource ^ random) >>> 0;
        }

        function newSession(engine) {
            return {
                epoch: makeEpoch(),
                numTrials: engine.applyNumTrialsFromUI(),
                trialIndex: 0,
                policy: loadListenOnly() ? AdvancePolicy.LISTEN : AdvancePolicy.ACTIVE,
                abort: new AbortController(),
                trialToken: 0,
                phaseToken: 0,
                omissions: 0
            };
        }

        function valid(sess, trialToken, phaseToken) {
            // CRITICAL FIX: More defensive validation with detailed logging
            if (!session) {
                // Don't log this - it's normal during session transitions
                return false;
            }
            if (!sess) {
                console.warn('valid() failed: sess parameter is null/undefined');
                return false;
            }
            if (sess.epoch !== session.epoch) {
                // Don't log this - it's normal when a new session starts
                return false;
            }
            if (trialToken !== session.trialToken) {
                console.warn(`valid() failed: trialToken mismatch - expected ${session.trialToken}, got ${trialToken}`);
                return false;
            }
            if (phaseToken && phaseToken !== session.phaseToken) {
                // Don't log phase mismatches - they're common during async operations
                return false;
            }
            if (sess.abort && sess.abort.signal && sess.abort.signal.aborted) {
                // Don't log this - it's normal when session is being stopped
                return false;
            }
            return true;
        }

        const SpeechGate = {
            trialSpeakId: 0,
            inFlight: false,
            explicitRepeatPhase: 0,
            flightToken: null
        };

        function resetSpeechGateForTrial() {
            SpeechGate.trialSpeakId += 1;
            SpeechGate.inFlight = false;
            SpeechGate.flightToken = null;
        }

        function noteExplicitRepeat() {
            SpeechGate.explicitRepeatPhase += 1;
        }

        const TTSMon = { starts: 0, ends: 0 };

        function instrumentUtterance(utterance) {
            if (!utterance || typeof utterance.addEventListener !== 'function') {
                return;
            }
            utterance.addEventListener('start', () => { TTSMon.starts += 1; });
            utterance.addEventListener('end', () => { TTSMon.ends += 1; });
        }

        if (typeof window !== 'undefined') {
            window.SpeechGate = SpeechGate;
            window.TTSMon = TTSMon;
        }

        const Timer = (() => {
            let id = 0;
            const live = new Map();

            function clear(timerId) {
                const entry = live.get(timerId);
                if (!entry) return;
                clearTimeout(entry.handle);
                live.delete(timerId);
            }

            function set(label, ms, trialToken, signal, cb) {
                const timerId = ++id;
                const handle = setTimeout(() => {
                    live.delete(timerId);
                    // Always call callback - validation should be done by caller if needed
                    if (cb) cb();
                }, ms);
                live.set(timerId, { handle, label, trialToken, started: performance.now() });
                if (signal) {
                    signal.addEventListener('abort', () => clear(timerId), { once: true });
                }
                return timerId;
            }

            function cancelAll() {
                for (const entry of live.values()) {
                    clearTimeout(entry.handle);
                }
                live.clear();
            }

            return { set, clear, cancelAll, live };
        })();

        let heartbeat = null;

        function clearHeartbeat() {
            if (heartbeat) {
                clearInterval(heartbeat);
                heartbeat = null;
            }
        }

        function loadNumTrials() {
            const v = parseInt(localStorage.getItem(NUM_TRIALS_KEY) || '20', 10);
            const clamped = Math.min(10000, Math.max(1, isNaN(v) ? 20 : v));
            numTrialsInput.value = String(clamped);
            numTrialsSlider.value = String(Math.min(500, clamped));
            numTrialsDisplay.textContent = `Trials: ${clamped}`;
            return clamped;
        }

        function persistNumTrials(v) {
            const clamped = Math.min(10000, Math.max(1, v | 0));
            localStorage.setItem(NUM_TRIALS_KEY, String(clamped));
            numTrialsDisplay.textContent = `Trials: ${clamped}`;
            if (clamped <= 500) numTrialsSlider.value = String(clamped);
            numTrialsInput.value = String(clamped);
            return clamped;
        }

        numTrialsInput.addEventListener('change', () => {
            const value = parseInt(numTrialsInput.value, 10);
            persistNumTrials(isNaN(value) ? 20 : value);
        });

        numTrialsSlider.addEventListener('input', () => {
            const value = parseInt(numTrialsSlider.value, 10);
            persistNumTrials(isNaN(value) ? 20 : value);
        });

        const initialNumTrials = loadNumTrials();

        function sessionDefaults() {
            return {
                state: "STOPPED",
                trialIndex: 0,
                numTrials: initialNumTrials,
                seedSession: null,
                n: parseInt(document.getElementById('n-slider').value, 10),
                k: parseInt(document.getElementById('k-slider').value, 10),
                secondsPerTrial: parseFloat(document.getElementById('spt-slider').value)
            };
        }


        function cryptoRandom32() {
            if (window.crypto && window.crypto.getRandomValues) {
                const arr = new Uint32Array(1);
                window.crypto.getRandomValues(arr);
                return arr[0] >>> 0;
            }

            let x = Date.now() ^ Math.floor(Math.random() * 0xffffffff);
            x ^= x << 13;
            x ^= x >>> 17;
            x ^= x << 5;
            return x >>> 0;
        }

        function fnv1aHash(parts) {
            let hash = 0x811c9dc5;
            for (const part of parts) {
                const value = (part >>> 0);
                hash ^= value;
                hash = Math.imul(hash, 0x01000193);
            }
            return hash >>> 0;
        }

        class Mulberry32 {
            constructor(seed) {
                this.state = seed >>> 0;
            }

            next() {
                let t = this.state += 0x6D2B79F5;
                t = Math.imul(t ^ t >>> 15, t | 1);
                t ^= t + Math.imul(t ^ t >>> 7, t | 61);
                return ((t ^ t >>> 14) >>> 0) / 4294967296;
            }

            nextInt(min, max) {
                return Math.floor(this.next() * (max - min + 1)) + min;
            }

            choice(array) {
                return array[Math.floor(this.next() * array.length)];
            }

            shuffle(array) {
                const arr = [...array];
                for (let i = arr.length - 1; i > 0; i--) {
                    const j = Math.floor(this.next() * (i + 1));
                    [arr[i], arr[j]] = [arr[j], arr[i]];
                }
                return arr;
            }

            weightedChoice(items, weights) {
                const cumulative = [];
                let total = 0;
                for (const weight of weights) {
                    total += weight;
                    cumulative.push(total);
                }
                const r = this.next() * total;
                for (let i = 0; i < cumulative.length; i++) {
                    if (r <= cumulative[i]) return items[i];
                }
                return items[items.length - 1];
            }

            nextBetween(min, max) {
                return min + (max - min) * this.next();
            }
        }

        class SeedManager {
            constructor() {
                this.runCounterKey = 'relational-nback-run-counter';
                this.seedKey = 'relational-nback-last-seed';
                this.lockKey = 'relational-nback-lock-seed';
                this.sessionSeed = null;
                this.runCounter = this.loadRunCounter();
            }

            loadRunCounter() {
                const raw = localStorage.getItem(this.runCounterKey);
                const parsed = raw ? parseInt(raw, 10) : 0;
                return Number.isFinite(parsed) ? parsed : 0;
            }

            getLockPreference() {
                return localStorage.getItem(this.lockKey) === 'true';
            }

            setLockPreference(lock) {
                localStorage.setItem(this.lockKey, lock ? 'true' : 'false');
            }

            incrementRunCounter() {
                this.runCounter += 1;
                localStorage.setItem(this.runCounterKey, String(this.runCounter));
                return this.runCounter;
            }

            generateSessionSeed(lockSeed) {
                if (lockSeed) {
                    const existing = localStorage.getItem(this.seedKey);
                    if (existing) {
                        this.sessionSeed = parseInt(existing, 10) >>> 0;
                        return this.sessionSeed;
                    }
                }

                const counter = this.incrementRunCounter();
                const random = cryptoRandom32();
                const salt = Date.now() >>> 0;
                const seed = fnv1aHash([counter, random, salt]);
                this.sessionSeed = seed;
                localStorage.setItem(this.seedKey, String(seed));
                return seed;
            }

            persistSessionSeed(seed) {
                this.sessionSeed = seed;
                localStorage.setItem(this.seedKey, String(seed));
            }
        }

        class DisjointSet {
            constructor(elements = []) {
                this.parent = new Map();
                this.rank = new Map();
                elements.forEach(e => this.makeSet(e));
            }

            makeSet(x) {
                if (!this.parent.has(x)) {
                    this.parent.set(x, x);
                    this.rank.set(x, 0);
                }
            }

            find(x) {
                if (!this.parent.has(x)) {
                    this.makeSet(x);
                }
                const parent = this.parent.get(x);
                if (parent !== x) {
                    const root = this.find(parent);
                    this.parent.set(x, root);
                    return root;
                }
                return x;
            }

            union(x, y) {
                const rootX = this.find(x);
                const rootY = this.find(y);
                if (rootX === rootY) return rootX;

                const rankX = this.rank.get(rootX) || 0;
                const rankY = this.rank.get(rootY) || 0;

                if (rankX < rankY) {
                    this.parent.set(rootX, rootY);
                    return rootY;
                } else if (rankX > rankY) {
                    this.parent.set(rootY, rootX);
                    return rootX;
                } else {
                    this.parent.set(rootY, rootX);
                    this.rank.set(rootX, rankX + 1);
                    return rootX;
                }
            }

            getSets() {
                const result = new Map();
                for (const key of this.parent.keys()) {
                    const root = this.find(key);
                    if (!result.has(root)) {
                        result.set(root, new Set());
                    }
                    result.get(root).add(key);
                }
                return result;
            }
        }

        class Atom {
            constructor(axis, head, tail) {
                this.axis = axis;
                this.head = head;
                this.tail = tail;
            }

            equals(other) {
                return this.axis === other.axis && this.head === other.head && this.tail === other.tail;
            }

            toString() {
                return `${this.head} is ${RELATION_WORDS[this.axis]} ${this.tail}`;
            }

            toKey() {
                return `${this.axis},${this.head},${this.tail}`;
            }

            static invert(atom) {
                const invMap = { N: 'S', S: 'N', E: 'W', W: 'E', NE: 'SW', SW: 'NE', SE: 'NW', NW: 'SE' };
                return new Atom(invMap[atom.axis], atom.tail, atom.head);
            }
        }

        class Premise {
            constructor(config) {
                if (Array.isArray(config)) {
                    // ATOMIC premise path (all levels including Level 6 direction words)
                    this.type = 'ATOMIC';
                    this.atoms = [...config].sort((a, b) => {
                        if (a.axis !== b.axis) return a.axis.localeCompare(b.axis);
                        if (a.head !== b.head) return a.head.localeCompare(b.head);
                        return a.tail.localeCompare(b.tail);
                    });
                    this.meta = null;
                    this.semanticPairs = null;
                } else {
                    console.error('Invalid Premise constructor argument:', config);
                    throw new Error('Invalid Premise constructor argument');
                }

                try {
                    this.features = this.computeFeatures();
                } catch (err) {
                    console.error('Failed to compute features for premise:', err);
                    // Provide default features to prevent crashes
                    this.features = {
                        lettersSet: new Set(),
                        degreeVector: new Map(),
                        skeletonIsoSignature: 'ERROR',
                        atomAxisProfile: new Map()
                    };
                }
            }

            getLetters() {
                const letters = new Set();
                this.atoms.forEach(atom => {
                    letters.add(atom.head);
                    letters.add(atom.tail);
                });
                return letters;
            }

            computeFeatures() {
                const lettersSet = new Set();
                const degreeVector = new Map();
                const axisProfile = new Map();
                const indexMap = {
                    N: [0, 1],
                    S: [2, 3],
                    E: [4, 5],
                    W: [6, 7]
                };

                const ensureVector = (letter) => {
                    if (!degreeVector.has(letter)) {
                        degreeVector.set(letter, [0, 0, 0, 0, 0, 0, 0, 0]);
                    }
                    return degreeVector.get(letter);
                };

                this.atoms.forEach(atom => {
                    lettersSet.add(atom.head);
                    lettersSet.add(atom.tail);

                    const [outIdx, inIdx] = indexMap[atom.axis];
                    const headVec = ensureVector(atom.head);
                    headVec[outIdx] += 1;
                    const tailVec = ensureVector(atom.tail);
                    tailVec[inIdx] += 1;

                    axisProfile.set(atom.axis, (axisProfile.get(atom.axis) || 0) + 1);
                });

                return {
                    lettersSet,
                    degreeVector,
                    skeletonIsoSignature: this.isoSignature(),
                    atomAxisProfile: axisProfile
                };
            }

            getFeatures() {
                return this.features;
            }

            atomKeys() {
                return this.atoms.map(atom => atom.toKey());
            }

            toKey() {
                return this.atomKeys().join('|');
            }

            toString() {
                return this.atoms.map(a => a.toString()).join('; ');
            }

            toNaturalSpeech() {
                return this.atoms.map(atom => `${atom.head} is ${RELATION_WORDS[atom.axis]} ${atom.tail}`).join('; ') + '.';
            }

            mirrorKey() {
                const canonicalAtoms = this.atoms.map(atom => {
                    const inverted = Atom.invert(atom);
                    const current = `${atom.axis}|${atom.head}|${atom.tail}`;
                    const flipped = `${inverted.axis}|${inverted.head}|${inverted.tail}`;
                    return current < flipped ? current : flipped;
                }).sort();
                return canonicalAtoms.join('|');
            }

            isoSignature() {
                const letterMap = new Map();
                let nextCharCode = 'a'.charCodeAt(0);
                const normalized = this.atoms.map(atom => {
                    if (!letterMap.has(atom.head)) {
                        letterMap.set(atom.head, String.fromCharCode(nextCharCode++));
                    }
                    if (!letterMap.has(atom.tail)) {
                        letterMap.set(atom.tail, String.fromCharCode(nextCharCode++));
                    }
                    const headNorm = letterMap.get(atom.head);
                    const tailNorm = letterMap.get(atom.tail);
                    const normalizedAtom = new Atom(atom.axis, headNorm, tailNorm);
                    const inverted = Atom.invert(normalizedAtom);
                    const keyCurrent = `${normalizedAtom.axis}|${normalizedAtom.head}|${normalizedAtom.tail}`;
                    const keyInv = `${inverted.axis}|${inverted.head}|${inverted.tail}`;
                    return keyCurrent < keyInv ? keyCurrent : keyInv;
                });
                return normalized.sort().join('|');
            }
        }

        class NoveltyManager {
            constructor(windowSize = HAMMING_WINDOW, firstN = FIRST_N_NOVELTY) {
                this.windowSize = windowSize;
                this.firstN = firstN;
                this.seenExact = new Set();
                this.seenMirror = new Set();
                this.seenIso = new Set();
                this.history = [];
            }

            buildSignatures(premise) {
                return {
                    exact: premise.toKey(),
                    mirror: premise.mirrorKey(),
                    iso: premise.isoSignature(),
                    atoms: premise.atomKeys()
                };
            }

            computeHamming(atoms) {
                if (this.history.length === 0) return this.windowSize;
                const freq1 = this.buildFrequencyMap(atoms);
                let total = 0;
                const limit = Math.min(this.windowSize, this.history.length);
                for (let i = 0; i < limit; i++) {
                    const other = this.history[this.history.length - 1 - i];
                    const freq2 = other.frequency;
                    const allKeys = new Set([...freq1.keys(), ...freq2.keys()]);
                    let diff = 0;
                    allKeys.forEach(key => {
                        diff += Math.abs((freq1.get(key) || 0) - (freq2.get(key) || 0));
                    });
                    total += diff;
                }
                return total / limit;
            }

            buildFrequencyMap(atoms) {
                const freq = new Map();
                atoms.forEach(key => {
                    freq.set(key, (freq.get(key) || 0) + 1);
                });
                return freq;
            }

            evaluate(premise, signatures, trialIndex) {
                const exactHit = this.seenExact.has(signatures.exact);
                if (exactHit) {
                    return {
                        blocked: true,
                        reason: 'exact-repeat',
                        penalty: Infinity,
                        noveltyScores: { exact: 1, mirror: 0, iso: 0, hamming: 0 }
                    };
                }

                const mirrorHit = this.seenMirror.has(signatures.mirror);
                const isoHit = this.seenIso.has(signatures.iso);
                const hamming = this.computeHamming(signatures.atoms);

                const noveltyScores = {
                    exact: mirrorHit ? 1 : 0,
                    mirror: mirrorHit ? 1 : 0,
                    iso: isoHit ? 1 : 0,
                    hamming
                };

                if (trialIndex < this.firstN && (mirrorHit || isoHit)) {
                    return {
                        blocked: true,
                        reason: 'novelty-mode',
                        penalty: Infinity,
                        noveltyScores
                    };
                }

                let penalty = 0;
                if (mirrorHit) penalty += 1;
                if (isoHit) penalty += 2;

                return {
                    blocked: false,
                    penalty,
                    noveltyScores
                };
            }

            register(signatures) {
                this.seenExact.add(signatures.exact);
                this.seenMirror.add(signatures.mirror);
                this.seenIso.add(signatures.iso);
                this.history.push({
                    signature: signatures.exact,
                    frequency: this.buildFrequencyMap(signatures.atoms)
                });
                if (this.history.length > this.windowSize) {
                    this.history.shift();
                }
            }

            reset() {
                this.seenExact.clear();
                this.seenMirror.clear();
                this.seenIso.clear();
                this.history = [];
            }
        }

        class LetterPoolManager {
            constructor(allLetters, rng, usageTracker) {
                this.allLetters = allLetters;
                this.rng = rng;
                this.usageTracker = usageTracker;
                this.currentPool = [];
            }

            getUsage(letter) {
                const usage = this.usageTracker.get(letter);
                if (!usage) return 0;
                return usage.head + usage.tail;
            }

            sampleLetters(count, candidates = this.allLetters) {
                const available = candidates.filter(l => !this.currentPool.includes(l));
                const selection = [];
                const pool = [...available];
                while (selection.length < count && pool.length > 0) {
                    const weights = pool.map(letter => 1 / (1 + this.getUsage(letter)));
                    const choice = this.rng.weightedChoice(pool, weights);
                    selection.push(choice);
                    const index = pool.indexOf(choice);
                    pool.splice(index, 1);
                }
                return selection;
            }

            nextPool(k, options = {}) {
                const { expand = false } = options;
                const min = k + 1;
                const max = Math.min(6, 2 * k + 2);
                const targetSize = Math.max(min, Math.min(max, (this.currentPool.length || min) + (expand ? 1 : 0)));

                if (this.currentPool.length === 0) {
                    const letters = this.rng.shuffle(this.allLetters).slice(0, targetSize);
                    this.currentPool = letters;
                    return this.currentPool;
                }

                const drift = expand ? 0.5 : this.rng.nextBetween(0.3, 0.5);
                const keepCount = Math.max(min, Math.round(targetSize * (1 - drift)));
                const orderedByUsage = [...this.currentPool].sort((a, b) => this.getUsage(a) - this.getUsage(b));
                const keep = orderedByUsage.slice(0, keepCount);
                const needed = targetSize - keep.length;
                const candidates = this.allLetters.filter(letter => !keep.includes(letter));
                const additions = this.sampleLetters(needed, candidates);
                this.currentPool = this.rng.shuffle([...keep, ...additions]);
                return this.currentPool;
            }
        }

        function collectLetters(atoms) {
            const set = new Set();
            atoms.forEach(atom => {
                set.add(atom.head);
                set.add(atom.tail);
            });
            return set;
        }

        function addEdge(map, from, to) {
            if (!map.has(from)) {
                map.set(from, new Set());
            }
            map.get(from).add(to);
        }

        function topologicalAssign(nodes, edges) {
            const indegree = new Map();
            nodes.forEach(node => indegree.set(node, 0));
            edges.forEach((targets, source) => {
                targets.forEach(target => {
                    indegree.set(target, (indegree.get(target) || 0) + 1);
                });
            });

            const queue = [];
            indegree.forEach((degree, node) => {
                if (degree === 0) queue.push(node);
            });

            const order = [];
            while (queue.length > 0) {
                const node = queue.shift();
                order.push(node);
                const neighbors = edges.get(node);
                if (!neighbors) continue;
                neighbors.forEach(neighbor => {
                    indegree.set(neighbor, indegree.get(neighbor) - 1);
                    if (indegree.get(neighbor) === 0) {
                        queue.push(neighbor);
                    }
                });
            }

            if (order.length !== nodes.length) {
                return { cycle: true, values: new Map() };
            }

            const values = new Map();
            order.forEach(node => {
                if (!values.has(node)) values.set(node, 0);
                const base = values.get(node);
                const neighbors = edges.get(node);
                if (!neighbors) return;
                neighbors.forEach(neighbor => {
                    const current = values.get(neighbor) || 0;
                    const candidate = Math.max(current, base + 1);
                    values.set(neighbor, candidate);
                });
            });

            nodes.forEach(node => {
                if (!values.has(node)) values.set(node, 0);
            });

            return { cycle: false, values };
        }

        function buildReachability(nodes, edges) {
            const reach = new Map();
            nodes.forEach(node => {
                const visited = new Set();
                const stack = [node];
                while (stack.length) {
                    const current = stack.pop();
                    const neighbors = edges.get(current);
                    if (!neighbors) continue;
                    neighbors.forEach(next => {
                        if (!visited.has(next)) {
                            visited.add(next);
                            stack.push(next);
                        }
                    });
                }
                reach.set(node, visited);
            });
            return reach;
        }

        class ConstraintSolver {
            analyze(allAtoms) {
                const letters = collectLetters(allAtoms);
                const ufX = new DisjointSet(letters);
                const ufY = new DisjointSet(letters);

                const graphX = new Map();
                const graphY = new Map();

                for (const atom of allAtoms) {
                    if (atom.axis === 'N' || atom.axis === 'S') {
                        ufX.union(atom.head, atom.tail);
                    } else {
                        ufY.union(atom.head, atom.tail);
                    }
                }

                for (const atom of allAtoms) {
                    if (atom.axis === 'N') {
                        const lesser = ufY.find(atom.tail);
                        const greater = ufY.find(atom.head);
                        if (lesser === greater) {
                            return { ok: false, reason: 'vertical-collision' };
                        }
                        addEdge(graphY, lesser, greater);
                    } else if (atom.axis === 'S') {
                        const lesser = ufY.find(atom.head);
                        const greater = ufY.find(atom.tail);
                        if (lesser === greater) {
                            return { ok: false, reason: 'vertical-collision' };
                        }
                        addEdge(graphY, lesser, greater);
                    } else if (atom.axis === 'E') {
                        const lesser = ufX.find(atom.tail);
                        const greater = ufX.find(atom.head);
                        if (lesser === greater) {
                            return { ok: false, reason: 'horizontal-collision' };
                        }
                        addEdge(graphX, lesser, greater);
                    } else if (atom.axis === 'W') {
                        const lesser = ufX.find(atom.head);
                        const greater = ufX.find(atom.tail);
                        if (lesser === greater) {
                            return { ok: false, reason: 'horizontal-collision' };
                        }
                        addEdge(graphX, lesser, greater);
                    }
                }

                const nodesX = Array.from(new Set([...graphX.keys(), ...Array.from(graphX.values()).flat()]));
                ufX.parent.forEach((_, letter) => nodesX.push(ufX.find(letter)));
                const uniqueNodesX = Array.from(new Set(nodesX));

                const nodesY = Array.from(new Set([...graphY.keys(), ...Array.from(graphY.values()).flat()]));
                ufY.parent.forEach((_, letter) => nodesY.push(ufY.find(letter)));
                const uniqueNodesY = Array.from(new Set(nodesY));

                const assignX = topologicalAssign(uniqueNodesX, graphX);
                if (assignX.cycle) {
                    return { ok: false, reason: 'horizontal-cycle' };
                }

                const assignY = topologicalAssign(uniqueNodesY, graphY);
                if (assignY.cycle) {
                    return { ok: false, reason: 'vertical-cycle' };
                }

                const coordinates = new Map();
                letters.forEach(letter => {
                    const xRep = ufX.find(letter);
                    const yRep = ufY.find(letter);
                    const x = assignX.values.get(xRep) || 0;
                    const y = assignY.values.get(yRep) || 0;
                    coordinates.set(letter, { x, y });
                });

                return {
                    ok: true,
                    coordinates,
                    ufX,
                    ufY,
                    graphX,
                    graphY,
                    nodesX: uniqueNodesX,
                    nodesY: uniqueNodesY
                };
            }

            evaluate(windowAtoms, candidateAtoms) {
                return this.analyze([...windowAtoms, ...candidateAtoms]);
            }
        }

        class EquivalenceEngine {
            constructor(transitivityEnabled = false) {
                this.transitivityEnabled = transitivityEnabled;
            }

            setTransitivity(enabled) {
                this.transitivityEnabled = enabled;
            }

            /**
             * Detects if a premise uses compound operators (Level 7-8).
             * Compound operators contain hyphens (e.g., "NE-SW", "N-S").
             * @param {Premise} premise - The premise to check
             * @returns {boolean} True if premise contains compound operators
             */
            isCompoundOperatorPremise(premise) {
                // Check if any atom has compound operators in head or tail
                if (!premise || !premise.atoms || premise.atoms.length === 0) {
                    return false;
                }

                return premise.atoms.some(atom =>
                    (atom.head && atom.head.includes('-')) ||
                    (atom.tail && atom.tail.includes('-'))
                );
            }

            lettersOf(premise) {
                const letters = new Set();

                // ATOMIC premises
                if (premise.atoms && Array.isArray(premise.atoms)) {
                    premise.atoms.forEach(atom => {
                        if (atom && atom.head && atom.tail) {
                            letters.add(atom.head);
                            letters.add(atom.tail);
                        }
                    });
                }
                return letters;
            }

            computeInvertibleMapping(atomsA, atomsB) {
                const mapping = [];
                const used = new Set();

                const search = (index) => {
                    if (index === atomsA.length) return true;
                    for (let j = 0; j < atomsB.length; j++) {
                        if (used.has(j)) continue;
                        if (atomsA[index].equals(atomsB[j])) {
                            used.add(j);
                            mapping.push({ from: atomsA[index].toKey(), to: atomsB[j].toKey(), inverted: false });
                            if (search(index + 1)) return true;
                            mapping.pop();
                            used.delete(j);
                        }
                        const inverted = Atom.invert(atomsA[index]);
                        if (inverted.equals(atomsB[j])) {
                            used.add(j);
                            mapping.push({ from: atomsA[index].toKey(), to: atomsB[j].toKey(), inverted: true });
                            if (search(index + 1)) return true;
                            mapping.pop();
                            used.delete(j);
                        }
                    }
                    return false;
                };

                const ok = search(0);
                return ok ? mapping.slice() : null;
            }

            analyzeMidWindow(midAtoms) {
                if (!midAtoms || midAtoms.length === 0) {
                    return { ok: false };
                }
                const solver = new ConstraintSolver();
                const analysis = solver.analyze(midAtoms);
                if (!analysis.ok) {
                    return { ok: false };
                }
                const reachX = buildReachability(analysis.nodesX, analysis.graphX);
                const reachY = buildReachability(analysis.nodesY, analysis.graphY);
                return { ok: true, analysis, reachX, reachY };
            }

            isDerivableFromMid(atom, midInfo) {
                if (!midInfo.ok) return false;
                const { analysis, reachX, reachY } = midInfo;
                if (atom.axis === 'N') {
                    const lesser = analysis.ufY.find(atom.tail);
                    const greater = analysis.ufY.find(atom.head);
                    const reach = reachY.get(lesser);
                    return reach ? reach.has(greater) : false;
                }
                if (atom.axis === 'S') {
                    const lesser = analysis.ufY.find(atom.head);
                    const greater = analysis.ufY.find(atom.tail);
                    const reach = reachY.get(lesser);
                    return reach ? reach.has(greater) : false;
                }
                if (atom.axis === 'E') {
                    const lesser = analysis.ufX.find(atom.tail);
                    const greater = analysis.ufX.find(atom.head);
                    const reach = reachX.get(lesser);
                    return reach ? reach.has(greater) : false;
                }
                if (atom.axis === 'W') {
                    const lesser = analysis.ufX.find(atom.head);
                    const greater = analysis.ufX.find(atom.tail);
                    const reach = reachX.get(lesser);
                    return reach ? reach.has(greater) : false;
                }
                return false;
            }

            Equivalent(premA, premB, windowAtoms = [], midAtoms = []) {
                const atomsA = premA.atoms;
                const atomsB = premB.atoms;

                if (atomsA.length !== atomsB.length) {
                    return { ok: false, reason: 'parity' };
                }

                const mapping = this.computeInvertibleMapping(atomsA, atomsB);
                // Allow non-invertible mapping if Transitivity is on, to enable A->C derivable from A->B
                if (!mapping && !this.transitivityEnabled) {
                    return { ok: false, reason: 'mapping' };
                }

                // CRITICAL: Detect compound operator premises (Levels 7-8)
                // Compound operators are abstract units that don't obey spatial semantics
                const isCompoundA = this.isCompoundOperatorPremise(premA);
                const isCompoundB = this.isCompoundOperatorPremise(premB);
                const isCompoundOperatorPair = isCompoundA || isCompoundB;

                // Shared anchors check: SKIP for compound operators (Levels 7-8)
                // Compound operators like "NE-SW" and "SW-NE" are different symbols
                // but may represent equivalent abstract relations - they don't share "letters"
                // in the spatial sense, so the anchors check is semantically invalid.
                if (!isCompoundOperatorPair) {
                    // Only perform shared anchors check for Levels 1-6
                    const lettersA = this.lettersOf(premA);
                    const lettersB = this.lettersOf(premB);
                    const shared = new Set();
                    lettersA.forEach(letter => {
                        if (lettersB.has(letter)) {
                            shared.add(letter);
                        }
                    });
                    if (shared.size < 2) {
                        return { ok: false, reason: 'anchors' };
                    }
                }

                // Constraint solver: SKIP for compound operators (Levels 7-8)
                // The ConstraintSolver enforces spatial consistency (N/S/E/W axes).
                // Compound operators are abstract symbols without spatial semantics,
                // so constraint solving produces meaningless results and false rejections.
                if (!isCompoundOperatorPair) {
                    // Only perform constraint solving for Levels 1-6
                    const solver = new ConstraintSolver();
                    const satResult = solver.analyze([...windowAtoms, ...atomsA, ...atomsB]);
                    if (!satResult.ok) {
                        return { ok: false, reason: 'sat' };
                    }
                }

                // Compute shared letters for certificate (even if we skipped anchors check)
                const lettersA = this.lettersOf(premA);
                const lettersB = this.lettersOf(premB);
                const shared = new Set();
                lettersA.forEach(letter => {
                    if (lettersB.has(letter)) {
                        shared.add(letter);
                    }
                });

                const midInfo = this.analyzeMidWindow(midAtoms);
                if (midInfo.ok) {
                    for (const atom of [...atomsA, ...atomsB]) {
                        if (this.isDerivableFromMid(atom, midInfo) || this.isDerivableFromMid(Atom.invert(atom), midInfo)) {
                            return {
                                ok: false,
                                reason: 'mid-window-derivable',
                                mapping,
                                sharedLetters: Array.from(shared),
                                midWindowDerivable: true
                            };
                        }
                    }
                }

                return {
                    ok: true,
                    type: 'invertible',
                    mapping,
                    sharedLetters: Array.from(shared),
                    midWindowDerivable: false
                };
            }

            computeCertificate(nBackPremise, candidatePremise, midAtoms, windowAtoms = []) {
                if (!nBackPremise) {
                    return { match: false, reason: 'no-nback' };
                }

                if (nBackPremise.toKey() === candidatePremise.toKey()) {
                    return { match: false, reason: 'identity' };
                }

                // Router: dispatch based on premise type
                if (nBackPremise.type !== candidatePremise.type) {
                    return { match: false, reason: 'type-mismatch' };
                }

                // ATOMIC premise path (all levels now use this, including Level 6 direction words)
                const result = this.Equivalent(nBackPremise, candidatePremise, windowAtoms, midAtoms || []);
                if (!result.ok) {
                    const response = { match: false, reason: result.reason };
                    if (result.reason === 'mid-window-derivable' || result.midWindowDerivable) {
                        response.midWindowDerivable = true;
                        if (this.transitivityEnabled) {
                            return {
                                match: true,
                                certificate: {
                                    type: 'transitive-closure',
                                    mapping: result.mapping || [],
                                    sharedLetters: result.sharedLetters || [],
                                    parity: true,
                                    midWindowDerivable: true
                                },
                                midWindowDerivable: true
                            };
                        }
                    }
                    return response;
                }

                const certificate = {
                    type: result.type,
                    mapping: result.mapping,
                    sharedLetters: result.sharedLetters,
                    parity: true,
                    midWindowDerivable: false
                };

                return { match: true, certificate, midWindowDerivable: false };
            }

        }

        class MatchPlanner {
            constructor(rng) {
                this.rng = rng;
                this.schedule = [];
                this.flips = new Map();
                this.matchModeBag = [];
                this.decoyModeBag = [];
                this.foilRate = conflictConfig.foilRate;
                this.foilTypes = Object.keys(conflictConfig.foilTypesWeights);
                this.foilWeights = this.foilTypes.map(type => conflictConfig.foilTypesWeights[type]);
            }

            plan(totalTrials, n) {
                this.schedule = new Array(totalTrials).fill(false);
                this.flips.clear();
                const rate = this.rng.nextBetween(0.35, 0.55);
                const history = [];
                for (let i = 0; i < totalTrials; i++) {
                    if (i < n) {
                        this.schedule[i] = false;
                        history.push(false);
                        continue;
                    }

                    let decision = this.rng.next() < rate;
                    if (this.wouldRepeat(history, decision)) {
                        decision = !decision;
                        this.flips.set(i, true);
                    }

                    this.schedule[i] = decision;
                    history.push(decision);
                    if (history.length > 24) history.shift();
                }
                return this.schedule;
            }

            chooseConflictMode(plannedMatch) {
                if (plannedMatch) {
                    if (this.matchModeBag.length === 0) {
                        this.matchModeBag = this.rng.shuffle(['BSM', 'CAC']);
                    }
                    return this.matchModeBag.pop();
                }
                if (this.decoyModeBag.length === 0) {
                    const decoys = ['ASNM', 'APNM', 'PPHF', 'CBB', 'WLC', 'ISD'];
                    const bag = [];
                    for (let i = 0; i < 2; i++) {
                        bag.push(...decoys);
                    }
                    this.decoyModeBag = this.rng.shuffle(bag);
                }
                return this.decoyModeBag.pop();
            }

            sampleFoilType() {
                if (this.foilTypes.length === 0) {
                    return null;
                }
                return this.rng.weightedChoice(this.foilTypes, this.foilWeights);
            }

            maybePlanFoil() {
                if (this.foilRate <= 0) return null;
                if (this.rng.next() < this.foilRate) {
                    const type = this.sampleFoilType();
                    return type ? { type } : null;
                }
                return null;
            }

            wouldRepeat(history, decision) {
                const window = [...history, decision];
                if (window.length < 24) return false;
                const recent = window.slice(-12);
                const previous = window.slice(-24, -12);
                return this.isRotationEqual(previous, recent);
            }

            isRotationEqual(arr1, arr2) {
                if (arr1.length !== arr2.length) return false;
                const joined1 = arr1.join('');
                const joined2 = arr2.join('');
                return (joined1 + joined1).includes(joined2);
            }

            forceFlip(index) {
                if (index < 0 || index >= this.schedule.length) return;
                this.schedule[index] = !this.schedule[index];
                this.flips.set(index, true);
            }

            wasFlipped(index) {
                return this.flips.get(index) || false;
            }
        }

        class GameLogger {
            constructor(limitBytes = 5 * 1024 * 1024) {
                this.entries = [];
                this.entrySizes = [];
                this.archivedChunks = [];
                this.sizeLimit = limitBytes;
                this.sizeEstimate = 0;
            }

            estimateSize(entry) {
                try {
                    return JSON.stringify(entry).length;
                } catch (error) {
                    return 0;
                }
            }

            flushToArchive() {
                const keep = Math.min(1000, this.entries.length);
                const flushCount = this.entries.length - keep;
                if (flushCount <= 0) return false;
                const flushedEntries = this.entries.splice(0, flushCount);
                const flushedSizes = this.entrySizes.splice(0, flushCount);
                this.archivedChunks.push(JSON.stringify(flushedEntries));
                const reclaimed = flushedSizes.reduce((acc, value) => acc + value, 0);
                this.sizeEstimate = Math.max(0, this.sizeEstimate - reclaimed);
                return true;
            }

            add(entry) {
                const size = this.estimateSize(entry);
                this.entries.push(entry);
                this.entrySizes.push(size);
                this.sizeEstimate += size;
                while (this.sizeEstimate > this.sizeLimit) {
                    const flushed = this.flushToArchive();
                    if (!flushed) {
                        break;
                    }
                }
            }

            reset() {
                this.entries = [];
                this.entrySizes = [];
                this.archivedChunks = [];
                this.sizeEstimate = 0;
            }

            getEntriesSnapshot() {
                const snapshot = [];
                for (const chunk of this.archivedChunks) {
                    try {
                        const parsed = JSON.parse(chunk);
                        if (Array.isArray(parsed)) {
                            snapshot.push(...parsed);
                        }
                    } catch (error) {
                        console.warn('Failed to parse archived log chunk', error);
                    }
                }
                snapshot.push(...this.entries);
                return snapshot;
            }

            toCSV() {
                const entries = this.getEntriesSnapshot();
                if (entries.length === 0) return '';
                const headers = Object.keys(entries[0]);
                const rows = [headers.join(',')];
                entries.forEach(entry => {
                    const row = headers.map(key => {
                        const value = entry[key];
                        if (value === null || value === undefined) return '';
                        if (typeof value === 'object') {
                            return JSON.stringify(value).replace(/"/g, '""');
                        }
                        return String(value).replace(/"/g, '""');
                    }).join(',');
                    rows.push(row);
                });
                return rows.join('\n');
            }

            toJSON() {
                return JSON.stringify(this.getEntriesSnapshot(), null, 2);
            }
        }

        class GameState {
            constructor(seed, options) {
                this.seed = seed;
                this.rng = new Mulberry32(seed);
                this.letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
                this.windowSize = options.windowSize;
                this.currentStep = 0;
                this.constraintStore = [];
                this.premiseHistory = [];
                this.letterUsage = new Map();
                this.axisUsage = { N: 0, S: 0, E: 0, W: 0 };
                this.cooldown = new Map();
                this.novelty = new NoveltyManager(HAMMING_WINDOW, FIRST_N_NOVELTY);
                this.letterPool = new LetterPoolManager(this.letters, this.rng, this.letterUsage);
                this.coordinates = new Map();
            }

            resetNovelty() {
                this.novelty.reset();
            }

            getWindowAtoms() {
                const cutoff = Math.max(0, this.currentStep - this.windowSize);
                return this.constraintStore
                    .filter(entry => entry.step >= cutoff)
                    .flatMap(entry => entry.atoms);
            }

            getConstraintsInRange(start, end) {
                return this.constraintStore
                    .filter(entry => entry.step >= start && entry.step <= end)
                    .flatMap(entry => entry.atoms);
            }

            ensureLetterUsage(letter) {
                if (!this.letterUsage.has(letter)) {
                    this.letterUsage.set(letter, { head: 0, tail: 0 });
                }
                return this.letterUsage.get(letter);
            }

            updateUsage(premise) {
                // Track letter and axis usage for ATOMIC premises (all levels)
                if (!premise || !premise.atoms || !Array.isArray(premise.atoms)) {
                    return;
                }

                if (premise.atoms.length > 0) {
                    premise.atoms.forEach(atom => {
                        if (atom && atom.head && atom.tail && atom.axis) {
                            this.ensureLetterUsage(atom.head).head += 1;
                            this.ensureLetterUsage(atom.tail).tail += 1;
                            if (this.axisUsage[atom.axis] !== undefined) {
                                this.axisUsage[atom.axis] += 1;
                            }
                        }
                    });
                }
            }

            recordPremise(premise, atoms, metadata) {
                // Defensive: ensure atoms is an array
                const safeAtoms = (Array.isArray(atoms) && atoms.length > 0) ? atoms : [];

                this.constraintStore.push({ step: this.currentStep, atoms: safeAtoms });
                this.premiseHistory.push({ step: this.currentStep, premise, metadata });
                this.currentStep += 1;

                const cutoff = this.currentStep - this.windowSize;
                this.constraintStore = this.constraintStore.filter(entry => entry.step >= cutoff);
                this.premiseHistory = this.premiseHistory.filter(entry => entry.step >= cutoff - this.windowSize);

                this.updateUsage(premise);
            }

            getPremiseAt(index) {
                const entry = this.premiseHistory.find(p => p.step === index);
                return entry ? entry.premise : null;
            }

            getActiveCooldown(currentTrial) {
                const active = new Set();
                this.cooldown.forEach((expiry, letter) => {
                    if (expiry > currentTrial) {
                        active.add(letter);
                    }
                });
                return active;
            }

            applyCooldown(letters, currentTrial, n) {
                const cooldownLength = Math.ceil(n / 2);
                letters.forEach(letter => {
                    this.cooldown.set(letter, currentTrial + cooldownLength);
                });
            }
        }

        class PremiseGenerator {
            constructor(state, solver, equivalence) {
                this.state = state;
                this.solver = solver;
                this.equivalence = equivalence;
                this.planner = null;
            }

            setPlanner(planner) {
                this.planner = planner;
            }

            generate(options) {
                const {
                    trialIndex,
                    k,
                    n,
                    plannedMatch,
                    nBackPremise,
                    middleAtoms,
                    avoidLetters,
                    allowOverride,
                    foilPlan,
                    forceMetaLeap,
                    forceCompoundLeap,
                    forceOctoLeap,
                    forceHexaLeap
                } = options;

                // DEBUG: Log all force flags at entry
                console.log('PremiseGenerator.generate() called with flags:', {
                    forceMetaLeap,
                    forceCompoundLeap,
                    forceOctoLeap,
                    forceHexaLeap,
                    trialIndex,
                    k
                });

                // HEXA OPERATOR premise generation path (Level 9: 16-Direction Triple-Nested Meta-Compound)
                if (forceHexaLeap) {
                    try {
                        const hexaPremise = this.buildHexaLeapOperatorPremise(plannedMatch, nBackPremise, k);
                        if (hexaPremise && hexaPremise.atoms && hexaPremise.atoms.length > 0) {
                            const signatures = this.state.novelty.buildSignatures(hexaPremise);
                            return {
                                premise: hexaPremise,
                                signatures,
                                novelty: { noveltyScores: {}, blocked: false },
                                satResult: { ok: true, coordinates: new Map() },
                                certificate: null,
                                midDerivable: false,
                                attempts: 1,
                                modeUsed: 'HEXA_OPERATOR',
                                features: hexaPremise.getFeatures(),
                                foilType: null,
                                planMatch: plannedMatch
                            };
                        } else {
                            console.error('buildHexaLeapOperatorPremise returned invalid premise', hexaPremise);
                        }
                    } catch (err) {
                        console.error('HEXA premise generation failed', err);
                        // Fall through to OCTO, COMPOUND, META or atomic generation as emergency fallback
                    }
                }

                // OCTO OPERATOR premise generation path (Level 8: 8-Direction Meta-Compound)
                if (forceOctoLeap) {
                    try {
                        const octoPremise = this.buildOctoOperatorPremise(plannedMatch, nBackPremise, k);
                        if (octoPremise && octoPremise.atoms && octoPremise.atoms.length > 0) {
                            const signatures = this.state.novelty.buildSignatures(octoPremise);
                            return {
                                premise: octoPremise,
                                signatures,
                                novelty: { noveltyScores: {}, blocked: false },
                                satResult: { ok: true, coordinates: new Map() },
                                certificate: null,
                                midDerivable: false,
                                attempts: 1,
                                modeUsed: 'OCTO_OPERATOR',
                                features: octoPremise.getFeatures(),
                                foilType: null,
                                planMatch: plannedMatch
                            };
                        } else {
                            console.error('buildOctoOperatorPremise returned invalid premise', octoPremise);
                        }
                    } catch (err) {
                        console.error('OCTO premise generation failed', err);
                        // Fall through to COMPOUND, META or atomic generation as emergency fallback
                    }
                }

                // COMPOUND OPERATOR premise generation path (Level 7)
                if (forceCompoundLeap) {
                    try {
                        const compoundPremise = this.buildCompoundOperatorPremise(plannedMatch, nBackPremise, k);
                        if (compoundPremise && compoundPremise.atoms && compoundPremise.atoms.length > 0) {
                            const signatures = this.state.novelty.buildSignatures(compoundPremise);
                            return {
                                premise: compoundPremise,
                                signatures,
                                novelty: { noveltyScores: {}, blocked: false },
                                satResult: { ok: true, coordinates: new Map() },
                                certificate: null,
                                midDerivable: false,
                                attempts: 1,
                                modeUsed: 'COMPOUND_OPERATOR',
                                features: compoundPremise.getFeatures(),
                                foilType: null,
                                planMatch: plannedMatch
                            };
                        } else {
                            console.error('buildCompoundOperatorPremise returned invalid premise', compoundPremise);
                        }
                    } catch (err) {
                        console.error('COMPOUND premise generation failed', err);
                        // Fall through to META or atomic generation as emergency fallback
                    }
                }

                // Pre-compute windowAtoms needed by Level 6 and atomic generation
                const windowAtoms = this.state.getWindowAtoms();

                // Level 6: Direction-word spatial reasoning (NEW implementation)
                if (forceMetaLeap) {
                    console.log('LEVEL 6 ACTIVE: forceMetaLeap = true, generating direction-word premise');
                    console.log('Level 6 parameters:', { plannedMatch, k, windowAtomsAvailable: windowAtoms?.length || 0 });
                    try {
                        for (let attempt = 0; attempt < 100; attempt++) {
                            const dirPremise = this.buildDirectionWordPremise(
                                plannedMatch,
                                nBackPremise,
                                k,
                                middleAtoms,
                                windowAtoms
                            );

                            if (!dirPremise) {
                                console.log(`Direction-word attempt ${attempt + 1} failed - buildDirectionWordPremise returned null/undefined`);
                                continue;
                            }

                            console.log(`Direction-word attempt ${attempt + 1} SUCCESS - Generated:`, dirPremise.serialize());

                            // Validate novelty
                            const signatures = this.state.novelty.buildSignatures(dirPremise);
                            const noveltyEval = this.state.novelty.evaluate(
                                dirPremise,
                                signatures,
                                trialIndex
                            );

                            if (noveltyEval.blocked) {
                                console.log(`Direction-word attempt ${attempt + 1} blocked by novelty`);
                                continue;
                            }

                            // Success! Return as standard atomic premise
                            console.log('LEVEL 6 SUCCESS: Returning direction-word premise:', dirPremise.serialize());
                            return {
                                premise: dirPremise,
                                signatures,
                                novelty: noveltyEval,
                                satResult: { ok: true, coordinates: new Map() },
                                certificate: null,
                                midDerivable: false,
                                attempts: attempt + 1,
                                modeUsed: 'DIRECTION_WORDS',
                                features: dirPremise.getFeatures(),
                                foilType: null,
                                planMatch: plannedMatch
                            };
                        }

                        console.warn('Direction-word premise generation failed after 100 attempts, falling back to atomic');
                        // Fall through to atomic generation as emergency fallback
                    } catch (err) {
                        console.error('Direction-word premise generation error:', err);
                        // Fall through to atomic generation
                    }
                }

                // windowAtoms already computed above (line 4937)
                let bestCandidate = null;
                let attempts = 0;
                let expanded = false;
                const effectiveMatch = plannedMatch && Boolean(nBackPremise);
                let mode = effectiveMatch ? 'BSM' : 'ASNM';
                if (this.planner) {
                    mode = this.planner.chooseConflictMode(effectiveMatch);
                }

                let activeFoilPlan = (!effectiveMatch && foilPlan && typeof foilPlan.type === 'string') ? { type: foilPlan.type } : null;
                let foilAttempts = 0;

                while (attempts < MAX_GENERATION_ATTEMPTS) {
                    const expand = attempts > 0 && attempts % NOVELTY_OVERRIDE_THRESHOLD === 0;
                    if (expand) expanded = true;

                    let candidatePremise = null;
                    let candidateAtoms = null;
                    let modeUsed = mode;
                    let foilType = null;

                    if (!effectiveMatch && activeFoilPlan && nBackPremise) {
                        const foilResult = this.buildFoilPremise(activeFoilPlan.type, {
                            referencePremise: nBackPremise,
                            windowAtoms,
                            middleAtoms,
                            avoidLetters
                        });
                        foilAttempts++;
                        if (foilResult) {
                            candidatePremise = foilResult.premise;
                            candidateAtoms = candidatePremise.atoms;
                            foilType = foilResult.foilType;
                            modeUsed = `FOIL_${foilResult.foilType}`;
                        } else if (foilAttempts >= 60) {
                            activeFoilPlan = null;
                        }
                    }

                    if (!candidatePremise) {
                        const pool = this.state.letterPool.nextPool(k, { expand });
                        const context = {
                            mode,
                            plannedMatch: effectiveMatch,
                            nBackPremise,
                            pool,
                            k,
                            n,
                            trialIndex,
                            middleAtoms,
                            avoidLetters,
                            state: this.state,
                            rng: this.state.rng
                        };
                        const atomsFromMode = this.makePremiseWithMode(mode, context);
                        attempts++;
                        if (!atomsFromMode) {
                            if (attempts % 12 === 0 && this.planner) {
                                mode = this.planner.chooseConflictMode(effectiveMatch);
                            }
                            continue;
                        }
                        candidateAtoms = atomsFromMode;
                        candidatePremise = new Premise(atomsFromMode);
                    } else {
                        attempts++;
                        candidateAtoms = candidatePremise.atoms;
                    }

                    const premise = candidatePremise;
                    const features = premise.getFeatures();
                    const signatures = this.state.novelty.buildSignatures(premise);
                    const novelty = this.state.novelty.evaluate(premise, signatures, trialIndex);

                    if (novelty.blocked && !(allowOverride && expanded)) {
                        continue;
                    }

                    const satResult = this.solver.evaluate(windowAtoms, candidateAtoms);
                    if (!satResult.ok) {
                        continue;
                    }

                    let certificate = null;
                    let midDerivable = false;

                    if (effectiveMatch) {
                        const equivalence = this.equivalence.computeCertificate(nBackPremise, premise, middleAtoms, windowAtoms);
                        if (!equivalence.match) {
                            continue;
                        }
                        certificate = equivalence.certificate;
                        midDerivable = equivalence.midWindowDerivable;
                    } else if (nBackPremise) {
                        const check = this.equivalence.computeCertificate(nBackPremise, premise, middleAtoms, windowAtoms);
                        if (check.match) {
                            continue;
                        }
                    }

                    const score = Math.exp(ACCEPTANCE_ALPHA * novelty.noveltyScores.hamming - ACCEPTANCE_BETA * novelty.penalty);
                    if (!bestCandidate || score > bestCandidate.score) {
                        bestCandidate = {
                            premise,
                            signatures,
                            novelty,
                            satResult,
                            certificate,
                            midDerivable,
                            attempts,
                            modeUsed,
                            features,
                            foilType,
                            score
                        };
                    }

                    if (this.state.rng.next() < Math.min(1, score)) {
                        return bestCandidate;
                    }

                    if (attempts % 12 === 0 && this.planner) {
                        mode = this.planner.chooseConflictMode(effectiveMatch);
                    }
                }

                return bestCandidate;
            }

            makePremiseWithMode(mode, context) {
                const requiresNBack = ['ASNM', 'APNM', 'PPHF', 'BSM', 'WLC', 'CAC', 'ISD'];
                if (!context.nBackPremise && requiresNBack.includes(mode)) {
                    return this.buildNovelPremise(context.pool, context.k, context.avoidLetters);
                }
                switch (mode) {
                    case 'ASNM':
                        return this.makeAxisSwapNearMiss(context);
                    case 'APNM':
                        return this.makeAnchorPermutationNearMiss(context);
                    case 'PPHF':
                        return this.makeParityPreservedHubFlip(context);
                    case 'CBB':
                        return this.makeCycleBorderBait(context);
                    case 'BSM':
                        return this.makeBipartiteSignatureMatch(context);
                    case 'WLC':
                        return this.makeWrongLagCamouflage(context);
                    case 'CAC':
                        return this.makeCrossAxisCoupling(context);
                    case 'ISD':
                        return this.makeIsomorphicSkeletonDecoy(context);
                    default:
                        return context.plannedMatch
                            ? this.buildMatchCandidate(context.nBackPremise, context.pool, context.k)
                            : this.buildNovelPremise(context.pool, context.k, context.avoidLetters);
                }
            }

            buildFoilPremise(type, context) {
                const { referencePremise, windowAtoms, middleAtoms, avoidLetters } = context;
                if (!referencePremise) return null;
                const maxAttempts = 80;
                for (let attempt = 0; attempt < maxAttempts; attempt++) {
                    let candidate = null;
                    switch (type) {
                        case 'ANCHOR_ONE':
                            candidate = this.makeAnchorOneFoil(referencePremise);
                            break;
                        case 'PAIR_SWAP':
                            candidate = this.makePairSwapFoil(referencePremise);
                            break;
                        case 'PARITY_OFF':
                            candidate = this.makeParityOffFoil(referencePremise);
                            break;
                        case 'AXIS_ORTHO':
                            candidate = this.makeAxisOrthoFoil(referencePremise);
                            break;
                        case 'DERIVED_IN_ONE':
                            candidate = this.makeDerivedInOneFoil(referencePremise);
                            break;
                        case 'WINDOW_SHADOW':
                            candidate = this.makeWindowShadowFoil(referencePremise, middleAtoms);
                            break;
                        default:
                            candidate = null;
                    }
                    if (!candidate) {
                        continue;
                    }
                    if (avoidLetters) {
                        const letters = candidate.getLetters();
                        let blocked = false;
                        avoidLetters.forEach(letter => {
                            if (letters.has(letter)) {
                                blocked = true;
                            }
                        });
                        if (blocked) continue;
                    }
                    const sat = this.solver.evaluate(windowAtoms, candidate.atoms);
                    if (!sat.ok) {
                        continue;
                    }
                    const eq = this.equivalence.Equivalent(referencePremise, candidate, windowAtoms, middleAtoms);
                    if (eq.ok) {
                        continue;
                    }
                    if (!this.foilReasonMatches(type, eq.reason)) {
                        continue;
                    }
                    return { premise: candidate, foilType: type };
                }
                return null;
            }

            foilReasonMatches(type, reason) {
                const expected = {
                    ANCHOR_ONE: 'anchors',
                    PAIR_SWAP: 'mapping',
                    PARITY_OFF: 'parity',
                    AXIS_ORTHO: 'mapping',
                    DERIVED_IN_ONE: 'parity',
                    WINDOW_SHADOW: 'mid-window-derivable'
                };
                const matchReason = expected[type];
                if (!matchReason) return true;
                if (matchReason === reason) return true;
                if (type === 'DERIVED_IN_ONE' && reason === 'mid-window-derivable') return true;
                return false;
            }

            makeAnchorOneFoil(referencePremise) {
                const refLetters = referencePremise.getLetters();
                const refArray = Array.from(refLetters);
                if (refArray.length === 0) return null;
                const anchor = this.state.rng.choice(refArray);
                const banned = new Set(refLetters);
                banned.delete(anchor);
                const available = this.state.letters.filter(letter => !banned.has(letter));
                if (available.length === 0) return null;
                const atoms = [];
                for (const atom of referencePremise.atoms) {
                    const axis = atom.axis;
                    const head = atom.head === anchor ? anchor : this.state.rng.choice(available);
                    let tail = atom.tail === anchor ? anchor : this.state.rng.choice(available);
                    let guard = 0;
                    while (tail === head && guard < 12) {
                        tail = atom.tail === anchor ? anchor : this.state.rng.choice(available);
                        guard++;
                    }
                    if (tail === head) return null;
                    atoms.push(new Atom(axis, head, tail));
                }
                const premise = new Premise(atoms);
                const shared = Array.from(premise.getLetters()).filter(letter => refLetters.has(letter));
                if (shared.length !== 1 || shared[0] !== anchor) return null;
                return premise;
            }

            makePairSwapFoil(referencePremise) {
                const atoms = referencePremise.atoms;
                if (atoms.length < 2) return null;
                const heads = atoms.map(atom => atom.head);
                const tails = atoms.map(atom => atom.tail);
                for (let attempt = 0; attempt < 40; attempt++) {
                    const shuffledHeads = this.state.rng.shuffle(heads);
                    const shuffledTails = this.state.rng.shuffle(tails);
                    const candidates = [];
                    const usedKeys = new Set();
                    let valid = true;
                    for (let i = 0; i < atoms.length; i++) {
                        let head = shuffledHeads[i];
                        let tail = shuffledTails[i];
                        let guard = 0;
                        while (head === tail && guard < 8) {
                            tail = this.state.rng.choice(tails);
                            guard++;
                        }
                        if (head === tail) {
                            valid = false;
                            break;
                        }
                        const atomCandidate = new Atom(atoms[i].axis, head, tail);
                        const key = atomCandidate.toKey();
                        if (usedKeys.has(key)) {
                            valid = false;
                            break;
                        }
                        if (atomCandidate.equals(atoms[i]) || atomCandidate.equals(Atom.invert(atoms[i]))) {
                            valid = false;
                            break;
                        }
                        usedKeys.add(key);
                        candidates.push(atomCandidate);
                    }
                    if (!valid) continue;
                    const premise = new Premise(candidates);
                    if (premise.toKey() === referencePremise.toKey()) continue;
                    return premise;
                }
                return null;
            }

            makeParityOffFoil(referencePremise) {
                const refSet = referencePremise.getLetters();
                const refLetters = Array.from(refSet);
                const base = this.cloneAtoms(referencePremise);
                const originalLength = base.length;
                if (originalLength === 0) return null;
                let target = originalLength;
                if (originalLength === 1) {
                    target = Math.min(4, 2);
                } else if (originalLength === 4) {
                    target = 3;
                } else {
                    const delta = this.state.rng.next() < 0.5 ? -1 : 1;
                    target = Math.min(4, Math.max(1, originalLength + delta));
                    if (target === originalLength) {
                        target = Math.max(1, Math.min(4, originalLength - delta));
                    }
                    if (target === originalLength) {
                        target = originalLength + 1 <= 4 ? originalLength + 1 : originalLength - 1;
                    }
                }
                if (target === originalLength) {
                    target = originalLength + 1 <= 4 ? originalLength + 1 : originalLength - 1;
                }
                if (target < 1) target = 1;
                let atoms = base;
                if (target < originalLength) {
                    atoms = base.slice();
                    while (atoms.length > target) {
                        const index = this.state.rng.nextInt(0, atoms.length - 1);
                        atoms.splice(index, 1);
                    }
                } else if (target > originalLength) {
                    atoms = base.slice();
                    const axes = MATCH_AXES;
                    let guard = 0;
                    while (atoms.length < target && guard < 60) {
                        guard++;
                        const head = this.state.rng.choice(refLetters);
                        if (avoidLetters && avoidLetters.has(head)) continue;
                        let tailCandidates = refLetters.filter(letter => letter !== head);
                        if (avoidLetters) {
                            tailCandidates = tailCandidates.filter(letter => !avoidLetters.has(letter));
                        }
                        if (tailCandidates.length === 0) continue;
                        const tail = this.state.rng.choice(tailCandidates);
                        const axis = this.state.rng.choice(axes);
                        const candidate = new Atom(axis, head, tail);
                        if (atoms.some(atom => atom.toKey() === candidate.toKey())) continue;
                        atoms.push(candidate);
                    }
                    if (atoms.length !== target) return null;
                }
                const premise = new Premise(atoms);
                const shared = Array.from(premise.getLetters()).filter(letter => refSet.has(letter));
                if (shared.length < 2) return null;
                return premise;
            }

            makeAxisOrthoFoil(referencePremise) {
                const base = this.cloneAtoms(referencePremise);
                if (base.length === 0) return null;
                const index = this.state.rng.nextInt(0, base.length - 1);
                const orthMap = { N: 'E', S: 'W', E: 'N', W: 'S' };
                const axis = orthMap[base[index].axis];
                if (!axis) return null;
                base[index] = new Atom(axis, base[index].head, base[index].tail);
                return new Premise(base);
            }

            makeDerivedInOneFoil(referencePremise) {
                const base = this.cloneAtoms(referencePremise);
                if (base.length === 0) return null;
                const additions = [];
                for (let i = 0; i < base.length; i++) {
                    for (let j = 0; j < base.length; j++) {
                        if (i === j) continue;
                        const a = base[i];
                        const b = base[j];
                        if (a.axis !== b.axis) continue;
                        if (a.tail === b.head && a.head !== b.tail) {
                            const candidate = new Atom(a.axis, a.head, b.tail);
                            if (candidate.head !== candidate.tail && !base.some(atom => atom.equals(candidate))) {
                                additions.push(candidate);
                            }
                        }
                        if (b.tail === a.head && b.head !== a.tail) {
                            const candidate = new Atom(a.axis, b.head, a.tail);
                            if (candidate.head !== candidate.tail && !base.some(atom => atom.equals(candidate))) {
                                additions.push(candidate);
                            }
                        }
                    }
                }
                if (additions.length === 0) return null;
                base.push(this.state.rng.choice(additions));
                return new Premise(base);
            }

            makeWindowShadowFoil(referencePremise, middleAtoms) {
                if (!middleAtoms || middleAtoms.length === 0) return null;
                const base = this.cloneAtoms(referencePremise);
                if (base.length === 0) return null;
                const refLetters = referencePremise.getLetters();
                const options = middleAtoms.filter(atom => {
                    const already = base.some(existing => existing.equals(atom));
                    return !already && (refLetters.has(atom.head) || refLetters.has(atom.tail));
                });
                if (options.length === 0) return null;
                const replacement = this.state.rng.choice(options);
                const index = this.state.rng.nextInt(0, base.length - 1);
                base[index] = new Atom(replacement.axis, replacement.head, replacement.tail);
                return new Premise(base);
            }

            cloneAtoms(premise) {
                return premise.atoms.map(atom => new Atom(atom.axis, atom.head, atom.tail));
            }

            sampleNewLetter(excludeSet = new Set()) {
                const candidates = this.state.letters.filter(letter => !excludeSet.has(letter));
                if (candidates.length === 0) return null;
                return this.state.rng.choice(candidates);
            }

            normalizeAtomCount(atoms, pool, target, avoidLetters, options = {}) {
                if (!atoms) return null;
                const clones = atoms.map(atom => new Atom(atom.axis, atom.head, atom.tail));
                const required = new Set();
                if (typeof options.requiredIndex === 'number') {
                    required.add(options.requiredIndex);
                }
                if (Array.isArray(options.requiredIndices)) {
                    options.requiredIndices.forEach(idx => required.add(idx));
                }

                const result = [];
                const usedKeys = new Set();
                const pushAtom = (atom) => {
                    const key = atom.toKey();
                    if (usedKeys.has(key)) return false;
                    result.push(atom);
                    usedKeys.add(key);
                    return true;
                };

                for (const idx of required) {
                    if (idx >= 0 && idx < clones.length) {
                        pushAtom(clones[idx]);
                    }
                }

                for (let i = 0; i < clones.length && result.length < target; i++) {
                    if (required.has(i)) continue;
                    pushAtom(clones[i]);
                }

                const poolLetters = pool.length > 0 ? pool : this.state.letters;
                let attempts = 0;
                while (result.length < target && attempts < 200) {
                    attempts++;
                    const head = this.state.rng.choice(poolLetters);
                    if (avoidLetters && avoidLetters.has(head)) continue;
                    let tailCandidates = poolLetters.filter(letter => letter !== head);
                    if (avoidLetters) {
                        tailCandidates = tailCandidates.filter(letter => !avoidLetters.has(letter));
                    }
                    if (tailCandidates.length === 0) continue;
                    const tail = this.state.rng.choice(tailCandidates);
                    const axis = this.state.rng.choice(MATCH_AXES);
                    const atom = new Atom(axis, head, tail);
                    if (usedKeys.has(atom.toKey())) continue;
                    pushAtom(atom);
                }

                if (result.length !== target) return null;
                return result;
            }

            makeAxisSwapNearMiss({ nBackPremise, k, pool, avoidLetters }) {
                if (!nBackPremise || nBackPremise.atoms.length === 0) return null;
                const base = this.cloneAtoms(nBackPremise);
                const index = this.state.rng.nextInt(0, base.length - 1);
                const axisOptions = MATCH_AXES.filter(axis => axis !== base[index].axis);
                if (axisOptions.length === 0) return null;
                base[index] = new Atom(this.state.rng.choice(axisOptions), base[index].head, base[index].tail);
                return this.normalizeAtomCount(base, pool, k, avoidLetters, { requiredIndex: index });
            }

            makeAnchorPermutationNearMiss({ nBackPremise, k, pool }) {
                if (!nBackPremise) return null;
                const letters = Array.from(nBackPremise.getLetters());
                if (letters.length < 2) return null;
                const anchor = this.state.rng.choice(letters);
                const mapping = new Map();
                mapping.set(anchor, anchor);
                const used = new Set([anchor]);
                for (const letter of letters) {
                    if (letter === anchor) continue;
                    let replacement = null;
                    let tries = 0;
                    while (tries < 80) {
                        tries++;
                        replacement = this.sampleNewLetter(new Set([...letters, ...used]));
                        if (!replacement || replacement === anchor) continue;
                        mapping.set(letter, replacement);
                        used.add(replacement);
                        break;
                    }
                    if (!mapping.has(letter)) return null;
                }
                const atoms = nBackPremise.atoms.map(atom => {
                    const head = mapping.get(atom.head) || atom.head;
                    const tail = mapping.get(atom.tail) || atom.tail;
                    return new Atom(atom.axis, head, tail);
                });
                return this.normalizeAtomCount(atoms, pool, k, null);
            }

            makeParityPreservedHubFlip({ nBackPremise, k, pool, avoidLetters }) {
                if (!nBackPremise) return null;
                const counts = new Map();
                nBackPremise.atoms.forEach(atom => {
                    counts.set(atom.head, (counts.get(atom.head) || 0) + 1);
                    counts.set(atom.tail, (counts.get(atom.tail) || 0) + 1);
                });
                const sorted = Array.from(counts.entries()).sort((a, b) => b[1] - a[1]);
                if (!sorted.length || sorted[0][1] < 2) return null;
                const hub = sorted[0][0];
                const exclude = new Set(nBackPremise.getLetters());
                let newHub = this.sampleNewLetter(exclude);
                if (!newHub) return null;
                const atoms = nBackPremise.atoms.map(atom => {
                    const head = atom.head === hub ? newHub : atom.head;
                    const tail = atom.tail === hub ? newHub : atom.tail;
                    return new Atom(atom.axis, head, tail);
                });
                return this.normalizeAtomCount(atoms, pool, k, avoidLetters);
            }

            makeCycleBorderBait({ k, pool, avoidLetters }) {
                const uniquePool = Array.from(new Set(pool));
                const targetLetters = Math.max(3, Math.min(k + 1, 6));
                const letters = [];
                const used = new Set();
                const shuffled = this.state.rng.shuffle(uniquePool);
                for (const letter of shuffled) {
                    if (letters.length >= targetLetters) break;
                    letters.push(letter);
                    used.add(letter);
                }
                while (letters.length < targetLetters) {
                    const next = this.sampleNewLetter(used);
                    if (!next) break;
                    letters.push(next);
                    used.add(next);
                }
                if (letters.length < 3) return null;
                const axes = ['N', 'E', 'S', 'W'];
                const atoms = [];
                for (let i = 0; i < Math.min(k, letters.length - 1); i++) {
                    const axis = axes[i % axes.length];
                    atoms.push(new Atom(axis, letters[i], letters[i + 1]));
                }
                if (atoms.length < k) {
                    const axis = axes[atoms.length % axes.length];
                    const head = letters[letters.length - 1];
                    const tailIndex = letters.length > 2 ? 1 : 0;
                    atoms.push(new Atom(axis, head, letters[tailIndex]));
                }
                return this.normalizeAtomCount(atoms, pool, k, avoidLetters);
            }

            makeBipartiteSignatureMatch({ nBackPremise, k, pool }) {
                if (!nBackPremise) return null;
                const targetFeatures = nBackPremise.getFeatures();
                for (let attempt = 0; attempt < 12; attempt++) {
                    const atoms = this.buildMatchCandidate(nBackPremise, pool, k);
                    if (!atoms) return null;
                    const candidate = new Premise(atoms);
                    if (candidate.toKey() === nBackPremise.toKey()) continue;
                    if (!this.compareDegreeVectors(candidate.getFeatures().degreeVector, targetFeatures.degreeVector)) {
                        continue;
                    }
                    return atoms;
                }
                return null;
            }

            makeWrongLagCamouflage({ trialIndex, n, state, pool, k }) {
                let altPremise = null;
                if (n > 1) {
                    altPremise = state.getPremiseAt(trialIndex - (n - 1));
                }
                if (!altPremise) {
                    altPremise = state.getPremiseAt(trialIndex - (n + 1));
                }
                if (!altPremise) return null;
                for (let attempt = 0; attempt < 10; attempt++) {
                    const atoms = this.buildMatchCandidate(altPremise, pool, k);
                    if (!atoms) return null;
                    const candidate = new Premise(atoms);
                    const equivalence = this.equivalence.computeCertificate(altPremise, candidate, []);
                    if (!equivalence.match) {
                        continue;
                    }
                    return atoms;
                }
                return null;
            }

            makeCrossAxisCoupling(context) {
                const { nBackPremise, pool, k, plannedMatch, avoidLetters } = context;
                if (!nBackPremise) {
                    return plannedMatch
                        ? this.buildMatchCandidate(nBackPremise, pool, k)
                        : this.buildNovelPremise(pool, k, avoidLetters);
                }
                if (plannedMatch) {
                    for (let attempt = 0; attempt < 12; attempt++) {
                        const atoms = this.buildMatchCandidate(nBackPremise, pool, k);
                        if (!atoms) return null;
                        const candidate = new Premise(atoms);
                        if (candidate.toKey() === nBackPremise.toKey()) continue;
                        if (!this.hasCrossAxisCoupling(nBackPremise, candidate)) continue;
                        return atoms;
                    }
                    return null;
                }
                const atoms = this.makeParityPreservedHubFlip({ nBackPremise, k, pool, avoidLetters });
                if (!atoms) return null;
                const candidate = new Premise(atoms);
                return this.hasCrossAxisCoupling(nBackPremise, candidate) ? atoms : null;
            }

            makeIsomorphicSkeletonDecoy({ nBackPremise, k, pool }) {
                if (!nBackPremise) return null;
                const letters = Array.from(nBackPremise.getLetters());
                if (letters.length === 0) return null;
                const sorted = [...letters].sort();
                const anchor = this.state.rng.choice(sorted);
                const mapping = new Map();
                mapping.set(anchor, anchor);
                const used = new Set([anchor]);
                for (const letter of sorted) {
                    if (letter === anchor) continue;
                    let replacement = null;
                    let tries = 0;
                    while (tries < 80) {
                        tries++;
                        replacement = this.sampleNewLetter(new Set([...letters, ...used]));
                        if (!replacement || replacement === anchor) continue;
                        mapping.set(letter, replacement);
                        used.add(replacement);
                        break;
                    }
                    if (!mapping.has(letter)) return null;
                }
                const atoms = nBackPremise.atoms.map(atom => {
                    const head = mapping.get(atom.head) || atom.head;
                    const tail = mapping.get(atom.tail) || atom.tail;
                    return new Atom(atom.axis, head, tail);
                });
                const candidate = new Premise(atoms);
                if (candidate.isoSignature() !== nBackPremise.isoSignature()) {
                    return null;
                }
                return this.normalizeAtomCount(candidate.atoms, pool, k, null);
            }

            compareDegreeVectors(a, b) {
                if (a.size !== b.size) return false;
                for (const [letter, vecA] of a.entries()) {
                    const vecB = b.get(letter);
                    if (!vecB) return false;
                    for (let i = 0; i < vecA.length; i++) {
                        if (vecA[i] !== vecB[i]) return false;
                    }
                }
                return true;
            }

            collectAxisUsage(premise) {
                const usage = new Map();
                const mark = (letter, axis) => {
                    if (!usage.has(letter)) {
                        usage.set(letter, { vertical: false, horizontal: false });
                    }
                    const entry = usage.get(letter);
                    if (axis === 'N' || axis === 'S') {
                        entry.vertical = true;
                    } else {
                        entry.horizontal = true;
                    }
                };
                premise.atoms.forEach(atom => {
                    mark(atom.head, atom.axis);
                    mark(atom.tail, atom.axis);
                });
                return usage;
            }

            hasCrossAxisCoupling(p1, p2) {
                const usage1 = this.collectAxisUsage(p1);
                const usage2 = this.collectAxisUsage(p2);
                const letters = new Set([...usage1.keys(), ...usage2.keys()]);
                for (const letter of letters) {
                    const info1 = usage1.get(letter) || { vertical: false, horizontal: false };
                    const info2 = usage2.get(letter) || { vertical: false, horizontal: false };
                    if ((info1.vertical || info2.vertical) && (info1.horizontal || info2.horizontal)) {
                        return true;
                    }
                }
                return false;
            }

            buildMatchCandidate(nBackPremise, pool, k) {
                if (!nBackPremise) return null;
                const atoms = [];
                const nAtoms = nBackPremise.atoms;
                for (let i = 0; i < nAtoms.length; i++) {
                    const atom = nAtoms[i];
                    const invert = this.state.rng.next() < 0.6;
                    atoms.push(invert ? Atom.invert(atom) : new Atom(atom.axis, atom.head, atom.tail));
                }

                while (atoms.length < k) {
                    const head = this.state.rng.choice(pool);
                    const tailOptions = pool.filter(l => l !== head);
                    if (tailOptions.length === 0) break;
                    const tail = this.state.rng.choice(tailOptions);
                    const axis = this.state.rng.choice(MATCH_AXES);
                    atoms.push(new Atom(axis, head, tail));
                }
                return atoms.slice(0, k);
            }

            buildNovelPremise(pool, k, avoidLetters) {
                const atoms = [];
                const usedPairs = new Set();
                const axisWeights = MATCH_AXES.map(axis => 1 / (1 + this.state.axisUsage[axis]));

                for (let i = 0; i < k; i++) {
                    let attempts = 0;
                    while (attempts < 40) {
                        let head = this.state.rng.choice(pool);
                        let tailCandidates = pool.filter(letter => letter !== head);
                        if (avoidLetters && avoidLetters.size > 0) {
                            const filtered = tailCandidates.filter(letter => !avoidLetters.has(letter));
                            if (filtered.length > 0) {
                                tailCandidates = filtered;
                            }
                            if (avoidLetters.has(head)) {
                                const alternatives = pool.filter(letter => !avoidLetters.has(letter));
                                if (alternatives.length > 0) {
                                    head = this.state.rng.choice(alternatives);
                                    tailCandidates = pool.filter(letter => letter !== head && !avoidLetters.has(letter));
                                }
                            }
                        }

                        if (tailCandidates.length === 0) break;
                        const tail = this.state.rng.choice(tailCandidates);
                        const pairKey = `${head}|${tail}`;
                        if (usedPairs.has(pairKey)) {
                            attempts++;
                            continue;
                        }

                        const axis = this.state.rng.weightedChoice(MATCH_AXES, axisWeights);
                        atoms.push(new Atom(axis, head, tail));
                        usedPairs.add(pairKey);
                        break;
                    }
                }

                return atoms.length === k ? atoms : null;
            }

            buildDirectionWordPremise(plannedMatch, nBackPremise, k, middleAtoms, windowAtoms) {
                // Generate ATOMIC premises using direction words as spatial letters
                // Maximum k=2 for Level 5 difficulty target
                const DIRECTION_LETTERS_LOCAL = ['North', 'South', 'East', 'West'];
                const effectiveK = Math.min(k, 2);
                const META_AXES = ['N', 'S', 'E', 'W'];
                const attempts_limit = 120;

                console.log('buildDirectionWordPremise called - Level 6 active');

                for (let attempt = 0; attempt < attempts_limit; attempt++) {
                    const atoms = [];
                    const usedPairs = new Set();

                    for (let i = 0; i < effectiveK; i++) {
                        let head, tail, axis;
                        let pairAttempts = 0;

                        do {
                            head = this.state.rng.choice(DIRECTION_LETTERS_LOCAL);
                            const tailOptions = DIRECTION_LETTERS_LOCAL.filter(d => d !== head);
                            tail = this.state.rng.choice(tailOptions);
                            axis = this.state.rng.choice(META_AXES);

                            const pairKey = `${axis}:${head}:${tail}`;
                            if (!usedPairs.has(pairKey)) {
                                usedPairs.add(pairKey);
                                break;
                            }

                            pairAttempts++;
                        } while (pairAttempts < 20);

                        if (pairAttempts >= 20) break;

                        atoms.push(new Atom(axis, head, tail));
                    }

                    if (atoms.length !== effectiveK) continue;

                    // Create ATOMIC premise (not META_RELATIONAL!)
                    const premise = new Premise(atoms);

                    // CRITICAL: Run SAT solver for spatial consistency
                    const satResult = this.solver.analyze(windowAtoms, atoms);
                    if (!satResult.ok) continue;

                    // If plannedMatch, verify equivalence with n-back
                    if (plannedMatch && nBackPremise) {
                        const cert = this.equivalence.computeCertificate(
                            nBackPremise,
                            premise,
                            middleAtoms || [],
                            windowAtoms
                        );

                        if (!cert.match) continue;
                    } else if (nBackPremise) {
                        // For no-match trials, ensure we DON'T accidentally match
                        const cert = this.equivalence.computeCertificate(
                            nBackPremise,
                            premise,
                            middleAtoms || [],
                            windowAtoms
                        );

                        if (cert.match) continue; // Reject accidental matches
                    }

                    // Success!
                    return premise;
                }

                return null; // Failed after attempts_limit
            }


            generateCompoundOperator() {
                // Generate a compound operator like "north-west" or "south-east"
                // ALWAYS exactly 2 DIFFERENT operators (no "north-north" identity)
                const META_OPERATORS = ['north', 'south', 'east', 'west'];
                const op1 = this.state.rng.choice(META_OPERATORS);

                // Ensure op2 is different from op1
                const otherOps = META_OPERATORS.filter(op => op !== op1);
                const op2 = this.state.rng.choice(otherOps);

                return `${op1}-${op2}`;
            }

            generateCompoundOperator8D() {
                // Level 8: Generate 8-direction compound operators using uppercase letters
                // Randomly select two DIFFERENT operators from 8 directions
                // Creates 56 possible compounds (8√ó7)
                // Format: "NE-SW", "N-S", "W-E", etc.
                const op1 = this.state.rng.choice(LEVEL8_OPERATORS);

                // Ensure op2 is different from op1
                const otherOps = LEVEL8_OPERATORS.filter(op => op !== op1);
                const op2 = this.state.rng.choice(otherOps);

                return `${op1}-${op2}`;
            }

            generateCompoundOperator16D_Triple() {
                // Level 9: Generate 16-direction triple-compound operators (Hexa-Leap)
                // Randomly select THREE DIFFERENT operators from LEVEL9_OPERATORS
                // (N, NNE, NE, ENE, E, ESE, SE, SSE, S, SSW, SW, WSW, W, WNW, NW, NNW)
                // Creates 3,360 possible compounds (16√ó15√ó14)
                const op1 = this.state.rng.choice(LEVEL9_OPERATORS);

                // Ensure op2 is different from op1
                const otherOps1 = LEVEL9_OPERATORS.filter(op => op !== op1);
                const op2 = this.state.rng.choice(otherOps1);

                // Ensure op3 is different from op1 AND op2
                const otherOps2 = LEVEL9_OPERATORS.filter(op => op !== op1 && op !== op2);
                const op3 = this.state.rng.choice(otherOps2);

                return `${op1}-${op2}-${op3}`;
            }

            buildCompoundOperatorPremise(plannedMatch, nBackPremise, k) {
                // Generate Level 7: Compound Operator Relational premise
                // Example: "north-west is north of south-east"
                // k controls number of atoms: k=1 ‚Üí 1 atom, k=2 ‚Üí 2 atoms, etc.

                const numAtoms = Math.max(1, Math.min(4, k || 1));
                const META_AXES = ['N', 'S', 'E', 'W'];
                const atoms = [];

                try {
                    for (let i = 0; i < numAtoms; i++) {
                        // Generate two compound operators (always 2-operator sequences)
                        const compound1 = this.generateCompoundOperator();
                        const compound2 = this.generateCompoundOperator();

                        // Choose random meta-operator to relate them
                        const metaAxis = this.state.rng.choice(META_AXES);

                        // Create atom with compound operators as head/tail
                        atoms.push(new Atom(metaAxis, compound1, compound2));
                    }

                    return new Premise(atoms);
                } catch (err) {
                    console.error('buildCompoundOperatorPremise: critical error', err);
                    // Fallback to simple compound premise
                    return new Premise([new Atom('N', 'north-west', 'south-east')]);
                }
            }

            buildOctoOperatorPremise(plannedMatch, nBackPremise, k) {
                // Generate Level 8: 8-Direction Meta-Compound Operator premise
                // Example: "northeast-southwest is north of southeast-northwest"
                // Uses ATOMIC premise type with 8-direction compound operators (north, northeast, east, southeast, south, southwest, west, northwest)
                // Meta-operators expanded to 8-directional (north, northeast, east, southeast, south, southwest, west, northwest) - progression from Level 7's 4D meta-operators
                // k controls number of atoms: k=1 ‚Üí 1 atom, k=2 ‚Üí 2 atoms, etc.

                const numAtoms = Math.max(1, Math.min(4, k || 1));
                const META_AXES = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW']; // Meta-operators expanded to 8-directional
                const atoms = [];

                try {
                    for (let i = 0; i < numAtoms; i++) {
                        // Generate two 8-direction compound operators
                        const compound1 = this.generateCompoundOperator8D();
                        const compound2 = this.generateCompoundOperator8D();

                        // Choose random meta-operator to relate them (8-directional)
                        const metaAxis = this.state.rng.choice(META_AXES);

                        // Create atom with 8D compound operators as head/tail
                        atoms.push(new Atom(metaAxis, compound1, compound2));
                    }

                    return new Premise(atoms);
                } catch (err) {
                    console.error('buildOctoOperatorPremise: critical error', err);
                    // Fallback to simple 8D compound premise using uppercase letter format
                    return new Premise([new Atom('N', 'NE-SW', 'SE-NW')]);
                }
            }

            buildHexaLeapOperatorPremise(plannedMatch, nBackPremise, k) {
                // Generate Level 9: 16-Direction Triple-Nested Meta-Compound Operator premise (Hexa-Leap)
                // Example: "NNE-ESE-SSW is north of ENE-SSE-WSW"
                // Uses ATOMIC premise type with 16-direction triple-compound operators
                // (N, NNE, NE, ENE, E, ESE, SE, SSE, S, SSW, SW, WSW, W, WNW, NW, NNW)
                // Meta-operators expanded to 8-directional (N, NE, E, SE, S, SW, W, NW) - progression from Level 8
                // k controls number of atoms: k=1 ‚Üí 1 atom, k=2 ‚Üí 2 atoms, etc.

                const numAtoms = Math.max(1, Math.min(4, k || 1));
                const META_AXES = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW']; // Meta-operators expanded to 8-directional
                const atoms = [];

                try {
                    for (let i = 0; i < numAtoms; i++) {
                        // Generate two 16-direction triple-compound operators
                        const compound1 = this.generateCompoundOperator16D_Triple();
                        const compound2 = this.generateCompoundOperator16D_Triple();

                        // Choose random meta-operator to relate them (4-directional)
                        const metaAxis = this.state.rng.choice(META_AXES);

                        // Create atom with 16D triple-compound operators as head/tail
                        atoms.push(new Atom(metaAxis, compound1, compound2));
                    }

                    return new Premise(atoms);
                } catch (err) {
                    console.error('buildHexaLeapOperatorPremise: critical error', err);
                    // Fallback to simple 16D triple-compound premise
                    return new Premise([new Atom('NE', 'NNE-ESE-SSW', 'ENE-SSE-WSW')]);
                }
            }

        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // iOS-SPECIFIC FEMALE VOICE ENFORCEMENT SYSTEM
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // This VoiceSynthesis class implements comprehensive iOS Safari
        // Web Speech API bug workarounds to prevent male voice (Reed) usage.
        //
        // iOS CRITICAL BUGS FIXED:
        //
        // 1. VOICE OBJECT STALENESS (PRIMARY BUG):
        //    - Voice objects from getVoices() become "stale" when cached
        //    - Stale voice objects assigned to utterance.voice are IGNORED
        //    - iOS falls back to system default voice (Reed - MALE)
        //    - FIX: Store voiceName + voiceLang as STRINGS only
        //    - FIX: Call getFreshVoiceObject() before EVERY speak()
        //
        // 2. DUAL PROPERTY REQUIREMENT:
        //    - iOS requires BOTH utterance.voice AND utterance.lang set
        //    - Setting only ONE property causes iOS to IGNORE both
        //    - iOS falls back to default voice (Reed - MALE)
        //    - FIX: Always set both properties together in speak()
        //
        // 3. ONE VOICE PER LOCALE LIMITATION:
        //    - iOS allows only ONE voice per locale to be selected
        //    - For en-US, that voice is Samantha (FEMALE) - this is GOOD
        //    - Attempting other en-US voices causes fallback to Reed
        //    - FIX: Priority cascade locks to Samantha for iOS
        //
        // 4. ASYNCHRONOUS VOICE LOADING:
        //    - getVoices() returns empty array on first call
        //    - voiceschanged event is unreliable/never fires on Safari
        //    - FIX: Polling mechanism (250ms interval, 3000ms timeout)
        //
        // 5. USER GESTURE REQUIREMENT:
        //    - iOS requires speechSynthesis triggered from user interaction
        //    - FIX: unlockIOSSpeech() speaks empty utterance on button click
        //
        // SAFETY LAYERS:
        // - Layer 1: Null check - refuse if voiceName/voiceLang null
        // - Layer 2: Male voice pattern check - refuse if matches Reed, etc.
        // - Layer 3: Female voice confirmation - warn if no female match
        // - Layer 4: utterance.voice verification - refuse if not set
        // - Layer 5: iOS dual-property check - refuse if only one set
        // - Layer 6: Final male voice check - refuse if assigned voice is male
        //
        // All safety checks REFUSE TO SPEAK rather than risk default voice.
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        class VoiceSynthesis {
            constructor() {
                this.synth = window.speechSynthesis;

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // iOS CRITICAL FIX: Store voice NAME and LANG, NOT voice object
                // Voice objects become "stale" on iOS and cause fallback to Reed
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                this.voiceName = null;          // Store voice name as string
                this.voiceLang = null;          // Store voice lang as string
                this.voiceReady = false;
                this.pitch = 1.2;
                this.rate = 0.9;
                this.volume = 1.0;
                this.sessionToken = makeEpoch();

                // iOS-specific flags
                this.isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) ||
                            (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
                this.iosGestureUnlocked = false;

                console.log(`üé§ VoiceSynthesis initialized - Platform: ${this.isIOS ? 'iOS' : 'Desktop'}`);
            }

            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // iOS CRITICAL: User Gesture Unlock
            // iOS requires speechSynthesis to be triggered from user interaction
            // Call this on voice-mode button click to unlock speech for session
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            unlockIOSSpeech() {
                if (!this.isIOS || this.iosGestureUnlocked) {
                    return;
                }

                try {
                    // Speak empty utterance to unlock iOS speech synthesis
                    const unlockUtterance = new SpeechSynthesisUtterance('');
                    unlockUtterance.volume = 0;
                    this.synth.speak(unlockUtterance);
                    this.iosGestureUnlocked = true;
                    console.log('‚úì iOS speech synthesis unlocked via user gesture');
                } catch (err) {
                    console.warn('iOS gesture unlock failed:', err);
                }
            }

            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // iOS CRITICAL: Polling-Based Voice Loading
            // iOS Safari returns empty array on first getVoices() call
            // voiceschanged event is unreliable - use polling instead
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            async initialize() {
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log(`  Initializing voice system - Platform: ${this.isIOS ? 'iOS' : 'Desktop'}`);
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

                // iOS: Unlock speech from user gesture (if not already done)
                if (this.isIOS) {
                    this.unlockIOSSpeech();
                }

                return new Promise((resolve, reject) => {
                    let pollAttempts = 0;
                    const maxPollAttempts = 12; // 12 √ó 250ms = 3000ms max wait
                    const pollIntervalMs = 250; // Poll every 250ms

                    let pollInterval = null;
                    let pollTimeout = null;

                    const stopPolling = () => {
                        if (pollInterval) clearInterval(pollInterval);
                        if (pollTimeout) clearTimeout(pollTimeout);
                    };

                    // Polling function
                    const pollForVoices = () => {
                        pollAttempts++;
                        console.log(`üì¢ Polling for voices... attempt ${pollAttempts}/${maxPollAttempts}`);

                        try {
                            const voices = this.synth.getVoices();
                            console.log(`  Retrieved ${voices?.length || 0} voices from speechSynthesis.getVoices()`);

                            if (voices && voices.length > 0) {
                                // SUCCESS: Voices loaded
                                stopPolling();
                                console.log(`‚úì Voices loaded successfully after ${pollAttempts} attempts`);

                                try {
                                    this.selectVoice(voices);
                                    this.voiceReady = true;
                                    console.log(`‚úì Voice system initialized: ${this.voiceName || 'null'} (${this.voiceLang || 'null'})`);
                                    resolve();
                                } catch (err) {
                                    console.error('Voice selection failed:', err);
                                    reject(err);
                                }
                            }
                        } catch (error) {
                            console.error('Polling error:', error);
                            stopPolling();
                            reject(error);
                        }
                    };

                    // Timeout handler
                    pollTimeout = setTimeout(() => {
                        stopPolling();
                        console.error('‚úó Voice loading timeout after 3000ms');
                        reject(new Error('Voice loading timeout - no voices available'));
                    }, 3000);

                    // Start polling every 250ms
                    pollInterval = setInterval(pollForVoices, pollIntervalMs);

                    // Immediate first attempt
                    pollForVoices();

                    // Also listen for voiceschanged event (unreliable on iOS but doesn't hurt)
                    if (this.synth.onvoiceschanged !== undefined) {
                        this.synth.onvoiceschanged = () => {
                            console.log('  voiceschanged event fired (backup trigger)');
                            pollForVoices();
                        };
                    }
                });
            }

            selectVoice(voices) {
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log('    ULTRA-COMPREHENSIVE FEMALE-ONLY VOICE SELECTION (ANY LANGUAGE)');
                console.log('    USER REQUIREMENT: ANY female voice, ZERO male voices');
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log(`Total voices available: ${voices.length}`);

                // Log all available voices for debugging
                voices.forEach((v, idx) => {
                    console.log(`  [${idx}] ${v.name} (${v.lang}) - ${v.localService ? 'local' : 'remote'}`);
                });

                // Detect platform
                const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) ||
                             (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
                const platform = isIOS ? 'iOS' : 'Desktop';
                console.log(`Platform detected: ${platform}`);

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // LAYER 1: WESTERN-ONLY LANGUAGE WHITELIST
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                const westernLanguageCodes = [
                    'en-US', 'en-GB', 'en-AU', 'en-CA', 'en-NZ', 'en-IE', 'en-ZA',
                    'en', // Generic English
                    'fr-FR', 'fr-CA', 'fr-BE', 'fr-CH',
                    'de-DE', 'de-AT', 'de-CH',
                    'es-ES', 'es-MX', 'es-AR',
                    'it-IT', 'it-CH',
                    'pt-PT', 'pt-BR',
                    'nl-NL', 'nl-BE',
                    'sv-SE',
                    'da-DK',
                    'no-NO',
                    'fi-FI',
                    'pl-PL',
                    'cs-CZ',
                    'hu-HU',
                    'ro-RO',
                    'el-GR'
                ];

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // LAYER 2: NON-WESTERN LANGUAGE/ACCENT EXCLUSION (COMPLETE BLACKLIST)
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                const nonWesternLanguageCodes = [
                    // INDIAN LANGUAGES (ALL INDIAN ACCENTS - CRITICAL EXCLUSION)
                    'hi-IN', 'hi', 'ta-IN', 'ta', 'bn-IN', 'bn', 'te-IN', 'te',
                    'mr-IN', 'mr', 'gu-IN', 'gu', 'kn-IN', 'kn', 'ml-IN', 'ml',
                    'pa-IN', 'pa', 'or-IN', 'or', 'as-IN', 'as', 'ur-IN', 'ur',

                    // CHINESE LANGUAGES
                    'zh-CN', 'zh-TW', 'zh-HK', 'zh', 'cmn', 'yue', 'nan',

                    // JAPANESE
                    'ja-JP', 'ja',

                    // KOREAN
                    'ko-KR', 'ko',

                    // ARABIC LANGUAGES
                    'ar-SA', 'ar-EG', 'ar-AE', 'ar-DZ', 'ar', 'ar-MA', 'ar-TN',
                    'ar-IQ', 'ar-JO', 'ar-LB', 'ar-KW', 'ar-OM', 'ar-QA',

                    // RUSSIAN/SLAVIC (non-Western European)
                    'ru-RU', 'ru', 'uk-UA', 'uk', 'be-BY', 'be',

                    // THAI
                    'th-TH', 'th',

                    // VIETNAMESE
                    'vi-VN', 'vi',

                    // INDONESIAN/MALAY
                    'id-ID', 'id', 'ms-MY', 'ms',

                    // TURKISH
                    'tr-TR', 'tr',

                    // PERSIAN
                    'fa-IR', 'fa',

                    // HEBREW
                    'he-IL', 'he', 'iw-IL', 'iw'
                ];

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // LAYER 3: EXHAUSTIVE MALE VOICE EXCLUSION LIST (100+ NAMES)
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                const maleVoiceNames = [
                    // ‚ïê‚ïê‚ïê COMMON ENGLISH MALE VOICES ‚ïê‚ïê‚ïê
                    'Alex', 'Daniel', 'Fred', 'Tom', 'Thomas', 'Oliver', 'Ralph',
                    'Bruce', 'James', 'John', 'Nathan', 'Aaron', 'Jorge', 'Diego',
                    'Timothy', 'Mark', 'David', 'Richard', 'Chris', 'Christopher',
                    'Matthew', 'Paul', 'George', 'Kevin', 'Jason', 'Michael', 'Robert',
                    'William', 'Joseph', 'Charles', 'Steven', 'Edward', 'Brian',
                    'Andrew', 'Anthony', 'Donald', 'Kenneth', 'Joshua', 'Brandon',
                    'Justin', 'Ryan', 'Eric', 'Nicholas', 'Jacob', 'Jonathan',
                    'Samuel', 'Benjamin', 'Patrick', 'Alexander', 'Jack', 'Henry',
                    'Oscar', 'Adam', 'Ethan', 'Noah', 'Liam', 'Mason', 'Logan',
                    'Lucas', 'Isaac', 'Nathan', 'Caleb', 'Christian', 'Hunter',
                    'Jordan', 'Dylan', 'Brandon', 'Jose', 'Austin', 'Evan',
                    'Sean', 'Tyler', 'Kyle', 'Ian', 'Carter', 'Xavier',

                    // ‚ïê‚ïê‚ïê CRITICAL iOS/macOS MALE VOICES (PREVIOUSLY MISSING - MOST LIKELY CULPRITS) ‚ïê‚ïê‚ïê
                    'Reed', 'Reed (Enhanced)', 'Reed (Compact)',
                    'Rocko', 'Rocko (Enhanced)', 'Rocko (Compact)',
                    'Lee', 'Lee (Enhanced)', 'Lee (Compact)',
                    'Gordon', 'Gordon (Enhanced)', 'Gordon (Compact)',
                    'Martin', 'Martin (Enhanced)', 'Martin (Compact)',
                    'Xander', 'Xander (Enhanced)', 'Xander (Compact)',
                    'Yuri', 'Yuri (Enhanced)', 'Yuri (Compact)',
                    'Otoya', 'Otoya (Enhanced)', 'Otoya (Compact)',
                    'Maged', 'Maged (Enhanced)', 'Maged (Compact)',
                    'Majed', 'Majed (Enhanced)', 'Majed (Compact)',
                    'Tarik', 'Tarik (Enhanced)', 'Tarik (Compact)',

                    // ‚ïê‚ïê‚ïê ADDITIONAL iOS/macOS MALE VOICES ‚ïê‚ïê‚ïê
                    'Carmit', 'Carmit (Enhanced)', 'Carmit (Compact)',
                    'Lekha', 'Lekha (Enhanced)', 'Lekha (Compact)',
                    'Lesya', 'Lesya (Enhanced)', 'Lesya (Compact)',
                    'Luca', 'Luca (Enhanced)', 'Luca (Compact)',
                    'Maged', 'Majed', 'Tarik',
                    'Yannick', 'Yannick (Enhanced)', 'Yannick (Compact)',
                    'Steffi', 'Steffi (Enhanced)', 'Steffi (Compact)',
                    'Yuri', 'Yuri (Enhanced)', 'Yuri (Compact)',
                    'Xander', 'Xander (Enhanced)', 'Xander (Compact)',

                    // ‚ïê‚ïê‚ïê SIRI MALE VARIANTS (ALL) ‚ïê‚ïê‚ïê
                    'Siri Male', 'Siri Male (Enhanced)', 'Siri Male (Compact)',
                    'Siri Male #1', 'Siri Male #2', 'Siri Male #3', 'Siri Male #4',

                    // ‚ïê‚ïê‚ïê INDIAN MALE VOICES (CRITICAL EXCLUSION - RISHI) ‚ïê‚ïê‚ïê
                    'Rishi', 'Prabhat', 'Hemant', 'Swara', 'Kalpana',

                    // ‚ïê‚ïê‚ïê MICROSOFT MALE VOICES ‚ïê‚ïê‚ïê
                    'Microsoft David', 'Microsoft Mark', 'Microsoft Paul',
                    'Microsoft George', 'Microsoft Rishi', 'Microsoft James',
                    'Microsoft Sean', 'Microsoft Guy', 'Microsoft Michael',
                    'Microsoft David Desktop', 'Microsoft Mark Desktop',

                    // ‚ïê‚ïê‚ïê GOOGLE MALE VOICES ‚ïê‚ïê‚ïê
                    'Google UK English Male', 'Google US English Male',
                    'Google Hindi Male', 'Google Tamil Male', 'Google Bengali Male',
                    'Google French Male', 'Google German Male', 'Google Spanish Male',
                    'Google Italian Male', 'Google Portuguese Male',
                    'Google Arabic Male', 'Google Russian Male', 'Google Japanese Male',
                    'Google Korean Male', 'Google Chinese Male', 'Google Dutch Male',

                    // ‚ïê‚ïê‚ïê APPLE/iOS MALE VOICES (ALL VARIANTS) ‚ïê‚ïê‚ïê
                    'Alex (Enhanced)', 'Fred (Enhanced)', 'Daniel (Compact)',
                    'Oliver (Enhanced)', 'Ralph (Compact)', 'Tom (Compact)',
                    'Alex (Compact)', 'Fred (Compact)', 'Daniel (Enhanced)',
                    'Oliver (Compact)', 'Ralph (Enhanced)', 'Thomas (Enhanced)',
                    'Tom (Enhanced)', 'Bruce (Enhanced)', 'Bruce (Compact)',
                    'James (Enhanced)', 'James (Compact)', 'John (Enhanced)', 'John (Compact)',

                    // ‚ïê‚ïê‚ïê NOVELTY/OTHER PLATFORM MALE VOICES ‚ïê‚ïê‚ïê
                    'Albert', 'Bad News', 'Bahh', 'Bells', 'Boing', 'Bubbles',
                    'Cellos', 'Deranged', 'Good News', 'Hysterical', 'Junior',
                    'Pipe Organ', 'Trinoids', 'Whisper', 'Wobble', 'Zarvox',

                    // ‚ïê‚ïê‚ïê ADDITIONAL PLATFORM-SPECIFIC MALE VOICES ‚ïê‚ïê‚ïê
                    'Eddy', 'Grandpa', 'Rocky', 'Shelley', 'Superstar',
                    'Jacques', 'Henri', 'Antoine', 'Pierre', 'Marc',
                    'Klaus', 'Hans', 'Markus',
                    'Carlos', 'Juan', 'Luis', 'Miguel', 'Pablo',
                    'Luca', 'Paolo', 'Marco', 'Giorgio', 'Matteo',

                    // ‚ïê‚ïê‚ïê EUROPEAN/MULTILINGUAL MALE VOICES ‚ïê‚ïê‚ïê
                    'Diego', 'Diego (Enhanced)', 'Diego (Compact)',
                    'Jorge', 'Jorge (Enhanced)', 'Jorge (Compact)',
                    'Juan', 'Juan (Enhanced)', 'Juan (Compact)',
                    'Tomas', 'Tomas (Enhanced)', 'Tomas (Compact)',
                    'Damien', 'Damien (Enhanced)', 'Damien (Compact)',
                    'Nicolas', 'Nicolas (Enhanced)', 'Nicolas (Compact)',
                    'Matthias', 'Matthias (Enhanced)', 'Matthias (Compact)',
                    'Viktor', 'Viktor (Enhanced)', 'Viktor (Compact)',
                    'Marko', 'Marko (Enhanced)', 'Marko (Compact)'
                ];

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // LAYER 4: EXHAUSTIVE MALE VOICE REGEX PATTERNS
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                const malePatterns = [
                    // Common male names
                    /\balex\b/i, /\bdaniel\b/i, /\bfred\b/i, /\btom\b/i, /\bthomas\b/i,
                    /\boliver\b/i, /\bralph\b/i, /\bbruce\b/i, /\bjames\b/i, /\bjohn\b/i,
                    /\bnathan\b/i, /\baaron\b/i, /\bjorge\b/i, /\bdiego\b/i,
                    /\btimothy\b/i, /\bmark\b/i, /\bdavid\b/i, /\brichard\b/i,
                    /\bchris\b/i, /\bchristopher\b/i, /\bmatthew\b/i, /\bpaul\b/i,
                    /\bgeorge\b/i, /\bkevin\b/i, /\bjason\b/i, /\bmichael\b/i,
                    /\brobert\b/i, /\bwilliam\b/i, /\bjoseph\b/i, /\bcharles\b/i,
                    /\bsteven\b/i, /\bedward\b/i, /\bbrian\b/i, /\bandrew\b/i,
                    /\banthony\b/i, /\bdonald\b/i, /\bkenneth\b/i, /\bjoshua\b/i,
                    /\bjustin\b/i, /\bryan\b/i, /\beric\b/i, /\bjacob\b/i,
                    /\bpatrick\b/i, /\balexander\b/i, /\bjack\b/i, /\bhenry\b/i,
                    /\bethan\b/i, /\bnoah\b/i, /\bliam\b/i, /\bmason\b/i,
                    /\btyler\b/i, /\bkyle\b/i, /\bdylan\b/i, /\badam\b/i,
                    /\bsean\b/i, /\bcarlos\b/i, /\bjuan\b/i, /\bluis\b/i,

                    // CRITICAL iOS/macOS MALE VOICES (PREVIOUSLY MISSING - MOST LIKELY CULPRITS)
                    /\breed\b/i, /\brocko\b/i, /\blee\b/i, /\bgordon\b/i,
                    /\bmartin\b/i, /\bxander\b/i, /\byuri\b/i, /\botoya\b/i,
                    /\bmaged\b/i, /\bmajed\b/i, /\btarik\b/i,

                    // ADDITIONAL iOS/macOS MALE PATTERNS
                    /\bcarmit\b/i, /\blekha\b/i, /\blesya\b/i,
                    /\btomas\b/i, /\bdamien\b/i, /\bnicolas\b/i,
                    /\bmatthias\b/i, /\bviktor\b/i, /\bmarko\b/i,
                    /\bluca\b/i, /\bpaolo\b/i, /\bmarco\b/i, /\bgiorgio\b/i, /\bmatteo\b/i,
                    /\bjacques\b/i, /\bhenri\b/i, /\bantoine\b/i, /\bpierre\b/i, /\bmarc\b/i,
                    /\bklaus\b/i, /\bhans\b/i, /\bmarkus\b/i, /\byannick\b/i,
                    /\beddy\b/i, /\bgrandpa\b/i, /\brocky\b/i, /\bshelley\b/i, /\bsuperstar\b/i,

                    // SIRI MALE PATTERNS
                    /siri.*male/i, /male.*siri/i,

                    // INDIAN MALE VOICES (CRITICAL EXCLUSION - RISHI + ALL INDIAN NAMES)
                    /\brishi\b/i, /\bprabhat\b/i, /\bhemant\b/i,

                    // Generic male indicators
                    /\bmale\b/i, /\bman\b/i, /\b\(m\)\b/i, /\bmale voice\b/i,
                    /\bguy\b/i, /\bdude\b/i, /\bboy\b/i, /\bmr\b/i
                ];

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // LAYER 5: INDIAN VOICE EXCLUSION (NAME-BASED)
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                const indianVoiceNames = [
                    // ALL INDIAN VOICES (BOTH MALE AND FEMALE)
                    'Rishi', 'Prabhat', 'Hemant', 'Swara', 'Kalpana',
                    'Lekha', 'Raveena', 'Veena',
                    'Aditi', 'Anjali', 'Divya', 'Kavya', 'Priya', 'Shreya'
                ];

                const indianVoicePatterns = [
                    /\brishi\b/i, /\bprabhat\b/i, /\bhemant\b/i, /\bswara\b/i, /\bkalpana\b/i,
                    /\blekha\b/i, /\braveena\b/i, /\bveena\b/i,
                    /\baditi\b/i, /\banjali\b/i, /\bdivya\b/i, /\bkavya\b/i,
                    /\bpriya\b/i, /\bshreya\b/i,
                    /hindi/i, /tamil/i, /bengali/i, /telugu/i, /marathi/i, /gujarati/i,
                    /indian/i, /india/i
                ];

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // LAYER 6: COMPREHENSIVE WESTERN FEMALE VOICE INCLUSION LIST (50+)
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                const femaleVoiceNames = [
                    // ‚ïê‚ïê‚ïê COMMON ENGLISH FEMALE VOICES ‚ïê‚ïê‚ïê
                    'Samantha', 'Karen', 'Victoria', 'Susan', 'Zoe', 'Moira',
                    'Tessa', 'Fiona', 'Nicky', 'Serena', 'Hazel', 'Zira',
                    'Aria', 'Eva', 'Ava', 'Emma', 'Emily', 'Sarah', 'Kate',
                    'Anna', 'Lauren', 'Jessica', 'Jennifer', 'Michelle',
                    'Catherine', 'Elizabeth', 'Amanda', 'Rebecca', 'Nicole',
                    'Stephanie', 'Melissa', 'Ashley', 'Heather', 'Rachel',
                    'Amy', 'Laura', 'Angela', 'Kimberly', 'Lisa', 'Mary',
                    'Sandra', 'Nancy', 'Betty', 'Dorothy', 'Helen', 'Deborah',
                    'Donna', 'Carol', 'Ruth', 'Sharon', 'Cynthia',

                    // ‚ïê‚ïê‚ïê MICROSOFT WESTERN FEMALE VOICES ‚ïê‚ïê‚ïê
                    'Microsoft Zira', 'Microsoft Hazel', 'Microsoft Susan',
                    'Microsoft Zira Desktop', 'Microsoft Zira - English (United States)',
                    'Microsoft Linda', 'Microsoft Heather', 'Microsoft Laura',

                    // ‚ïê‚ïê‚ïê GOOGLE WESTERN FEMALE VOICES ‚ïê‚ïê‚ïê
                    'Google UK English Female', 'Google US English Female',
                    'Google Australian Female', 'Google French Female',
                    'Google German Female', 'Google Spanish Female',
                    'Google Italian Female', 'Google Portuguese Female',

                    // ‚ïê‚ïê‚ïê APPLE/iOS FEMALE VOICES (ALL VARIANTS) ‚ïê‚ïê‚ïê
                    'Samantha (Enhanced)', 'Karen (Enhanced)', 'Moira (Enhanced)',
                    'Tessa (Enhanced)', 'Victoria (Enhanced)', 'Fiona (Enhanced)',
                    'Samantha (Compact)', 'Karen (Compact)', 'Moira (Compact)',
                    'Tessa (Compact)', 'Victoria (Compact)', 'Fiona (Compact)',

                    // iOS format variations: "Name - Language (Country)"
                    'Samantha - English (United States)', 'Samantha - English (US)',
                    'Karen - English (Australia)', 'Karen - English (Australian)',
                    'Moira - English (Ireland)', 'Moira - English (Irish)',
                    'Tessa - English (South Africa)', 'Tessa - English (South African)',
                    'Victoria - English (United States)', 'Victoria - English (US)',
                    'Fiona - English (Scotland)', 'Fiona - English (Scottish)',
                    'Nicky - English (United States)', 'Serena - English (United Kingdom)',

                    // iOS format variations: "Name (Country Code)"
                    'Samantha (US)', 'Karen (AU)', 'Moira (IE)', 'Tessa (ZA)',
                    'Victoria (US)', 'Fiona (GB)', 'Nicky (US)', 'Serena (GB)',

                    // ‚ïê‚ïê‚ïê SIRI VARIANTS ‚ïê‚ïê‚ïê
                    'Siri Female', 'Siri Female (Enhanced)', 'Siri Female (Compact)',
                    'Siri (Female)', 'Siri - Female', 'Female Siri',

                    // ‚ïê‚ïê‚ïê EUROPEAN FEMALE VOICES ‚ïê‚ïê‚ïê
                    'Amelie', 'Audrey', 'Aurelie', 'Celine', 'Chantal',
                    'Marie', 'Sophie', 'Yelda', 'Zofia', 'Petra', 'Vicki',
                    'Katja', 'Sabina', 'Carmit', 'Kyoko', 'Luciana', 'Joana'
                ];

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // LAYER 7: WESTERN FEMALE VOICE REGEX PATTERNS (EXPANDED FOR iOS)
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                const femalePatterns = [
                    // Core female names (iOS/macOS primary)
                    /\bsamantha\b/i, /\bkaren\b/i, /\bvictoria\b/i, /\bsusan\b/i,
                    /\bzoe\b/i, /\bmoira\b/i, /\btessa\b/i, /\bfiona\b/i,
                    /\bnicky\b/i, /\bserena\b/i, /\bhazel\b/i, /\bzira\b/i,

                    // Additional common female names
                    /\baria\b/i, /\beva\b/i, /\bava\b/i, /\bemma\b/i,
                    /\bemily\b/i, /\bsarah\b/i, /\bkate\b/i, /\banna\b/i,
                    /\blauren\b/i, /\bjessica\b/i, /\bjennifer\b/i, /\bmichelle\b/i,
                    /\bcatherine\b/i, /\belizabeth\b/i, /\bamanda\b/i,
                    /\brebecca\b/i, /\bnicole\b/i, /\bstephanie\b/i, /\bmelissa\b/i,
                    /\bashley\b/i, /\bheather\b/i, /\brachel\b/i, /\bamy\b/i,
                    /\blaura\b/i, /\bangela\b/i, /\blisa\b/i, /\bmary\b/i,

                    // European female names
                    /\bamelie\b/i, /\baudrey\b/i, /\bceline\b/i, /\bmarie\b/i,
                    /\bsophie\b/i, /\bpietra\b/i, /\bvicki\b/i, /\bkatja\b/i,
                    /\bjoana\b/i, /\bluciana\b/i, /\bcarmit\b/i, /\bkyoko\b/i,

                    // Generic female indicators
                    /\bfemale\b/i, /\bwoman\b/i, /\b\(f\)\b/i, /\bfemale voice\b/i,
                    /\bsiri.*female\b/i, /female.*siri/i, /\blady\b/i, /\bgirl\b/i,
                    /\bms\b/i, /\bmiss\b/i, /\bmrs\b/i
                ];

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // SIMPLIFIED FILTERING: EXCLUDE MALES ONLY, ACCEPT ALL OTHERS
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // USER REQUIREMENT: "I just want a female voice, it doesn't have to be western"
                // NEW APPROACH: Inverse logic - reject ONLY male voices, accept everything else

                console.log('\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê');
                console.log('‚îÇ  FILTERING: REMOVING MALE VOICES ONLY (ANY LANGUAGE)   ‚îÇ');
                console.log('‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò');

                const femaleVoices = voices.filter(voice => {
                    const voiceName = voice.name;

                    // Check by male name (comprehensive list)
                    const isMaleName = maleVoiceNames.some(maleName =>
                        voiceName.toLowerCase() === maleName.toLowerCase() ||
                        voiceName.toLowerCase().includes(maleName.toLowerCase())
                    );

                    // Check by male pattern (regex)
                    const isMalePattern = malePatterns.some(pattern =>
                        pattern.test(voiceName)
                    );

                    if (isMaleName || isMalePattern) {
                        console.log(`  ‚úó‚úó‚úó EXCLUDED (MALE VOICE): ${voiceName} (${voice.lang})`);
                        return false;
                    }

                    console.log(`  ‚úì‚úì‚úì ACCEPTED (FEMALE/NON-MALE): ${voiceName} (${voice.lang})`);
                    return true;
                });

                console.log(`\nAfter male voice filtering: ${femaleVoices.length} voices remain (${voices.length - femaleVoices.length} male voices EXCLUDED)`);

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // CRITICAL RULE: If NO non-male voices exist, FAIL HARD
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                if (femaleVoices.length === 0) {
                    console.error('\n‚úó‚úó‚úó CRITICAL FAILURE ‚úó‚úó‚úó');
                    console.error('NO FEMALE VOICES AVAILABLE!');
                    console.error('All available voices matched male exclusion patterns.');
                    this.voiceName = null;
                    this.voiceLang = null;
                    this.showVoiceWarning('ERROR: Only male voices available on this system!');
                    console.log('\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                    console.log('   VOICE SELECTION FAILED (No female voices found)');
                    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');
                    return;
                }

                const finalVoicePool = femaleVoices;

                console.log(`FINAL VOICE POOL SIZE: ${finalVoicePool.length} female voices (any language)`);
                console.log(`  (${voices.length} original ‚Üí ${finalVoicePool.length} after male exclusion)\n`);

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // TIER 1: PLATFORM-SPECIFIC PRIORITY LISTS (PREFERRED VOICES)
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                const iOSFemalePriority = [
                    'Samantha',
                    'Samantha (Enhanced)',
                    'Karen',
                    'Karen (Enhanced)',
                    'Moira',
                    'Moira (Enhanced)',
                    'Tessa',
                    'Tessa (Enhanced)',
                    'Victoria',
                    'Victoria (Enhanced)',
                    'Fiona',
                    'Fiona (Enhanced)',
                    'Nicky',
                    'Serena',
                    'Siri Female',
                    'Siri Female (Enhanced)',
                    'Siri Female (Compact)'
                ];

                const desktopFemalePriority = [
                    'Samantha',
                    'Victoria',
                    'Karen',
                    'Susan',
                    'Zoe',
                    'Hazel',
                    'Zira',
                    'Microsoft Zira',
                    'Microsoft Zira Desktop',
                    'Microsoft Hazel',
                    'Microsoft Susan',
                    'Google US English Female',
                    'Google UK English Female',
                    'Google Australian Female'
                ];

                const priorityList = isIOS ? iOSFemalePriority : desktopFemalePriority;

                console.log('‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê');
                console.log('‚îÇ  TIER 1: PRIORITY LIST MATCHING                       ‚îÇ');
                console.log('‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò');

                for (const priorityName of priorityList) {
                    console.log(`  Trying priority voice: ${priorityName}`);
                    const match = finalVoicePool.find(v => v.name === priorityName);
                    if (match) {
                        console.log(`  ‚úì‚úì‚úì PRIORITY VOICE FOUND: ${match.name} (${match.lang})`);

                        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                        // FINAL SAFETY NET: Verify this is NOT a male voice (should never happen)
                        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                        const voiceName = match.name;
                        const isMaleName = maleVoiceNames.some(maleName =>
                            voiceName.toLowerCase().includes(maleName.toLowerCase())
                        );
                        const isMalePattern = malePatterns.some(pattern => pattern.test(voiceName));

                        if (isMaleName || isMalePattern) {
                            console.error(`  ‚úó‚úó‚úó SAFETY BLOCK: Priority voice "${voiceName}" matched MALE pattern! Skipping.`);
                            continue;
                        }

                        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                        // iOS CRITICAL: Store name and lang as STRINGS, not object
                        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                        this.voiceName = match.name;
                        this.voiceLang = match.lang;
                        this.persistVoice(match, this.isIOS);
                        console.log('\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                        console.log(`   VOICE SELECTION COMPLETE: ${this.voiceName} (${this.voiceLang})`);
                        console.log('   (Stored as name+lang strings for iOS compatibility)');
                        console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');
                        return;
                    }
                }
                console.log('  No priority matches found');

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // TIER 2: USE FIRST VOICE FROM FILTERED POOL
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                console.log('\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê');
                console.log('‚îÇ  TIER 2: SELECTING FIRST FEMALE VOICE FROM POOL        ‚îÇ');
                console.log('‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò');

                if (finalVoicePool.length > 0) {
                    const candidateVoice = finalVoicePool[0];
                    const voiceName = candidateVoice.name;

                    console.log(`  Candidate voice: ${voiceName} (${candidateVoice.lang})`);

                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    // FINAL SAFETY NET: Verify this is NOT a male voice (should never happen)
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    const isMaleName = maleVoiceNames.some(maleName =>
                        voiceName.toLowerCase().includes(maleName.toLowerCase())
                    );
                    const isMalePattern = malePatterns.some(pattern => pattern.test(voiceName));

                    if (isMaleName || isMalePattern) {
                        console.error(`  ‚úó‚úó‚úó SAFETY BLOCK: Candidate voice "${voiceName}" matched MALE pattern!`);
                        console.error('  This should never happen - male voice in female pool!');
                        this.voiceName = null;
                        this.voiceLang = null;
                        this.showVoiceWarning('ERROR: Male voice detected in female pool! Refusing assignment for safety.');
                        return;
                    }

                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    // iOS CRITICAL: Store name and lang as STRINGS, not object
                    // Voice passed male exclusion filter, so it's female - ACCEPT IT
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    this.voiceName = candidateVoice.name;
                    this.voiceLang = candidateVoice.lang;
                    console.log(`  ‚úì‚úì‚úì SELECTED: ${this.voiceName} (${this.voiceLang})`);
                    this.persistVoice(candidateVoice, this.isIOS);
                    console.log('\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                    console.log(`   VOICE SELECTION COMPLETE: ${this.voiceName} (${this.voiceLang})`);
                    console.log('   (Stored as name+lang strings for iOS compatibility)');
                    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');
                    return;
                }

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // CRITICAL FAILURE - No suitable voices exist
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                console.error('\n‚úó‚úó‚úó CRITICAL FAILURE ‚úó‚úó‚úó');
                console.error('No female voices available on this device!');
                console.error('All available voices matched male exclusion patterns.');
                console.error('This should not happen on iPhone - investigating available voices:');
                voices.forEach((v, idx) => {
                    console.error(`  [${idx}] ${v.name} (${v.lang})`);
                });
                this.voiceName = null;
                this.voiceLang = null;
                this.showVoiceWarning('ERROR: No female voice available on this device!');
                console.log('\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log('   VOICE SELECTION FAILED');
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');
            }

            // Helper method to persist voice selection with platform awareness
            persistVoice(voice, isIOS) {
                localStorage.setItem('relational-nback-voice-name', voice.name);
                localStorage.setItem('relational-nback-voice-lang', voice.lang);
                localStorage.setItem('relational-nback-voice-platform', isIOS ? 'ios' : 'desktop');
                console.log('Persisted voice:', voice.name, voice.lang, isIOS ? 'ios' : 'desktop');
            }

            // Method to reset voice selection (for manual override)
            resetVoiceSelection() {
                localStorage.removeItem('relational-nback-voice-name');
                localStorage.removeItem('relational-nback-voice-lang');
                localStorage.removeItem('relational-nback-voice-platform');
                this.voiceName = null;
                this.voiceLang = null;
                console.log('Voice selection reset');
            }

            // Display warning to user about voice selection issues
            showVoiceWarning(message) {
                console.warn(`VOICE WARNING: ${message}`);

                // Update voice-info element if it exists
                const voiceInfoEl = document.getElementById('voice-info');
                if (voiceInfoEl) {
                    voiceInfoEl.innerHTML = `<span style="color: #e74c3c;">‚ö† ${message}</span>`;
                }

                // Optionally show alert for critical issues
                if (message.includes('ERROR')) {
                    setTimeout(() => {
                        alert(`Voice System Warning:\n\n${message}\n\nThe game may not work correctly without a suitable voice.`);
                    }, 500);
                }
            }

            getVoiceInfo() {
                return this.voiceName ? `${this.voiceName} (${this.voiceLang})` : 'Voice not initialized';
            }

            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // iOS CRITICAL: Get FRESH voice object from getVoices()
            // NEVER return cached voice object - causes staleness on iOS
            // This method is called by speak() before EVERY utterance
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            getFreshVoiceObject() {
                if (!this.voiceName || !this.voiceLang) {
                    console.error('getFreshVoiceObject: No voice selected (voiceName/voiceLang null)');
                    return null;
                }

                try {
                    const voices = this.synth.getVoices();

                    if (!voices || voices.length === 0) {
                        console.error('getFreshVoiceObject: getVoices() returned empty array');
                        return null;
                    }

                    // Find voice by name AND lang (exact match)
                    const freshVoice = voices.find(v =>
                        v.name === this.voiceName &&
                        v.lang === this.voiceLang
                    );

                    if (freshVoice) {
                        console.log(`‚úì Fresh voice object retrieved: ${freshVoice.name} (${freshVoice.lang})`);
                        return freshVoice;
                    }

                    // FALLBACK: Selected voice not found - try to find ANY female voice
                    console.warn(`Selected voice "${this.voiceName}" (${this.voiceLang}) not found in current getVoices()`);
                    console.warn('Attempting fallback to ANY available female voice...');

                    // Use the same male exclusion logic as selectVoice()
                    const maleVoiceNames = ['Reed', 'Alex', 'Daniel', 'Fred', 'Tom', 'Thomas', 'Oliver', 'Ralph', 'Bruce', 'James', 'Rishi', 'Rocko', 'Lee', 'Gordon', 'Martin', 'Xander', 'Yuri'];
                    const malePatterns = [/\breed\b/i, /\balex\b/i, /\bmale\b/i, /\brishi\b/i, /\bman\b/i];

                    const anyFemaleVoice = voices.find(v => {
                        const isMaleName = maleVoiceNames.some(maleName =>
                            v.name.toLowerCase().includes(maleName.toLowerCase())
                        );
                        const isMalePattern = malePatterns.some(pattern => pattern.test(v.name));
                        return !isMaleName && !isMalePattern;
                    });

                    if (anyFemaleVoice) {
                        console.warn(`‚ö† Using fallback female voice: ${anyFemaleVoice.name} (${anyFemaleVoice.lang})`);
                        return anyFemaleVoice;
                    }

                    console.error('getFreshVoiceObject: No female voice found (all voices are male)');
                    return null;

                } catch (err) {
                    console.error('getFreshVoiceObject error:', err);
                    return null;
                }
            }

            // Backward compatibility alias (calls getFreshVoiceObject)
            getLockedVoice() {
                return this.getFreshVoiceObject();
            }

            async cancelAndWait() {
                try {
                    this.synth.cancel();
                } catch (error) {
                    console.warn('speechSynthesis.cancel failed', error);
                }
                await new Promise(resolve => setTimeout(resolve, 50));
                this.sessionToken = makeEpoch();
            }

            speak(text, guardToken = null) {
                if (!text) {
                    return Promise.resolve({ fallback: false, attempts: 0 });
                }

                return new Promise(resolve => {
                    if (guardToken && guardToken !== this.sessionToken) {
                        resolve({ fallback: false, attempts: 0 });
                        return;
                    }

                    const utterance = new SpeechSynthesisUtterance(text);
                    const voice = this.getLockedVoice();

                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    // CRITICAL SAFETY RULE #1: REFUSE TO SPEAK IF NO VOICE ASSIGNED
                    // This prevents browser from using its DEFAULT voice (male on iPhone)
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    if (!voice) {
                        console.error('‚úó‚úó‚úó CRITICAL SAFETY BLOCK: No voice assigned (this.voice is null)!');
                        console.error('REFUSING TO SPEAK to prevent browser default voice (likely male) from being used!');
                        console.error('Voice system failed to initialize properly or all voices were filtered out.');
                        console.error('Check browser console for voice selection errors.');
                        resolve({ fallback: true, attempts: 0 });
                        return;
                    }

                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    // COMPREHENSIVE SAFETY CHECK: Prevent ANY male voices from speaking
                    // This is the SECOND line of defense - if a male voice reaches here,
                    // we refuse to speak rather than use it
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    if (voice) {
                        const voiceName = voice.name;

                        // EXHAUSTIVE male voice detection patterns (CRITICAL - includes Reed, Rocko, Lee, Gordon, etc.)
                        const malePatterns = [
                            // Common male names
                            /\balex\b/i, /\bdaniel\b/i, /\bfred\b/i, /\btom\b/i, /\bthomas\b/i,
                            /\boliver\b/i, /\bralph\b/i, /\bbruce\b/i, /\bjames\b/i, /\bjohn\b/i,
                            /\bnathan\b/i, /\baaron\b/i, /\bjorge\b/i, /\bdiego\b/i,
                            /\bmark\b/i, /\bdavid\b/i, /\brichard\b/i, /\bpaul\b/i, /\bgeorge\b/i,
                            /\bmichael\b/i, /\brobert\b/i, /\bwilliam\b/i, /\bjoseph\b/i,

                            // CRITICAL iOS/macOS male voices (PREVIOUSLY MISSING)
                            /\breed\b/i, /\brocko\b/i, /\blee\b/i, /\bgordon\b/i,
                            /\bmartin\b/i, /\bxander\b/i, /\byuri\b/i, /\botoya\b/i,
                            /\bmaged\b/i, /\bmajed\b/i, /\btarik\b/i,

                            // Additional male voices
                            /\bluca\b/i, /\bpaolo\b/i, /\bmarco\b/i, /\btomas\b/i,
                            /\bnicolas\b/i, /\bviktor\b/i, /\bmarko\b/i,

                            // INDIAN MALE VOICES
                            /\brishi\b/i, /\bprabhat\b/i, /\bhemant\b/i,

                            // Siri male
                            /siri.*male/i, /male.*siri/i,

                            // Generic male indicators
                            /\bmale\b/i, /\bman\b/i, /\b\(m\)\b/i, /\bmale voice\b/i,
                            /\bguy\b/i, /\bdude\b/i, /\bboy\b/i, /\bmr\b/i
                        ];

                        const isMaleVoice = malePatterns.some(pattern => pattern.test(voiceName));

                        if (isMaleVoice) {
                            console.error(`‚úó‚úó‚úó RUNTIME SAFETY BLOCK: Prevented male voice "${voiceName}" from speaking!`);
                            console.error('CRITICAL: Male voice bypassed selectVoice filtering - this should NEVER happen!');
                            console.error('Refusing to speak. Voice system is compromised.');
                            resolve({ fallback: true, attempts: 0 });
                            return;
                        }

                        // ADDITIONAL SAFETY: Confirm voice matches female patterns (EXPANDED FOR iOS)
                        const femalePatterns = [
                            // Core iOS/macOS female voices
                            /\bsamantha\b/i, /\bkaren\b/i, /\bvictoria\b/i, /\bsusan\b/i,
                            /\bzoe\b/i, /\bmoira\b/i, /\btessa\b/i, /\bfiona\b/i,
                            /\bnicky\b/i, /\bserena\b/i, /\bhazel\b/i, /\bzira\b/i,

                            // Additional common female names
                            /\baria\b/i, /\beva\b/i, /\bava\b/i, /\bemma\b/i,
                            /\bemily\b/i, /\bsarah\b/i, /\bkate\b/i, /\banna\b/i,
                            /\blauren\b/i, /\bjessica\b/i, /\bjennifer\b/i, /\bmichelle\b/i,
                            /\bcatherine\b/i, /\belizabeth\b/i, /\bamanda\b/i,
                            /\brebecca\b/i, /\bnicole\b/i, /\bstephanie\b/i, /\bmelissa\b/i,

                            // European female names
                            /\bamelie\b/i, /\baudrey\b/i, /\bceline\b/i, /\bmarie\b/i,
                            /\bsophie\b/i, /\bvicki\b/i, /\bkatja\b/i, /\bjoana\b/i,
                            /\bluciana\b/i,

                            // Generic female indicators
                            /\bfemale\b/i, /\bwoman\b/i, /\bsiri.*female\b/i, /female.*siri/i,
                            /\blady\b/i, /\bgirl\b/i, /\b\(f\)\b/i
                        ];

                        const isFemaleVoice = femalePatterns.some(pattern => pattern.test(voiceName));

                        if (!isFemaleVoice) {
                            console.warn(`‚ö† WARNING: Voice "${voiceName}" does not match known female patterns`);
                            console.warn('Allowing it to proceed, but this voice may not be female');
                            console.warn('If you hear a male voice, please report this immediately');
                        }

                        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                        // iOS CRITICAL: Set BOTH utterance.voice AND utterance.lang
                        // Setting only ONE property causes iOS to ignore and use default
                        // BOTH must be set together or iOS falls back to Reed (male)
                        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                        utterance.voice = voice;
                        utterance.lang = voice.lang;

                        if (this.isIOS) {
                            console.log(`iOS: Set both utterance.voice="${voice.name}" AND utterance.lang="${voice.lang}"`);
                        }
                    }

                    utterance.pitch = this.pitch;
                    utterance.rate = this.rate;
                    utterance.volume = this.volume;

                    let settled = false;
                    const finish = (fallback) => {
                        if (settled) return;
                        settled = true;
                        clearTimeout(fallbackTimer);
                        resolve({ fallback, attempts: 1 });
                    };

                    const fallbackTimer = setTimeout(() => finish(true), estimateUtteranceMs(text, this.rate) + 400);

                    utterance.onend = () => finish(false);
                    utterance.onerror = () => finish(true);

                    setTimeout(() => {
                        if (settled) return;
                        if (guardToken && guardToken !== this.sessionToken) {
                            finish(true);
                            return;
                        }
                        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                        // CRITICAL SAFETY RULE #2: VERIFY utterance.voice IS SET
                        // Final check before speaking - if utterance.voice is not set,
                        // browser will use DEFAULT voice (Reed on iPhone)
                        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                        if (!utterance.voice) {
                            console.error('‚úó‚úó‚úó CRITICAL SAFETY BLOCK: utterance.voice is not set!');
                            console.error('REFUSING TO SPEAK - would use browser default voice (male)!');
                            console.error('This should NEVER happen - voice was not properly assigned to utterance.');
                            finish(true);
                            return;
                        }

                        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                        // iOS CRITICAL: VERIFY BOTH utterance.voice AND utterance.lang ARE SET
                        // iOS requires BOTH properties or ignores voice and uses default Reed
                        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                        if (this.isIOS) {
                            if (!utterance.voice || !utterance.lang) {
                                console.error('‚úó‚úó‚úó iOS CRITICAL SAFETY BLOCK: utterance.voice OR utterance.lang not set!');
                                console.error(`utterance.voice: ${utterance.voice?.name || 'NULL'}`);
                                console.error(`utterance.lang: ${utterance.lang || 'NULL'}`);
                                console.error('iOS requires BOTH properties set or will use default voice (Reed - male)!');
                                console.error('REFUSING TO SPEAK!');
                                finish(true);
                                return;
                            }
                            console.log(`‚úì iOS dual-property check passed: voice="${utterance.voice.name}", lang="${utterance.lang}"`);
                        }

                        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                        // FINAL VERIFICATION: Confirm assigned voice is female
                        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                        const assignedVoiceName = utterance.voice.name;
                        console.log(`üì¢ About to speak with voice: "${assignedVoiceName}" (${utterance.voice.lang})`);

                        // One last male voice check (includes Reed - iOS default)
                        const finalMaleCheck = [
                            /\breed\b/i, /\brocko\b/i, /\balex\b/i, /\bfred\b/i, /\btom\b/i,
                            /\bmale\b/i, /\bman\b/i, /\brishi\b/i, /\blee\b/i, /\bgordon\b/i,
                            /\bmartin\b/i, /\bxander\b/i, /\byuri\b/i, /\botoya\b/i,
                            /\bmaged\b/i, /\bmajed\b/i, /\btarik\b/i, /\bdaniel\b/i
                        ];

                        if (finalMaleCheck.some(pattern => pattern.test(assignedVoiceName))) {
                            console.error(`‚úó‚úó‚úó FINAL SAFETY BLOCK: Assigned voice "${assignedVoiceName}" is MALE!`);
                            console.error('REFUSING TO SPEAK!');
                            finish(true);
                            return;
                        }

                        try {
                            this.synth.resume();
                        } catch (err) {
                            console.warn('speechSynthesis.resume failed', err);
                        }
                        try {
                            this.synth.speak(utterance);
                        } catch (err) {
                            console.warn('speechSynthesis.speak failed', err);
                            finish(true);
                        }
                    }, 120);
                });
            }

            async speakPremise(premise, guardToken = null) {
                if (!premise) {
                    return { fallback: false, attempts: 0 };
                }
                const text = formatPremiseForSpeech(premise);
                return this.speak(text, guardToken);
            }
        }

        class GameEngine {
            constructor() {
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log('GameEngine constructor called');
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                this.session = sessionDefaults();
                this.session.state = 'STOPPED';
                this.seedManager = new SeedManager();
                this.logger = new GameLogger();
                this.voice = new VoiceSynthesis();
                this.state = null;
                this.solver = null;
                this.equivalence = new EquivalenceEngine(false);
                this.generator = null;
                this.planner = null;
                this.matchSchedule = [];
                this.awaitingResponse = false;
                this.sessionToken = makeEpoch();
                this.responseStartTime = 0;
                this.currentPremises = [];
                this.score = 0;
                this.correctResponses = 0;
                this.totalResponses = 0;
                this.omissions = 0;
                this.recentAccuracy = [];
                this.M = 8;
                this.lockSeed = this.seedManager.getLockPreference();
                this.resetOnRestart = false;
                this.pendingPlannerFlip = false;
                this.pendingRestart = false;
                this.statusMessage = 'Idle';
                this.policy = AdvancePolicy.ACTIVE;
                this.lastSpokenFallback = false;
                this.activePremise = null;
                this.forceMetaLeap = false;
                this.forceCompoundLeap = false;
                this.forceOctoLeap = false;
                this.forceHexaLeap = false;
                console.log('GameEngine initial flags:', {
                    forceMetaLeap: this.forceMetaLeap,
                    forceCompoundLeap: this.forceCompoundLeap,
                    forceOctoLeap: this.forceOctoLeap,
                    forceHexaLeap: this.forceHexaLeap
                });
            }

            get n() {
                return this.session.n;
            }

            set n(value) {
                this.session.n = value;
            }

            get k() {
                return this.session.k;
            }

            set k(value) {
                this.session.k = value;
            }

            get secondsPerTrial() {
                return this.session.secondsPerTrial;
            }

            set secondsPerTrial(value) {
                this.session.secondsPerTrial = value;
            }

            get totalTrials() {
                return this.session.numTrials;
            }

            set totalTrials(value) {
                this.session.numTrials = value;
            }

            applyNumTrialsFromUI() {
                const current = loadNumTrials();
                this.session.numTrials = current;
                return current;
            }

            speakOnce(text) {
                if (!text) return;
                this.voice.speak(text, this.voice.sessionToken);
            }

            renderSummary() {
                this.statusMessage = `Session complete. ${this.session.numTrials} trials finished.`;
                const feedbackEl = document.getElementById('feedback');
                if (feedbackEl) {
                    feedbackEl.textContent = '';
                    feedbackEl.className = 'feedback';
                }
            }

            async initialize() {
                await this.voice.initialize();

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // iOS CRITICAL: Unlock speech synthesis from user gesture
                // Must be called after voice.initialize() to enable iOS speech
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                this.voice.unlockIOSSpeech();

                this.updateVoiceInfo();
                this.attachUI();
                this.updateUI();
            }

            attachUI() {
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log('attachUI() called');
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                if (window._imagiHandlersBound) {
                    console.log('attachUI: Handlers already bound, returning early');
                    return;
                }
                window._imagiHandlersBound = true;

                const lockSeedToggle = document.getElementById('lock-seed-toggle');
                if (lockSeedToggle) {
                    lockSeedToggle.checked = this.lockSeed;
                    lockSeedToggle.addEventListener('change', (e) => {
                        this.lockSeed = e.target.checked;
                        this.seedManager.setLockPreference(this.lockSeed);
                    });
                }

                const resetSeedToggle = document.getElementById('reset-seed-toggle');
                if (resetSeedToggle) {
                    resetSeedToggle.addEventListener('change', (e) => {
                        this.resetOnRestart = e.target.checked;
                    });
                }

                const transitivityToggle = document.getElementById('transitivity-toggle');
                if (transitivityToggle) {
                    this.equivalence.setTransitivity(transitivityToggle.checked); // Apply initial state
                    transitivityToggle.addEventListener('change', (e) => {
                        this.equivalence.setTransitivity(e.target.checked);
                    });
                }

                const gLeapToggle = document.getElementById('g-leap-toggle');
                console.log('Looking for g-leap-toggle checkbox...');
                console.log('g-leap-toggle element:', gLeapToggle);
                if (gLeapToggle) {
                    console.log('g-leap-toggle FOUND');
                    console.log('g-leap-toggle initial checked state:', gLeapToggle.checked);
                    this.forceMetaLeap = gLeapToggle.checked; // Apply initial state
                    console.log('Set this.forceMetaLeap to:', this.forceMetaLeap);
                    gLeapToggle.addEventListener('change', (e) => {
                        console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                        console.log('g-leap-toggle CHANGED EVENT FIRED');
                        console.log('New checked state:', e.target.checked);
                        console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                        this.forceMetaLeap = e.target.checked;
                        console.log('this.forceMetaLeap now:', this.forceMetaLeap);

                        // If Level 6 enabled, disable Level 7 and Level 8
                        if (this.forceMetaLeap) {
                            const compoundToggle = document.getElementById('compound-leap-toggle');
                            if (compoundToggle) compoundToggle.checked = false;
                            this.forceCompoundLeap = false;

                            const octoToggle = document.getElementById('octo-leap-toggle');
                            if (octoToggle) octoToggle.checked = false;
                            this.forceOctoLeap = false;

                            const hexaToggle = document.getElementById('hexa-leap-toggle');
                            if (hexaToggle) hexaToggle.checked = false;
                            this.forceHexaLeap = false;
                        }

                        // Disable transitivity toggle in META mode (doesn't apply to operator logic)
                        const transitivityCtrl = document.getElementById('transitivity-toggle');
                        if (transitivityCtrl) {
                            transitivityCtrl.disabled = this.forceMetaLeap || this.forceCompoundLeap || this.forceOctoLeap || this.forceHexaLeap;
                        }

                        // Update k slider label to show what k means in META mode
                        const kLabel = document.getElementById('k-label');
                        if (kLabel) {
                            kLabel.textContent = this.forceHexaLeap ? '16D Triple-Compound Atoms' :
                                               this.forceOctoLeap ? '8D Compound Atoms' :
                                               this.forceCompoundLeap ? 'Compound Atoms' :
                                               this.forceMetaLeap ? 'Operator Pairs' : 'Atoms per Premise';
                        }
                    });
                }

                const compoundLeapToggle = document.getElementById('compound-leap-toggle');
                if (compoundLeapToggle) {
                    this.forceCompoundLeap = compoundLeapToggle.checked; // Apply initial state
                    compoundLeapToggle.addEventListener('change', (e) => {
                        this.forceCompoundLeap = e.target.checked;

                        // If Level 7 enabled, disable Level 6, Level 8, and Level 9
                        if (this.forceCompoundLeap) {
                            const gToggle = document.getElementById('g-leap-toggle');
                            if (gToggle) gToggle.checked = false;
                            this.forceMetaLeap = false;

                            const octoToggle = document.getElementById('octo-leap-toggle');
                            if (octoToggle) octoToggle.checked = false;
                            this.forceOctoLeap = false;

                            const hexaToggle = document.getElementById('hexa-leap-toggle');
                            if (hexaToggle) hexaToggle.checked = false;
                            this.forceHexaLeap = false;
                        }

                        // Disable transitivity toggle in COMPOUND mode (doesn't apply)
                        const transitivityCtrl = document.getElementById('transitivity-toggle');
                        if (transitivityCtrl) {
                            transitivityCtrl.disabled = this.forceMetaLeap || this.forceCompoundLeap || this.forceOctoLeap || this.forceHexaLeap;
                        }

                        // Update k slider label
                        const kLabel = document.getElementById('k-label');
                        if (kLabel) {
                            kLabel.textContent = this.forceHexaLeap ? '16D Triple-Compound Atoms' :
                                               this.forceOctoLeap ? '8D Compound Atoms' :
                                               this.forceCompoundLeap ? 'Compound Atoms' :
                                               this.forceMetaLeap ? 'Operator Pairs' : 'Atoms per Premise';
                        }
                    });
                }

                const octoLeapToggle = document.getElementById('octo-leap-toggle');
                if (octoLeapToggle) {
                    this.forceOctoLeap = octoLeapToggle.checked; // Apply initial state
                    octoLeapToggle.addEventListener('change', (e) => {
                        this.forceOctoLeap = e.target.checked;

                        // If Level 8 enabled, disable Level 6, Level 7, and Level 9 (mutually exclusive)
                        if (this.forceOctoLeap) {
                            const gToggle = document.getElementById('g-leap-toggle');
                            if (gToggle) gToggle.checked = false;
                            this.forceMetaLeap = false;

                            const compoundToggle = document.getElementById('compound-leap-toggle');
                            if (compoundToggle) compoundToggle.checked = false;
                            this.forceCompoundLeap = false;

                            const hexaToggle = document.getElementById('hexa-leap-toggle');
                            if (hexaToggle) hexaToggle.checked = false;
                            this.forceHexaLeap = false;
                        }

                        // Disable transitivity toggle in OCTO mode (doesn't apply)
                        const transitivityCtrl = document.getElementById('transitivity-toggle');
                        if (transitivityCtrl) {
                            transitivityCtrl.disabled = this.forceMetaLeap || this.forceCompoundLeap || this.forceOctoLeap || this.forceHexaLeap;
                        }

                        // Update k slider label
                        const kLabel = document.getElementById('k-label');
                        if (kLabel) {
                            kLabel.textContent = this.forceHexaLeap ? '16D Triple-Compound Atoms' :
                                               this.forceOctoLeap ? '8D Compound Atoms' :
                                               this.forceCompoundLeap ? 'Compound Atoms' :
                                               this.forceMetaLeap ? 'Operator Pairs' : 'Atoms per Premise';
                        }
                    });
                }

                const hexaLeapToggle = document.getElementById('hexa-leap-toggle');
                if (hexaLeapToggle) {
                    this.forceHexaLeap = hexaLeapToggle.checked; // Apply initial state
                    hexaLeapToggle.addEventListener('change', (e) => {
                        this.forceHexaLeap = e.target.checked;

                        // If Level 9 enabled, disable Level 6, Level 7, and Level 8 (mutually exclusive)
                        if (this.forceHexaLeap) {
                            const gToggle = document.getElementById('g-leap-toggle');
                            if (gToggle) gToggle.checked = false;
                            this.forceMetaLeap = false;

                            const compoundToggle = document.getElementById('compound-leap-toggle');
                            if (compoundToggle) compoundToggle.checked = false;
                            this.forceCompoundLeap = false;

                            const octoToggle = document.getElementById('octo-leap-toggle');
                            if (octoToggle) octoToggle.checked = false;
                            this.forceOctoLeap = false;
                        }

                        // Disable transitivity toggle in HEXA mode (doesn't apply)
                        const transitivityCtrl = document.getElementById('transitivity-toggle');
                        if (transitivityCtrl) {
                            transitivityCtrl.disabled = this.forceMetaLeap || this.forceCompoundLeap || this.forceOctoLeap || this.forceHexaLeap;
                        }

                        // Update k slider label
                        const kLabel = document.getElementById('k-label');
                        if (kLabel) {
                            kLabel.textContent = this.forceHexaLeap ? '16D Triple-Compound Atoms' :
                                               this.forceOctoLeap ? '8D Compound Atoms' :
                                               this.forceCompoundLeap ? 'Compound Atoms' :
                                               this.forceMetaLeap ? 'Operator Pairs' : 'Atoms per Premise';
                        }
                    });
                }

                const debugToggle = document.getElementById('debug-toggle');
                if (debugToggle) {
                    debugToggle.addEventListener('change', (e) => {
                        document.getElementById('debug').hidden = !e.target.checked;
                    });
                }

                const sptSlider = document.getElementById('spt-slider');
                const sptNumber = document.getElementById('spt-number');
                const syncSeconds = (value) => {
                    this.secondsPerTrial = parseFloat(value);
                    const sptValue = document.getElementById('spt-value');
                    if (sptValue) {
                        sptValue.textContent = this.secondsPerTrial.toFixed(1);
                    }
                };
                if (sptSlider) {
                    sptSlider.addEventListener('input', (e) => {
                        if (sptNumber) {
                            sptNumber.value = e.target.value;
                        }
                        syncSeconds(e.target.value);
                    });
                }
                if (sptNumber) {
                    sptNumber.addEventListener('input', (e) => {
                        if (sptSlider) {
                            sptSlider.value = e.target.value;
                        }
                        syncSeconds(e.target.value);
                    });
                }

                const nSlider = document.getElementById('n-slider');
                if (nSlider) {
                    nSlider.addEventListener('input', (e) => {
                        this.n = parseInt(e.target.value, 10);
                        const nValue = document.getElementById('n-value');
                        if (nValue) {
                            nValue.textContent = this.n;
                        }
                    });
                }

                const kSlider = document.getElementById('k-slider');
                if (kSlider) {
                    kSlider.addEventListener('input', (e) => {
                        this.k = parseInt(e.target.value, 10);
                        const kValue = document.getElementById('k-value');
                        if (kValue) {
                            kValue.textContent = this.k;
                        }
                    });
                }

                const startBtn = document.getElementById('start-btn');
                if (startBtn) {
                    startBtn.addEventListener('click', () => {
                        this.pendingRestart = false;
                        startSession();
                    });
                }

                const restartBtn = document.getElementById('restart-btn');
                if (restartBtn) {
                    restartBtn.addEventListener('click', () => {
                        restartSession();
                    });
                }

                const stopBtn = document.getElementById('stop-btn');
                if (stopBtn) {
                    stopBtn.addEventListener('click', () => {
                        stopSession();
                    });
                }

                const repeatBtn = document.getElementById('repeat-btn');
                if (repeatBtn) {
                    repeatBtn.addEventListener('click', () => {
                        onRepeatPressed();
                    });
                }

                const previewBtn = document.getElementById('preview-btn');
                if (previewBtn) {
                    previewBtn.addEventListener('click', async () => {
                        const previewPremise = new Premise([
                            new Atom('N', 'A', 'B'),
                            new Atom('E', 'C', 'D')
                        ]);
                        await this.voice.speakPremise(previewPremise, this.voice.sessionToken);
                    });
                }

                const resetVoiceBtn = document.getElementById('reset-voice-btn');
                if (resetVoiceBtn) {
                    resetVoiceBtn.addEventListener('click', async () => {
                        console.log('Manual voice reset requested');
                        // Reset voice selection and re-initialize
                        this.voice.resetVoiceSelection();
                        this.voice.voiceReady = false;

                        try {
                            await this.voice.initialize();
                            this.updateVoiceInfo();
                            alert('Voice selection has been reset and re-initialized.\n\nSelected voice: ' + this.voice.getVoiceInfo());
                        } catch (error) {
                            console.error('Voice re-initialization failed:', error);
                            alert('Voice re-initialization failed: ' + error.message);
                        }
                    });
                }

                document.addEventListener('keydown', (e) => {
                    if (e.code === 'Space' || e.code === 'Enter') {
                        const handler = window.__imagiActiveResponse;
                        if (typeof handler === 'function') {
                            e.preventDefault();
                            handler(e.code === 'Space' ? 'match' : 'nomatch');
                        }
                    }
                });

                const exportBtn = document.getElementById('export-btn');
                if (exportBtn) {
                    exportBtn.addEventListener('click', () => {
                        this.exportData();
                    });
                }

                const testBtn = document.getElementById('test-btn');
                if (testBtn) {
                    testBtn.addEventListener('click', async () => {
                        const panel = document.getElementById('test-panel');
                        const resultsEl = document.getElementById('test-results');
                        if (panel) panel.hidden = false;
                        if (resultsEl) {
                            resultsEl.innerHTML = '<p>Running tests...</p>';
                            const harness = new TestHarness();
                            const results = await harness.runAll();
                            resultsEl.innerHTML = results.map(result => {
                                const cls = result.passed ? 'pass' : 'fail';
                                const symbol = result.passed ? '‚úì' : '‚úó';
                                return `<div class="test-result ${cls}">${symbol} ${result.test}: ${result.details}</div>`;
                            }).join('');
                        }
                    });
                }
            }

            updateVoiceInfo() {
                const info = document.getElementById('voice-info');
                if (info) {
                    const voiceInfo = this.voice.getVoiceInfo();
                    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
                    const platform = isIOS ? 'iOS' : 'Desktop';

                    // Determine voice status with female voice awareness
                    let voiceStatus;
                    if (this.voice.voice) {
                        const voiceName = this.voice.voice.name;

                        // Check if it's a known female voice
                        const knownFemaleVoices = [
                            'Samantha', 'Karen', 'Moira', 'Tessa', 'Victoria', 'Fiona',
                            'Nicky', 'Serena', 'Susan', 'Zoe', 'Hazel', 'Zira'
                        ];
                        const isKnownFemale = knownFemaleVoices.some(name => voiceName.includes(name));

                        if (voiceName.includes('Samantha')) {
                            voiceStatus = '<span style="color: #2ecc71;">‚úì Samantha (Female)</span>';
                        } else if (isKnownFemale) {
                            voiceStatus = '<span style="color: #2ecc71;">‚úì Female Voice</span>';
                        } else {
                            voiceStatus = '<span style="color: #f39c12;">‚ö† Ambiguous Voice</span>';
                        }
                    } else {
                        voiceStatus = '<span style="color: #e74c3c;">‚úó No Voice</span>';
                    }

                    info.innerHTML = `<strong>Voice:</strong> ${voiceInfo} | <strong>Platform:</strong> ${platform} | ${voiceStatus}`;
                    console.log(`Voice info updated: ${voiceInfo} on ${platform}`);
                }
            }

            updateUI() {
                const trialCount = document.getElementById('trial-count');
                if (trialCount) {
                    trialCount.textContent = this.session.trialIndex;
                }
                const scoreEl = document.getElementById('score');
                if (scoreEl) {
                    scoreEl.textContent = this.score;
                }
                const omissionsEl = document.getElementById('omissions');
                if (omissionsEl) {
                    omissionsEl.textContent = this.omissions;
                }
                const accuracyEl = document.getElementById('accuracy');
                const accuracy = this.totalResponses > 0 ? (this.correctResponses / this.totalResponses) * 100 : null;
                if (accuracyEl) {
                    accuracyEl.textContent = accuracy !== null ? `${accuracy.toFixed(1)}%` : '-';
                }
                const rollingEl = document.getElementById('rolling-acc');
                const rolling = this.recentAccuracy.length > 0
                    ? (this.recentAccuracy.reduce((a, b) => a + b, 0) / this.recentAccuracy.length) * 100
                    : null;
                if (rollingEl) {
                    rollingEl.textContent = rolling !== null ? `${rolling.toFixed(1)}%` : '-';
                }

                const running = this.session.state === 'RUNNING';
                const statusText = running ? `Running (n=${this.n}, k=${this.k})` : this.statusMessage;
                const statusEl = document.getElementById('status');
                if (statusEl) {
                    statusEl.textContent = statusText;
                }

                const startBtn = document.getElementById('start-btn');
                if (startBtn) startBtn.disabled = running;
                const restartBtn = document.getElementById('restart-btn');
                if (restartBtn) restartBtn.disabled = !running;
                const stopBtn = document.getElementById('stop-btn');
                if (stopBtn) stopBtn.disabled = !running;
            }

            prepareSession(sess) {
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log('prepareSession() called');
                console.log('Current force flags at prepareSession start:', {
                    forceMetaLeap: this.forceMetaLeap,
                    forceCompoundLeap: this.forceCompoundLeap,
                    forceOctoLeap: this.forceOctoLeap,
                    forceHexaLeap: this.forceHexaLeap
                });
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                const totalPlanned = sess.numTrials;
                this.session = sessionDefaults();
                this.session.trialIndex = 0;
                this.session.numTrials = totalPlanned;
                this.session.state = 'RUNNING';
                this.policy = sess.policy;
                this.score = 0;
                this.correctResponses = 0;
                this.totalResponses = 0;
                this.omissions = 0;
                this.recentAccuracy = [];
                this.pendingPlannerFlip = false;
                this.awaitingResponse = false;
                this.lastSpokenFallback = false;

                const shouldResetLogs = !this.pendingRestart || this.resetOnRestart;
                this.pendingRestart = false;

                const seed = this.seedManager.generateSessionSeed(this.lockSeed);
                this.session.seedSession = seed;
                this.state = new GameState(seed, { windowSize: Math.max(2 * this.n + 2, 12) });
                this.state.resetNovelty();
                this.solver = new ConstraintSolver();
                this.generator = new PremiseGenerator(this.state, this.solver, this.equivalence);
                console.log('PremiseGenerator created');
                this.planner = new MatchPlanner(this.state.rng);
                this.generator.setPlanner(this.planner);
                this.matchSchedule = this.planner.plan(totalPlanned, this.n);
                console.log('prepareSession complete - generator ready');
                if (shouldResetLogs) {
                    this.logger.reset();
                }
                this.currentPremises = [];
                this.statusMessage = `Running (n=${this.n}, k=${this.k})`;
                this.sessionToken = makeEpoch();

                const premiseDisplay = document.getElementById('premise-display');
                if (premiseDisplay) {
                    premiseDisplay.textContent = '';
                }
                const feedbackEl = document.getElementById('feedback');
                if (feedbackEl) {
                    feedbackEl.textContent = '';
                    feedbackEl.className = 'feedback';
                }
                const repeatBtn = document.getElementById('repeat-btn');
                if (repeatBtn) repeatBtn.disabled = true;
                const matchBtn = document.getElementById('match-btn');
                if (matchBtn) matchBtn.disabled = true;
                const noMatchBtn = document.getElementById('no-match-btn');
                if (noMatchBtn) noMatchBtn.disabled = true;
                window.__imagiActiveResponse = null;
                window.forceCurrentTrialTimeout = null;
                window.currentPremiseText = '';

                this.updateUI();
            }

            async finalizeSession(sess, aborted) {
                // CRITICAL FIX: Add comprehensive logging to track why session is stopping
                const reason = aborted ? 'ABORTED' : 'COMPLETED';
                const trialProgress = `${sess?.trialIndex || 0}/${sess?.numTrials || 'unknown'}`;
                console.log(`finalizeSession called: ${reason}, trials: ${trialProgress}, epoch: ${sess?.epoch}`);

                // DEFENSIVE: Capture stack trace to see what triggered this finalization
                if (aborted && sess && sess.trialIndex < sess.numTrials) {
                    console.warn(`Session stopped prematurely at trial ${sess.trialIndex}/${sess.numTrials}. Stack trace:`);
                    console.trace();
                }

                this.awaitingResponse = false;
                this.session.state = 'STOPPED';
                this.statusMessage = aborted ? 'Stopped' : `Session complete. ${this.session.numTrials} trials finished.`;
                if (!aborted) {
                    this.renderSummary();
                }
                this.activePremise = null;
                this.updateUI();
            }

            planTrial(trialIndex) {
                const scheduledMatch = this.matchSchedule[trialIndex] || false;
                const nBackIndex = trialIndex - this.n;
                const nBackPremise = nBackIndex >= 0 ? this.currentPremises[nBackIndex] : null;
                const middleAtoms = nBackIndex >= 0 ? this.state.getConstraintsInRange(nBackIndex + 1, trialIndex - 1) : [];
                const cooldown = this.state.getActiveCooldown(trialIndex);
                const planMatch = scheduledMatch && Boolean(nBackPremise);
                const foilPlan = (!planMatch && nBackPremise) ? this.planner.maybePlanFoil() : null;
                return { trialIndex, scheduledMatch, nBackPremise, middleAtoms, cooldown, planMatch, foilPlan };
            }

            tryGenerate(plan, override = null) {
                const params = {
                    trialIndex: plan.trialIndex,
                    k: this.k,
                    n: this.n,
                    plannedMatch: override !== null ? override : plan.planMatch,
                    nBackPremise: plan.nBackPremise,
                    middleAtoms: plan.middleAtoms,
                    avoidLetters: (override !== null ? override : plan.planMatch) ? plan.cooldown : null,
                    allowOverride: true,
                    foilPlan: plan.foilPlan,
                    forceMetaLeap: this.forceMetaLeap,
                    forceCompoundLeap: this.forceCompoundLeap,
                    forceOctoLeap: this.forceOctoLeap,
                    forceHexaLeap: this.forceHexaLeap
                };
                console.log('GameEngine.tryGenerate() passing to generator:', {
                    forceMetaLeap: params.forceMetaLeap,
                    forceCompoundLeap: params.forceCompoundLeap,
                    forceOctoLeap: params.forceOctoLeap,
                    forceHexaLeap: params.forceHexaLeap
                });
                return this.generator.generate(params);
            }

            async generatePremiseGuaranteed(plan) {
                for (let attempt = 0; attempt < 30; attempt++) {
                    const result = this.tryGenerate(plan, null);
                    if (result) {
                        return { ...result, planMatch: plan.planMatch };
                    }
                    if (plan.scheduledMatch && attempt === 0) {
                        this.planner.forceFlip(plan.trialIndex);
                        this.pendingPlannerFlip = true;
                        const flipped = this.tryGenerate(plan, false);
                        if (flipped) {
                            return { ...flipped, planMatch: false };
                        }
                    }
                }

                if (!plan._flipped && plan.nBackPremise) {
                    const flippedPlan = { ...plan, planMatch: !plan.planMatch, scheduledMatch: false, _flipped: true };
                    for (let attempt = 0; attempt < 30; attempt++) {
                        const result = this.tryGenerate(flippedPlan, flippedPlan.planMatch);
                        if (result) {
                            return { ...result, planMatch: flippedPlan.planMatch };
                        }
                    }
                }

                return this.buildNeutralNonMatch(plan);
            }

            buildNeutralNonMatch(plan) {
                const letters = this.state?.letters || 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
                const head = this.state?.rng ? this.state.rng.choice(letters) : letters[0];
                const tails = letters.filter(letter => letter !== head);
                const tail = (this.state?.rng ? this.state.rng.choice(tails.length ? tails : letters) : (tails[0] || letters[1] || head));
                const axis = this.state?.rng ? this.state.rng.choice(MATCH_AXES) : 'N';
                const safeTail = tail === head ? letters[(letters.indexOf(head) + 1) % letters.length] : tail;
                const premise = new Premise([new Atom(axis, head, safeTail)]);
                const signatures = this.state ? this.state.novelty.buildSignatures(premise) : { exact: premise.toKey() };
                const windowAtoms = this.state ? this.state.getWindowAtoms() : [];
                const satResult = this.solver ? this.solver.evaluate(windowAtoms, premise.atoms) : { ok: true, coordinates: new Map() };
                return {
                    premise,
                    signatures,
                    novelty: { noveltyScores: {}, blocked: false },
                    satResult,
                    certificate: null,
                    modeUsed: 'fallback',
                    features: premise.getFeatures(),
                    foilType: null,
                    planMatch: false
                };
            }


            async executeTrial(sess, trialToken, signal) {
                // CRITICAL FIX: Enhanced validation with detailed logging
                if (!valid(sess, trialToken)) {
                    console.warn(`executeTrial: invalid at start, trial ${sess.trialIndex}, reason: ${!session ? 'no global session' : session.epoch !== sess.epoch ? 'epoch mismatch' : trialToken !== session.trialToken ? 'token mismatch' : signal.aborted ? 'signal aborted' : 'unknown'}`);
                    return;
                }
                resetSpeechGateForTrial();
                const currentIndex = sess.trialIndex;
                this.session.trialIndex = currentIndex;
                this.updateUI();

                let plan = this.planTrial(currentIndex);
                let result = await this.generatePremiseGuaranteed(plan);
                if (!result) {
                    console.warn('Premise generation returned null; using neutral fallback.');
                    result = this.buildNeutralNonMatch(plan);
                }

                const { premise, signatures, novelty, satResult, certificate, modeUsed, features, foilType, planMatch } = result;
                this.activePremise = premise;
                const planType = planMatch ? 'match' : (foilType ? `foil:${foilType}` : 'nonmatch');
                const featureSnapshot = features || premise.getFeatures();

                this.currentPremises.push(premise);
                this.state.recordPremise(premise, premise.atoms, { plannedMatch: planMatch, certificate, modeUsed, foilType });
                this.state.novelty.register(signatures);
                this.state.coordinates = satResult.coordinates;

                sess.phaseToken = (sess.phaseToken || 0) + 1;
                const premiseDisplay = document.getElementById('premise-display');
                if (premiseDisplay) {
                    premiseDisplay.textContent = premise.toString();
                }
                window.currentPremiseText = formatPremiseForSpeech(premise);
                const matchBtn = document.getElementById('match-btn');
                const noMatchBtn = document.getElementById('no-match-btn');
                const repeatBtn = document.getElementById('repeat-btn');
                if (matchBtn) matchBtn.disabled = true;
                if (noMatchBtn) noMatchBtn.disabled = true;
                if (repeatBtn) repeatBtn.disabled = false;

                const speechMeta = await speakPremiseSafe(sess, premise, trialToken, signal);
                this.lastSpokenFallback = Boolean(speechMeta?.fallback);
                if (!valid(sess, trialToken)) {
                    console.warn(`executeTrial: invalid after speech, trial ${currentIndex}`);
                    return;
                }

                if (sess.policy === AdvancePolicy.LISTEN) {
                    await dwellSafe(this.secondsPerTrial, trialToken, signal);
                    if (!valid(sess, trialToken)) {
                        console.warn(`executeTrial: invalid after dwell, trial ${currentIndex}`);
                        return;
                    }
                    this.logTrial({
                        planMatch,
                        planType,
                        certificate,
                        featureSnapshot,
                        premise,
                        novelty,
                        satResult,
                        foilType,
                        responsePayload: { choice: null, correct: null, rt: null, omission: false, timeout: false },
                        modeUsed,
                        trialIndex: currentIndex,
                        passiveAdvance: true,
                        trialTokenAtStart: trialToken,
                        listenOnly: true
                    });
                    if (repeatBtn) repeatBtn.disabled = true;
                    const feedbackEl = document.getElementById('feedback');
                    if (feedbackEl) {
                        feedbackEl.textContent = 'Listening‚Ä¶';
                        feedbackEl.className = 'feedback';
                    }
                    this.updateUI();
                    this.activePremise = null;
                    return;
                }

                this.awaitingResponse = true;
                this.responseStartTime = Date.now();
                if (matchBtn) matchBtn.disabled = false;
                if (noMatchBtn) noMatchBtn.disabled = false;

                const response = await collectResponseSafe(this.secondsPerTrial, trialToken, signal);
                this.awaitingResponse = false;
                if (!valid(sess, trialToken)) {
                    console.warn(`executeTrial: invalid after collectResponse, trial ${currentIndex}`);
                    return;
                }

                if (matchBtn) matchBtn.disabled = true;
                if (noMatchBtn) noMatchBtn.disabled = true;
                if (repeatBtn) repeatBtn.disabled = true;

                const responseChoice = response?.type === 'answer' ? response.choice : null;
                const timeout = response?.type === 'timeout';
                const omission = timeout || responseChoice === null;
                const actualMatch = (modeUsed === 'META' || modeUsed === 'COMPOUND_OPERATOR' || modeUsed === 'OCTO_OPERATOR' || modeUsed === 'HEXA_OPERATOR')
                    ? planMatch  // For operator modes, use planMatch directly
                    : Boolean(planMatch && certificate);  // For atomic modes, use equivalence engine
                let correct = null;
                if (!timeout && responseChoice !== null) {
                    correct = (responseChoice === 'match') === actualMatch;
                }

                if (timeout) {
                    this.omissions += 1;
                } else if (correct !== null) {
                    this.totalResponses += 1;
                    if (correct) {
                        this.score += 1;
                        this.correctResponses += 1;
                    }
                    this.recentAccuracy.push(correct ? 1 : 0);
                    if (this.recentAccuracy.length > this.M) {
                        this.recentAccuracy.shift();
                    }
                }

                const rt = (!timeout && responseChoice !== null) ? Date.now() - this.responseStartTime : null;
                const feedbackEl = document.getElementById('feedback');
                if (feedbackEl) {
                    if (timeout) {
                        feedbackEl.textContent = 'Response window expired.';
                        feedbackEl.className = 'feedback incorrect';
                    } else if (correct) {
                        feedbackEl.textContent = 'Correct';
                        feedbackEl.className = 'feedback correct';
                    } else if (correct === false) {
                        feedbackEl.textContent = 'Incorrect';
                        feedbackEl.className = 'feedback incorrect';
                    } else {
                        feedbackEl.textContent = '';
                        feedbackEl.className = 'feedback';
                    }
                }

                if (actualMatch && certificate) {
                    this.state.applyCooldown(Array.from(premise.getLetters()), currentIndex, this.n);
                }

                this.logTrial({
                    planMatch,
                    planType,
                    certificate,
                    featureSnapshot,
                    premise,
                    novelty,
                    satResult,
                    foilType,
                    responsePayload: {
                        choice: responseChoice,
                        correct,
                        rt,
                        omission,
                        timeout
                    },
                    modeUsed,
                    trialIndex: currentIndex,
                    passiveAdvance: false,
                    trialTokenAtStart: trialToken,
                    listenOnly: false
                });

                this.activePremise = null;
                this.updateUI();
            }

            logTrial({ planMatch, planType, certificate, featureSnapshot, premise, novelty, satResult, foilType, responsePayload, modeUsed, trialIndex, passiveAdvance, trialTokenAtStart, listenOnly }) {
                const { choice, correct, rt, omission, timeout } = responsePayload;
                const featureLog = {
                    lettersSet: Array.from(featureSnapshot.lettersSet).sort(),
                    degreeVector: {},
                    skeletonIsoSignature: featureSnapshot.skeletonIsoSignature,
                    atomAxisProfile: {}
                };
                featureSnapshot.degreeVector.forEach((vec, letter) => {
                    featureLog.degreeVector[letter] = [...vec];
                });
                featureSnapshot.atomAxisProfile.forEach((count, axis) => {
                    featureLog.atomAxisProfile[axis] = count;
                });

                const plannerFlip = this.pendingPlannerFlip || (this.planner && typeof this.planner.wasFlipped === 'function' ? this.planner.wasFlipped(trialIndex) : false);
                this.pendingPlannerFlip = false;

                const logEntry = {
                    seedSession: this.seedManager.sessionSeed,
                    trialIndex,
                    trialNumber: trialIndex + 1,
                    numTrials: this.session.numTrials,
                    n: this.n,
                    k: this.k,
                    letters: Array.from(premise.getLetters()).join(''),
                    atomsCanonical: premise.toKey(),
                    atomsMirrorCanonical: premise.mirrorKey(),
                    isoSignature: premise.isoSignature(),
                    plannedMatch: planMatch,
                    planType,
                    foilType: foilType || null,
                    certificate: certificate || null,
                    satStatus: satResult.ok,
                    midWindowDerivable: certificate ? certificate.midWindowDerivable : false,
                    noveltyScores: novelty?.noveltyScores || {},
                    response: { choice, correct, rtMs: rt, omission, timeout },
                    cooldownLetters: Array.from(this.state.getActiveCooldown(trialIndex + 1)),
                    plannerFlip,
                    modeUsed,
                    mode: listenOnly ? AdvancePolicy.LISTEN : AdvancePolicy.ACTIVE,
                    passiveAdvance,
                    ttsFallback: Boolean(this.lastSpokenFallback),
                    trialTokenAtStart,
                    features: featureLog
                };

                this.logger.add(logEntry);
                this.updateDebugPanel(logEntry);
            }

            updateDebugPanel(entry) {
                const debug = document.getElementById('debug-content');
                if (!debug) return;
                const el = document.createElement('div');
                el.className = 'debug-premise';
                el.textContent = `Trial ${entry.trialIndex}: ${entry.atomsCanonical} | Plan=${entry.planType} | Response=${entry.response.choice}`;
                debug.prepend(el);
                while (debug.childElementCount > 20) {
                    debug.removeChild(debug.lastChild);
                }
            }

            exportData() {
                const data = {
                    seedSession: this.seedManager.sessionSeed,
                    entries: this.logger.getEntriesSnapshot()
                };
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `imagi-world-session-${Date.now()}.json`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
            }
        }

        const DEBOUNCE_MS = 250;
        let lastBtn = 0;

        function debounce() {
            const now = performance.now();
            if (now - lastBtn < DEBOUNCE_MS) return false;
            lastBtn = now;
            return true;
        }

        function cancelSpeechImmediately() {
            try {
                window.speechSynthesis?.cancel();
            } catch (err) {
                console.warn('speechSynthesis.cancel immediate failed', err);
            }
        }

        function clearAllEngineTimers() {
            Timer.cancelAll();
            clearHeartbeat();
        }

        function stopSession() {
            if (!session) {
                console.log('stopSession called, but no active session');
                return;
            }

            // CRITICAL FIX: Add logging to track when and why stopSession is called
            console.log(`stopSession called: trial ${session.trialIndex}/${session.numTrials}, epoch ${session.epoch}`);
            console.trace('stopSession stack trace:');

            try {
                session.abort.abort();
            } catch (err) {
                console.warn('abort stop failed', err);
            }
            clearAllEngineTimers();
            cancelSpeechImmediately();
            SpeechGate.inFlight = false;
            SpeechGate.flightToken = null;
            engine.finalizeSession(session, true);
            window.__imagiActiveResponse = null;
            window.forceCurrentTrialTimeout = null;
            session = null;
        }

        async function runLoop(sess) {
            const signal = sess.abort.signal;
            console.log(`runLoop started: epoch ${sess.epoch}, numTrials ${sess.numTrials}`);

            // CRITICAL FIX: Wrap each trial in try-catch to prevent single trial errors from stopping entire session
            while (!signal.aborted && sess.trialIndex < sess.numTrials) {
                sess.trialToken += 1;
                sess.phaseToken = 0;

                try {
                    await engine.executeTrial(sess, sess.trialToken, signal);
                } catch (err) {
                    console.error(`runLoop: Error in executeTrial at trial ${sess.trialIndex}:`, err);
                    // DEFENSIVE: Log error but continue with next trial instead of stopping entire session
                    // This prevents transient errors (speech synthesis failures, DOM timing issues) from killing the session
                    console.warn(`Continuing to next trial despite error in trial ${sess.trialIndex}`);
                }

                if (signal.aborted) {
                    console.warn(`runLoop: aborted at trial ${sess.trialIndex}`);
                    break;
                }
                sess.trialIndex += 1;
            }

            if (!signal.aborted) {
                console.log(`runLoop: completed ${sess.trialIndex}/${sess.numTrials} trials normally`);
                await engine.finalizeSession(sess, false);
                clearAllEngineTimers();
                session = null;
            } else {
                console.warn(`runLoop: session aborted, completed ${sess.trialIndex}/${sess.numTrials} trials`);
                // Note: Don't call finalizeSession here - stopSession() already does it
            }
        }

        function startSession() {
            if (!debounce()) return;

            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            console.log('START BUTTON CLICKED - startSession() called');
            console.log('engine.forceMetaLeap at START:', engine.forceMetaLeap);
            console.log('engine.forceCompoundLeap at START:', engine.forceCompoundLeap);
            console.log('engine.forceOctoLeap at START:', engine.forceOctoLeap);
            console.log('engine.forceHexaLeap at START:', engine.forceHexaLeap);
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

            // CRITICAL FIX: Clean up old session first, then create new one atomically
            // This prevents race conditions between stopSession() and session creation
            stopSession();

            // Create new session and prepare engine BEFORE starting runLoop
            const newSess = newSession(engine);
            session = newSess;  // Set global session immediately to prevent epoch mismatches

            engine.prepareSession(newSess);
            wireHeartbeat(newSess);

            // CRITICAL FIX: Add better error handling that doesn't stop on transient errors
            runLoop(newSess).catch((err) => {
                console.error('runLoop encountered error:', err);
                // Only stop if session is still the one that errored (not already replaced)
                if (session && session.epoch === newSess.epoch) {
                    console.error('Stopping session due to unrecoverable error in runLoop');
                    stopSession();
                } else {
                    console.warn('runLoop error for stale session, ignoring');
                }
            });
        }

        function restartSession() {
            if (!debounce()) return;
            stopSession();
            startSession();
        }

        function formatPremiseForSpeech(premise) {
            if (!premise) return '';

            // Use premise's toNaturalSpeech() method which handles all types
            return premise.toNaturalSpeech();
        }

        function estimateUtteranceMs(text, rate = 0.9) {
            const cps = 12 * rate;
            return Math.max(900, Math.min(9000, Math.round((text.length / cps) * 1000) + 300));
        }

        async function speakPremiseSafe(sess, premise, trialToken, signal) {
            if (!valid(sess, trialToken)) {
                return { fallback: false, attempts: 0 };
            }

            return new Promise((resolve) => {
                const mySpeakId = SpeechGate.trialSpeakId;
                const myRepeatPhase = SpeechGate.explicitRepeatPhase;

                if (SpeechGate.inFlight) {
                    resolve({ fallback: false, attempts: 0 });
                    return;
                }

                const flightToken = Symbol('speech-flight');
                SpeechGate.inFlight = true;
                SpeechGate.flightToken = flightToken;

                try {
                    window.speechSynthesis?.cancel();
                } catch (err) {
                    console.warn('speechSynthesis.cancel before speak failed', err);
                }
                try {
                    window.speechSynthesis?.resume();
                } catch (err) {
                    console.warn('speechSynthesis.resume after cancel failed', err);
                }

                const text = formatPremiseForSpeech(premise);
                window.currentPremiseText = text;
                const utterance = new SpeechSynthesisUtterance(text);

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // iOS CRITICAL FIX: Use VoiceSynthesis class's selected voice
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // PROBLEM: Previous code used voices[0] which on iPhone = Reed (male)
                // SOLUTION: Use engine.voice.getFreshVoiceObject() for properly selected female voice
                // This matches the Voice Preview button behavior which works perfectly on iPhone

                const freshVoice = engine?.voice?.getFreshVoiceObject();
                if (freshVoice) {
                    utterance.voice = freshVoice;
                    utterance.lang = freshVoice.lang;
                    console.log(`‚úì speakPremiseSafe using selected voice: ${freshVoice.name} (${freshVoice.lang})`);
                } else {
                    console.error('‚úó speakPremiseSafe: getFreshVoiceObject() returned null - attempting fallback');
                    // Fallback: Try to get voices array directly (should not happen if voice initialized)
                    const voices = window.speechSynthesis.getVoices();
                    if (voices.length > 0) {
                        // Last resort: use voices[0] (will be male on iPhone, but better than silence)
                        utterance.voice = voices[0];
                        utterance.lang = voices[0].lang;
                        console.warn(`‚ö† Using fallback voice: ${voices[0].name} (may be male on iPhone)`);
                    }
                }

                const pitch = engine?.voice?.pitch ?? 1.2;
                const rate = engine?.voice?.rate ?? 0.9;
                const volume = engine?.voice?.volume ?? 1.0;
                utterance.pitch = pitch;
                utterance.rate = rate;
                utterance.volume = volume;

                instrumentUtterance(utterance);

                let settled = false;

                const finish = (fallback) => {
                    if (settled) return;
                    settled = true;
                    if (SpeechGate.flightToken === flightToken) {
                        SpeechGate.inFlight = false;
                        SpeechGate.flightToken = null;
                    }
                    clearTimeout(fallbackTimer);
                    signal.removeEventListener('abort', onAbort);
                    resolve({ fallback, attempts: 1 });
                };

                const onAbort = () => finish(false);
                signal.addEventListener('abort', onAbort, { once: true });

                const fallbackTimer = setTimeout(() => {
                    if (SpeechGate.trialSpeakId !== mySpeakId) {
                        finish(true);
                        return;
                    }
                    if (SpeechGate.explicitRepeatPhase !== myRepeatPhase) {
                        finish(false);
                        return;
                    }
                    finish(true);
                }, estimateUtteranceMs(text, rate) + 400);

                utterance.onend = () => finish(false);
                utterance.onerror = () => finish(true);

                setTimeout(() => {
                    if (settled) return;
                    if (signal.aborted) {
                        finish(true);
                        return;
                    }
                    if (SpeechGate.trialSpeakId !== mySpeakId) {
                        finish(true);
                        return;
                    }
                    if (SpeechGate.explicitRepeatPhase !== myRepeatPhase) {
                        finish(false);
                        return;
                    }
                    try {
                        window.speechSynthesis?.resume();
                    } catch (err) {
                        console.warn('speechSynthesis.resume failed', err);
                    }
                    try {
                        window.speechSynthesis?.speak(utterance);
                    } catch (err) {
                        console.warn('speechSynthesis.speak failed', err);
                        finish(true);
                    }
                }, 100);
            });
        }

        function secondsPerTrial() {
            return engine.secondsPerTrial;
        }

        async function dwellSafe(seconds, trialToken, signal) {
            return new Promise((resolve) => {
                let resolved = false;
                const safeResolve = () => {
                    if (!resolved) {
                        resolved = true;
                        resolve();
                    }
                };
                Timer.set('dwell', Math.max(0, Math.round(seconds * 1000)), trialToken, signal, safeResolve);
                // Ensure promise resolves if signal aborts
                signal.addEventListener('abort', safeResolve, { once: true });
            });
        }

        function bindTrialButtons(onMatch, onNo) {
            const matchBtn = document.getElementById('match-btn');
            const noMatchBtn = document.getElementById('no-match-btn');
            matchBtn?.addEventListener('click', onMatch, { once: true });
            noMatchBtn?.addEventListener('click', onNo, { once: true });
        }

        function unbindTrialButtons(onMatch, onNo) {
            const matchBtn = document.getElementById('match-btn');
            const noMatchBtn = document.getElementById('no-match-btn');
            matchBtn?.removeEventListener('click', onMatch);
            noMatchBtn?.removeEventListener('click', onNo);
        }

        async function collectResponseSafe(seconds, trialToken, signal) {
            return new Promise((resolve) => {
                let settled = false;
                const settle = (payload) => {
                    if (settled) {
                        console.warn(`collectResponseSafe: settle() called multiple times for trial token ${trialToken} - IGNORING duplicate call. Payload:`, payload);
                        console.trace('Duplicate settle() call stack trace:');
                        return;
                    }
                    settled = true;
                    cleanup();
                    resolve(payload);
                };

                const onMatch = () => settle({ type: 'answer', choice: 'match' });
                const onNo = () => settle({ type: 'answer', choice: 'nomatch' });
                bindTrialButtons(onMatch, onNo);
                window.__imagiActiveResponse = (choice) => {
                    if (choice === 'match') {
                        onMatch();
                    } else {
                        onNo();
                    }
                };

                const timerId = Timer.set('resp', Math.max(0, Math.round(seconds * 1000)), trialToken, signal, () => settle({ type: 'timeout' }));

                const cleanup = () => {
                    unbindTrialButtons(onMatch, onNo);
                    Timer.clear(timerId);
                    window.__imagiActiveResponse = null;
                    // CRITICAL FIX: Clear forceCurrentTrialTimeout to prevent watchdog from calling stale timeout function
                    // BUG: If watchdog calls forceCurrentTrialTimeout after this trial ends but before next trial starts,
                    // it would call the OLD settle() function, causing undefined behavior and potential session stops
                    window.forceCurrentTrialTimeout = null;
                };

                signal.addEventListener('abort', () => settle({ type: 'timeout' }), { once: true });

                // CRITICAL FIX: Create timeout function with staleness check
                // This prevents watchdog from triggering stale settle() calls that could crash the session
                const timeoutToken = Symbol('timeout-token');
                window.forceCurrentTrialTimeout = () => {
                    // Only settle if this is still the active timeout function (not stale)
                    if (window.forceCurrentTrialTimeout?.timeoutToken === timeoutToken) {
                        console.log(`forceCurrentTrialTimeout called for trial token ${trialToken} - settling as timeout`);
                        settle({ type: 'timeout' });
                    } else {
                        console.warn(`forceCurrentTrialTimeout called but token is stale (expected ${timeoutToken.toString()}, current ${window.forceCurrentTrialTimeout?.timeoutToken?.toString()}) - IGNORING to prevent race condition`);
                    }
                };
                window.forceCurrentTrialTimeout.timeoutToken = timeoutToken;
            });
        }

        function wireHeartbeat(sess) {
            clearHeartbeat();
            let lastTick = performance.now();
            let lastTrial = -1;
            let nudgeCount = 0;  // Track consecutive nudges to prevent over-aggressive watchdog

            heartbeat = setInterval(() => {
                // CRITICAL FIX: More defensive session checks to prevent race conditions
                if (!session || !sess) {
                    clearHeartbeat();
                    return;
                }
                if (session.epoch !== sess.epoch) {
                    // Session has been replaced, this watchdog is stale
                    clearHeartbeat();
                    return;
                }
                if (sess.abort.signal.aborted) {
                    clearHeartbeat();
                    return;
                }

                const now = performance.now();

                // Reset nudge count when trial advances successfully
                if (sess.trialIndex !== lastTrial) {
                    lastTrial = sess.trialIndex;
                    lastTick = now;
                    nudgeCount = 0;  // Reset nudge counter on progress
                    return;
                }

                // CRITICAL FIX: More generous timeout calculation to reduce false positives
                // Add extra buffer for browser variability, tab switching, etc.
                const typical = estimateUtteranceMs(window.currentPremiseText || 'H is east of R; Y is north of X.', 0.90) + (secondsPerTrial() * 1000) + 3000;  // Increased from 1500ms to 3000ms buffer
                const elapsed = now - lastTick;

                if (elapsed > typical) {
                    nudgeCount++;
                    console.warn(`Watchdog nudge #${nudgeCount} (elapsed: ${Math.round(elapsed)}ms, typical: ${Math.round(typical)}ms)`);

                    // CRITICAL FIX: Only nudge if we haven't exceeded reasonable retry limit
                    // This prevents infinite nudge loops from stopping the session
                    if (nudgeCount <= 3) {  // Allow up to 3 nudges before giving up on this trial
                        cancelSpeechImmediately();
                        if (session?.policy === AdvancePolicy.ACTIVE) {
                            // CRITICAL FIX: Only call forceCurrentTrialTimeout if it exists and trial tokens match
                            // This prevents calling stale timeout functions that could cause session stops
                            if (typeof window.forceCurrentTrialTimeout === 'function') {
                                console.log(`Watchdog nudge #${nudgeCount}: Calling forceCurrentTrialTimeout for trial ${sess.trialIndex}`);
                                window.forceCurrentTrialTimeout();
                            } else {
                                console.warn(`Watchdog nudge #${nudgeCount}: No active forceCurrentTrialTimeout function (trial might be between states)`);
                            }
                        } else {
                            Timer.set('dwell-nudge', 50, session.trialToken, session.abort.signal, () => {});
                        }
                    } else {
                        console.error(`Watchdog: Trial ${sess.trialIndex} appears stuck after ${nudgeCount} nudges, but continuing session`);
                        // Don't abort the session - just reset the tick and hope next trial works
                        // This is better than stopping the entire session randomly
                    }

                    lastTick = now;  // Reset tick regardless of nudge count
                }
            }, 500);
        }

        function onRepeatPressed() {
            if (!session) return;
            const premise = engine.activePremise || engine.currentPremises[Math.max(0, session.trialIndex - 1)];
            if (!premise) return;
            noteExplicitRepeat();
            cancelSpeechImmediately();
            setTimeout(() => {
                if (!session || session.abort.signal.aborted) return;
                SpeechGate.inFlight = false;
                SpeechGate.flightToken = null;
                speakPremiseSafe(session, premise, session.trialToken, session.abort.signal);
            }, 120);
        }

        function shouldAutoStopForOmissions() {
            return session?.policy === AdvancePolicy.ACTIVE;
        }

        document.addEventListener('visibilitychange', () => {
            try {
                window.speechSynthesis?.resume();
            } catch (err) {
                console.warn('speechSynthesis.resume visibility failed', err);
            }
        });

        class InstructionsManager {
            constructor(engine) {
                this.engine = engine;
                this.voice = engine.voice;
                this.sections = TUTORIAL_SECTIONS;
                this.dialog = document.getElementById('dlgInstructions');
                this.openButton = document.getElementById('btnInstructions');
                this.closeButton = document.getElementById('instClose');
                this.nav = document.getElementById('instTabs');
                this.tabButtons = Array.from(this.nav.querySelectorAll('button'));
                this.content = document.getElementById('instContent');
                this.prevButton = document.getElementById('instPrev');
                this.nextButton = document.getElementById('instNext');
                this.readAloudCheckbox = document.getElementById('instReadAloud');
                this.currentIndex = 0;
                this.dialogOpen = false;
                this.previousFocus = null;
                this.visited = new Set();
                this.completed = false;
                this.readAloud = false;
                this.pendingSpeechToken = null;
                this.boundKeydown = (event) => this.handleKeydown(event);
                this.boundFocusIn = (event) => this.enforceFocus(event);
                this.nav.setAttribute('role', 'tablist');
                this.tabButtons.forEach(btn => {
                    btn.setAttribute('role', 'tab');
                    const isActive = this.sections[this.currentIndex] && this.sections[this.currentIndex].id === btn.dataset.tab;
                    btn.setAttribute('aria-selected', isActive ? 'true' : 'false');
                    btn.setAttribute('tabindex', isActive ? '0' : '-1');
                });
                this.sandbox = {
                    premise: null,
                    mapping: {},
                    journal: []
                };
                this.sandboxElements = null;
            }

            initialize() {
                this.loadState();
                this.attachEvents();
                this.renderCurrentSection();
                this.updateCompletionState();
            }

            loadState() {
                const storedSection = localStorage.getItem('instSection');
                const storedIndex = this.sections.findIndex(section => section.id === storedSection);
                if (storedIndex >= 0) {
                    this.currentIndex = storedIndex;
                }

                const visitedRaw = localStorage.getItem('instVisited');
                if (visitedRaw) {
                    try {
                        const parsed = JSON.parse(visitedRaw);
                        if (Array.isArray(parsed)) {
                            parsed.forEach(id => this.visited.add(id));
                        }
                    } catch (err) {
                        console.warn('Failed to parse tutorial visited state', err);
                    }
                }

                const completed = localStorage.getItem('instCompleted');
                this.completed = completed === 'true';

                const readAloud = localStorage.getItem('instReadAloud');
                this.readAloud = readAloud === 'true';
                this.readAloudCheckbox.checked = this.readAloud;

                const journalRaw = localStorage.getItem('instPracticeJournal');
                if (journalRaw) {
                    try {
                        const parsed = JSON.parse(journalRaw);
                        if (Array.isArray(parsed)) {
                            this.sandbox.journal = parsed;
                        }
                    } catch (err) {
                        console.warn('Failed to parse sandbox journal', err);
                    }
                }
            }

            attachEvents() {
                this.openButton.addEventListener('click', () => this.openDialog());

                // Level 8 Instructions button - opens dialog directly to Level 8 Instructions tab
                const level8Button = document.getElementById('btnLevel8Instructions');
                if (level8Button) {
                    level8Button.addEventListener('click', () => {
                        this.openDialog();
                        // Find the Level 8 Instructions tab index
                        const level8Index = this.sections.findIndex(section => section.id === 'level8-instructions');
                        if (level8Index !== -1) {
                            this.navigateTo(level8Index);
                        }
                    });
                }

                const level9Button = document.getElementById('btnLevel9Instructions');
                if (level9Button) {
                    level9Button.addEventListener('click', () => {
                        this.openDialog();
                        // Find the Level 9 Instructions tab index
                        const level9Index = this.sections.findIndex(section => section.id === 'level9-instructions');
                        if (level9Index !== -1) {
                            this.navigateTo(level9Index);
                        }
                    });
                }

                // Da Vinci Instructions button - opens dialog directly to Da Vinci tutorial tab
                const daVinciButton = document.getElementById('btnDaVinciInstructions');
                if (daVinciButton) {
                    daVinciButton.addEventListener('click', () => {
                        this.openDialog();
                        // Find the Da Vinci tab index
                        const daVinciIndex = this.sections.findIndex(section => section.id === 'davinci-method');
                        if (daVinciIndex !== -1) {
                            this.navigateTo(daVinciIndex);
                        }
                    });
                }

                this.closeButton.addEventListener('click', () => this.closeDialog());

                this.tabButtons.forEach((button) => {
                    const sectionId = button.dataset.tab;
                    const index = this.sections.findIndex(section => section.id === sectionId);
                    if (index === -1) return;
                    button.addEventListener('click', () => {
                        this.currentIndex = index;
                        this.renderCurrentSection();
                        if (this.dialogOpen && this.readAloud) {
                            this.queueSpeech();
                        }
                    });
                });

                this.prevButton.addEventListener('click', () => {
                    if (this.currentIndex > 0) {
                        this.currentIndex -= 1;
                        this.renderCurrentSection();
                        if (this.dialogOpen && this.readAloud) {
                            this.queueSpeech();
                        }
                    }
                });

                this.nextButton.addEventListener('click', () => {
                    if (this.currentIndex < this.sections.length - 1) {
                        this.currentIndex += 1;
                        this.renderCurrentSection();
                        if (this.dialogOpen && this.readAloud) {
                            this.queueSpeech();
                        }
                    }
                });

                this.readAloudCheckbox.addEventListener('change', (event) => {
                    this.readAloud = event.target.checked;
                    localStorage.setItem('instReadAloud', this.readAloud ? 'true' : 'false');
                    if (this.dialogOpen && this.readAloud) {
                        this.queueSpeech(true);
                    } else {
                        this.cancelSpeech();
                    }
                });
            }

            openDialog() {
                if (this.dialogOpen) return;
                this.dialogOpen = true;
                this.previousFocus = document.activeElement;
                this.dialog.hidden = false;
                document.body.classList.add('dialog-open');
                this.content.scrollTop = 0;
                this.markVisited(this.sections[this.currentIndex].id);
                this.focusInitialElement();
                document.addEventListener('keydown', this.boundKeydown, true);
                document.addEventListener('focusin', this.boundFocusIn, true);
                if (this.readAloud) {
                    this.queueSpeech(true);
                }
            }

            closeDialog() {
                if (!this.dialogOpen) return;
                this.dialogOpen = false;
                this.dialog.hidden = true;
                document.body.classList.remove('dialog-open');
                document.removeEventListener('keydown', this.boundKeydown, true);
                document.removeEventListener('focusin', this.boundFocusIn, true);
                this.cancelSpeech();
                if (this.previousFocus && typeof this.previousFocus.focus === 'function') {
                    this.previousFocus.focus();
                } else {
                    this.openButton.focus();
                }
            }

            handleKeydown(event) {
                if (!this.dialogOpen) return;
                if (event.key === 'Escape') {
                    event.preventDefault();
                    this.closeDialog();
                    return;
                }
                if (event.key === 'Tab') {
                    this.trapFocus(event);
                }
            }

            enforceFocus(event) {
                if (!this.dialogOpen) return;
                if (!this.dialog.contains(event.target)) {
                    const focusable = this.getFocusableElements();
                    if (focusable.length > 0) {
                        focusable[0].focus();
                    } else {
                        this.content.focus();
                    }
                }
            }

            trapFocus(event) {
                const focusable = this.getFocusableElements();
                if (focusable.length === 0) {
                    event.preventDefault();
                    this.content.focus();
                    return;
                }
                const first = focusable[0];
                const last = focusable[focusable.length - 1];
                const active = document.activeElement;

                if (event.shiftKey) {
                    if (active === first || !this.dialog.contains(active)) {
                        event.preventDefault();
                        last.focus();
                    }
                } else {
                    if (active === last) {
                        event.preventDefault();
                        first.focus();
                    }
                }
            }

            getFocusableElements() {
                const selectors = ['button', '[href]', 'input', 'select', 'textarea', '[tabindex]:not([tabindex="-1"])'];
                return Array.from(this.dialog.querySelectorAll(selectors.join(',')))
                    .filter(el => !el.hasAttribute('disabled') && el.tabIndex !== -1 && this.dialog.contains(el));
            }

            focusInitialElement() {
                const focusable = this.getFocusableElements();
                if (focusable.length > 0) {
                    focusable[0].focus();
                } else {
                    this.content.focus();
                }
            }

            renderCurrentSection() {
                const section = this.sections[this.currentIndex];
                if (!section) return;
                this.tabButtons.forEach((button) => {
                    const isActive = button.dataset.tab === section.id;
                    button.classList.toggle('active', isActive);
                    if (this.visited.has(button.dataset.tab)) {
                        button.classList.add('visited');
                    }
                    button.setAttribute('aria-selected', isActive ? 'true' : 'false');
                    button.setAttribute('tabindex', isActive ? '0' : '-1');
                });
                if (typeof section.render === 'function') {
                    this.content.innerHTML = '';
                    section.render(this.content);
                } else {
                    this.content.innerHTML = section.html;
                    if (section.id === 'examples') {
                        renderGuidedExamples();
                    }
                }
                this.content.scrollTop = 0;
                localStorage.setItem('instSection', section.id);
                this.markVisited(section.id);
                this.updateNavButtons();
                if (section.id === 'practice') {
                    this.setupSandboxUI();
                } else {
                    this.sandboxElements = null;
                }
                if (this.dialogOpen && this.readAloud) {
                    this.queueSpeech();
                }
            }

            updateNavButtons() {
                this.prevButton.disabled = this.currentIndex === 0;
                this.nextButton.disabled = this.currentIndex === this.sections.length - 1;
            }

            markVisited(id) {
                if (!this.visited.has(id)) {
                    this.visited.add(id);
                    localStorage.setItem('instVisited', JSON.stringify(Array.from(this.visited)));
                }
                if (this.visited.size === this.sections.length) {
                    this.completed = true;
                    localStorage.setItem('instCompleted', 'true');
                }
                this.updateCompletionState();
            }

            updateCompletionState() {
                this.openButton.classList.toggle('completed', this.completed);
            }

            async queueSpeech(force = false) {
                if (!this.readAloud || !this.dialogOpen) return;
                if (!this.voice || !this.voice.voiceReady) return;
                const section = this.sections[this.currentIndex];
                if (!section || !section.speech) return;
                const token = Symbol('instSpeech');
                this.pendingSpeechToken = token;
                if (force) {
                    await this.voice.cancelAndWait();
                } else {
                    await this.voice.cancelAndWait();
                }
                await new Promise(resolve => setTimeout(resolve, 100));
                if (!this.dialogOpen || !this.readAloud || this.pendingSpeechToken !== token) {
                    return;
                }
                await this.voice.speak(section.speech, this.voice.sessionToken);
            }

            cancelSpeech() {
                this.pendingSpeechToken = null;
                if (this.voice && typeof this.voice.cancelAndWait === 'function') {
                    this.voice.cancelAndWait();
                }
            }

            setupSandboxUI() {
                const panel = document.createElement('div');
                panel.className = 'sandbox-panel';

                const workspaceTitle = document.createElement('h4');
                workspaceTitle.textContent = 'Practice Workspace';
                panel.appendChild(workspaceTitle);

                const controls = document.createElement('div');
                controls.className = 'sandbox-controls';

                const loadBtn = this.createSandboxButton('Load current premise', () => this.loadCurrentPremise());
                const spawnBtn = this.createSandboxButton('Spawn practice premise', () => this.spawnPracticePremise());
                const applyBtn = this.createSandboxButton('Apply Relation Operations', () => this.applySandboxOperations());
                const commitBtn = this.createSandboxButton('Commit to Journal', () => this.commitSandboxJournal());

                controls.append(loadBtn, spawnBtn, applyBtn, commitBtn);
                panel.appendChild(controls);

                const status = document.createElement('div');
                status.className = 'hint';
                panel.appendChild(status);

                const atoms = document.createElement('div');
                atoms.className = 'sandbox-atom-list';
                panel.appendChild(atoms);

                const grid = document.createElement('div');
                grid.className = 'sandbox-letter-grid';
                panel.appendChild(grid);

                const journalTitle = document.createElement('h4');
                journalTitle.textContent = 'Journal';
                panel.appendChild(journalTitle);

                const journal = document.createElement('div');
                journal.className = 'sandbox-journal';
                panel.appendChild(journal);

                this.content.appendChild(panel);

                this.sandboxElements = {
                    status, atoms, grid, journal
                };

                this.renderSandboxPremise();
                this.renderSandboxInputs();
                this.renderSandboxJournal();
                this.updateSandboxStatus('Load the latest premise or spawn a fresh training premise to begin.');
            }

            createSandboxButton(label, handler) {
                const btn = document.createElement('button');
                btn.type = 'button';
                btn.className = 'secondary';
                btn.textContent = label;
                btn.addEventListener('click', handler);
                return btn;
            }

            loadCurrentPremise() {
                const current = this.engine.currentPremises && this.engine.currentPremises.length > 0
                    ? this.engine.currentPremises[this.engine.currentPremises.length - 1]
                    : null;
                if (!current) {
                    this.updateSandboxStatus('No live premise available yet. Start a session or spawn practice.');
                    return;
                }
                this.sandbox.premise = {
                    atoms: current.atoms.map(atom => ({ axis: atom.axis, head: atom.head, tail: atom.tail }))
                };
                this.sandbox.mapping = {};
                this.renderSandboxPremise();
                this.renderSandboxInputs();
                this.updateSandboxStatus('Loaded the latest live premise into the sandbox.');
            }

            spawnPracticePremise() {
                const practice = this.generatePracticePremise();
                this.sandbox.premise = practice;
                this.sandbox.mapping = {};
                this.renderSandboxPremise();
                this.renderSandboxInputs();
                this.updateSandboxStatus('Spawned a fresh training premise.');
            }

            generatePracticePremise() {
                const k = Math.max(2, Math.min(4, this.engine ? this.engine.k : 3));
                const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
                const usedPairs = new Set();
                const atoms = [];
                for (let i = 0; i < k; i++) {
                    let head = letters[Math.floor(Math.random() * letters.length)];
                    let tail = letters[Math.floor(Math.random() * letters.length)];
                    let attempts = 0;
                    while ((head === tail || usedPairs.has(`${head}-${tail}`)) && attempts < 40) {
                        head = letters[Math.floor(Math.random() * letters.length)];
                        tail = letters[Math.floor(Math.random() * letters.length)];
                        attempts += 1;
                    }
                    usedPairs.add(`${head}-${tail}`);
                    const axis = MATCH_AXES[Math.floor(Math.random() * MATCH_AXES.length)];
                    atoms.push({ axis, head, tail });
                }
                return { atoms };
            }

            applySandboxOperations() {
                if (!this.sandbox.premise) {
                    this.updateSandboxStatus('Load or spawn a premise before applying operations.');
                    return;
                }
                let changed = false;
                const mapping = this.sandbox.mapping;
                this.sandbox.premise.atoms.forEach(atom => {
                    const headKey = atom.head;
                    const tailKey = atom.tail;
                    const headValue = (mapping[headKey] || '').trim();
                    const tailValue = (mapping[tailKey] || '').trim();
                    const transform = SANDBOX_TRANSFORMS[atom.axis];
                    if (!transform) return;
                    if (tailValue && !headValue) {
                        mapping[headKey] = transform.forward(tailValue);
                        changed = true;
                    } else if (headValue && !tailValue) {
                        mapping[tailKey] = transform.reverse(headValue);
                        changed = true;
                    }
                });
                this.renderSandboxInputs();
                this.updateSandboxStatus(changed ? 'Applied relation operations. Tweak any concept as needed.' : 'No changes applied. Anchor at least one letter first.');
            }

            commitSandboxJournal() {
                if (!this.sandbox.premise) {
                    this.updateSandboxStatus('Load or spawn a premise before committing to the journal.');
                    return;
                }
                const entries = Object.entries(this.sandbox.mapping)
                    .map(([letter, value]) => [letter, value ? value.trim() : ''])
                    .filter(([, value]) => value.length > 0)
                    .sort((a, b) => a[0].localeCompare(b[0]));
                if (entries.length === 0) {
                    this.updateSandboxStatus('Add at least one mapped concept before committing.');
                    return;
                }
                const record = {
                    timestamp: new Date().toISOString(),
                    premise: this.sandbox.premise.atoms,
                    mapping: entries
                };
                this.sandbox.journal.unshift(record);
                this.sandbox.journal = this.sandbox.journal.slice(0, 20);
                localStorage.setItem('instPracticeJournal', JSON.stringify(this.sandbox.journal));
                this.renderSandboxJournal();
                this.updateSandboxStatus('Mapping committed to journal.');
            }

            renderSandboxPremise() {
                if (!this.sandboxElements) return;
                const atoms = this.sandbox.premise ? this.sandbox.premise.atoms : [];
                if (!atoms || atoms.length === 0) {
                    this.sandboxElements.atoms.textContent = 'No practice premise loaded yet.';
                } else {
                    this.sandboxElements.atoms.textContent = atoms
                        .map(atom => `${atom.head} is ${RELATION_WORDS[atom.axis]} ${atom.tail}`)
                        .join('; ');
                }
            }

            renderSandboxInputs() {
                if (!this.sandboxElements) return;
                const grid = this.sandboxElements.grid;
                grid.innerHTML = '';
                if (!this.sandbox.premise) return;
                const letters = new Set();
                this.sandbox.premise.atoms.forEach(atom => {
                    letters.add(atom.head);
                    letters.add(atom.tail);
                });
                Array.from(letters).sort().forEach(letter => {
                    const cell = document.createElement('div');
                    cell.className = 'sandbox-letter';
                    const label = document.createElement('label');
                    label.textContent = `${letter} concept`;
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.value = this.sandbox.mapping[letter] || '';
                    input.addEventListener('input', (event) => {
                        this.sandbox.mapping[letter] = event.target.value;
                    });
                    cell.append(label, input);
                    grid.appendChild(cell);
                });
            }

            renderSandboxJournal() {
                if (!this.sandboxElements) return;
                const journal = this.sandboxElements.journal;
                journal.innerHTML = '';
                if (this.sandbox.journal.length === 0) {
                    const empty = document.createElement('p');
                    empty.className = 'hint';
                    empty.textContent = 'Your journal entries will appear here.';
                    journal.appendChild(empty);
                    return;
                }
                this.sandbox.journal.forEach(entry => {
                    const item = document.createElement('div');
                    item.className = 'sandbox-journal-entry';
                    const timestamp = document.createElement('div');
                    timestamp.innerHTML = `<strong>${new Date(entry.timestamp).toLocaleString()}</strong>`;
                    const premise = document.createElement('div');
                    premise.textContent = `Premise: ${entry.premise.map(atom => `${atom.head} is ${RELATION_WORDS[atom.axis]} ${atom.tail}`).join('; ')}`;
                    const mapping = document.createElement('div');
                    mapping.innerHTML = entry.mapping.map(([letter, value]) => `<code>${letter}</code>: ${value}`).join('; ');
                    item.append(timestamp, premise, mapping);
                    journal.appendChild(item);
                });
            }

            updateSandboxStatus(message) {
                if (!this.sandboxElements) return;
                this.sandboxElements.status.textContent = message;
            }
        }

        class TestHarness {
            constructor() {
                this.seedManager = new SeedManager();
            }

            async runAll() {
                return [
                    await this.testNovelty(),
                    await this.testContradictions(),
                    await this.testCertificate(),
                    await this.testInputGating(),
                    await this.testProofExamples()
                ];
            }

            async testNovelty() {
                const seeds = [];
                const firstPremises = new Set();
                for (let i = 0; i < 5; i++) {
                    const seed = this.seedManager.generateSessionSeed(false);
                    seeds.push(seed);
                    const state = new GameState(seed, { windowSize: 12 });
                    const solver = new ConstraintSolver();
                    const eq = new EquivalenceEngine(false);
                    const generator = new PremiseGenerator(state, solver, eq);
                    let unique = true;
                    for (let trial = 0; trial < FIRST_N_NOVELTY; trial++) {
                        const result = generator.generate({
                            trialIndex: trial,
                            k: 2,
                            n: 2,
                            plannedMatch: false,
                            nBackPremise: null,
                            middleAtoms: [],
                            avoidLetters: null,
                            allowOverride: false
                        });
                        if (!result) {
                            unique = false;
                            break;
                        }
                        const key = result.premise.toKey();
                        if (firstPremises.has(key)) {
                            unique = false;
                        }
                        firstPremises.add(key);
                        state.novelty.register(state.novelty.buildSignatures(result.premise));
                    }
                }
                return {
                    test: 'Novelty',
                    passed: firstPremises.size >= seeds.length * FIRST_N_NOVELTY,
                    details: 'First six premises differ across restarts'
                };
            }

            async testContradictions() {
                const state = new GameState(12345, { windowSize: 12 });
                const solver = new ConstraintSolver();
                const atoms = [new Atom('N', 'A', 'B'), new Atom('S', 'A', 'B')];
                const sat = solver.evaluate([], atoms);
                return {
                    test: 'Constraint contradictions',
                    passed: !sat.ok,
                    details: 'Opposite relations rejected by SAT core'
                };
            }

            async testCertificate() {
                const premiseA = new Premise([new Atom('N', 'A', 'B'), new Atom('W', 'A', 'C')]);
                const premiseB = new Premise([new Atom('S', 'B', 'A'), new Atom('E', 'C', 'A')]);
                const eq = new EquivalenceEngine(false);
                const certificate = eq.computeCertificate(premiseA, premiseB, []);
                return {
                    test: 'Certificate generation',
                    passed: certificate.match && certificate.certificate.mapping.length === 2,
                    details: 'Invertible mapping generated for 2-atom pair'
                };
            }

            async testInputGating() {
                const dummyEngine = new GameEngine();
                await dummyEngine.voice.initialize();
                const dummySession = {
                    ...newSession(dummyEngine),
                    abort: new AbortController(),
                    trialToken: 1
                };
                session = dummySession;
                const promise = collectResponseSafe(0.05, dummySession.trialToken, dummySession.abort.signal);
                dummySession.abort.abort();
                const result = await promise;
                session = null;
                return {
                    test: 'Input gating',
                    passed: result.type === 'timeout',
                    details: 'Abort resolves response promise as timeout'
                };
            }

            async testProofExamples() {
                const eq = new EquivalenceEngine(false);
                const p1 = new Premise([new Atom('N', 'A', 'B')]);
                const mid = [new Atom('N', 'B', 'C')];
                const p2 = new Premise([new Atom('N', 'A', 'C')]);
                const cert = eq.computeCertificate(p1, p2, mid);
                return {
                    test: 'Proof-based equivalence',
                    passed: !cert.match,
                    details: 'Mid-window derivable relation rejected when transitivity off'
                };
            }
        }

        const engine = new GameEngine();
        const instructions = new InstructionsManager(engine);
        instructions.initialize();
        engine.initialize().then(() => {
            console.log('Game engine initialization complete');
            instructions.updateCompletionState();
            if (instructions.dialogOpen && instructions.readAloud) {
                instructions.queueSpeech(true);
            }
        }).catch((error) => {
            console.error('Game engine initialization failed:', error);
            const statusEl = document.getElementById('status');
            if (statusEl) {
                statusEl.textContent = 'Voice initialization failed. Check console for details.';
            }
            alert('Voice system failed to initialize. Please check your browser settings and reload the page.\n\nError: ' + error.message);
        });
    </script>
</body>
</html>
